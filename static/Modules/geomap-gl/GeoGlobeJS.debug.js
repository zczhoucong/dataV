window.GeoGlobe = {
    singleFile: true
};


//装载GeoSurfJSAPI库文件
(function(){
    /**
     * Namespace: GeoGlobe
     * GeoGlobe 是整个 GeoGlobeSDK 地图 API 的命名空间，本手册中介绍的所有类和对象都通过 GeoGlobe.XXX 的方式调用。
     * 如创建一个 LonLat 对象：new GeoGlobe.LonLat(121.123458,34.534227)。
     */
    window.GeoGlobe = window.GeoGlobe || {};
    window.GeoGlobe.LngLatBounds = {};
    window.GeoGlobe.LngLat = {};
    window.GeoGlobe.Point = mapboxgl.Point;
	window.GeoGlobe.BoxHandler = mapboxgl.BoxHandler;
    window.GeoGlobe.Class = {};
    window.GeoGlobe.Layer = {};
    window.GeoGlobe.Source = {};
    window.GeoGlobe.Event = {};
    window.GeoGlobe.Control = {};
    window.GeoGlobe.Marker = {};
    window.GeoGlobe.Popup = {};
    window.GeoGlobe.Filter = {};
    window.GeoGlobe.Format = {};
    window.GeoGlobe.Analysis = {};
    window.GeoGlobe.Protocol = {};
    window.GeoGlobe.Query = {};
    window.GeoGlobe.Statistic = {};
    window.GeoGlobe.HeatMap ={};
 window.GeoGlobe.LayerGroup ={};
    window.GeoGlobe.Protocol ={};
    window.GeoGlobe.Service = {};
	window.GeoGlobe.DynamicFeature ={};
    window.GeoGlobe.DynamicTrace = {};
    /**
     * Method: getScriptArg
     * 获取script src的参数。
     *
     * Parameters:
     * key - {String} 参数键。
     *
     * Returns:
     * {String} 参数键对应的值。
     */
    GeoGlobe.getScriptArg = function(key){
        var scripts = document.getElementsByTagName("script");
        var script = scripts[scripts.length-1];
        var src = script.src;
        return (src.match(new RegExp("(?:\\?|&)"+key+"=(.*?)(?=&|$)"))||['',null])[1];
    };

    if (!GeoGlobe.singleFile) {
        //导入js文件库
        var scriptName = "GeoGlobeJSAPI.js";
        var jsfiles = [
            "View2D/tool/Class.js",
            "View2D/tool/dom.js",
            "View2D/tool/Util.js",//sw
            "View2D/tool/Proj4cn.js",
            "View2D/tool/ProjAxisOrder.js",
            "View2D/tool/Projection.js",
			"View2D/BaseTypes/BaseTypes.js",//sw
            "View2D/BaseTypes/Pixel.js",//sw
            "View2D/BaseTypes/Size.js",//sw
            "View2D/BaseTypes/Date.js",
            "View2D/tool/Console.js",//sw
			"View2D/tool/Request/Request.js",
            "View2D/tool/Request/XMLHttpRequest.js",
			
            "View2D/map/Map.js",
            "View2D/geo/Lng_Lat_bounds_geo.js",
            "View2D/geo/Lng_Lat_geo.js",
            "View2D/Layer/Layer.js",
            "View2D/Layer/wmsLayer.js",
            "View2D/Layer/wmtsLayer.js",
			 "View2D/Layer/WMTS.js",
            "View2D/Layer/WMS.js",
			"View2D/Layer/GeoTileLayer.js",
			"View2D/Layer/GeoWMTSLayer.js",
            "View2D/Layer/vectortileLayer.js",
            "View2D/Layer/VTS.js",
            "View2D/Layer/RasterLayer.js",
            "View2D/Layer/FillLayer.js",
            "View2D/Layer/CircleLayer.js",
            "View2D/Layer/SymbolLayer.js",
            "View2D/Layer/FillExtrusionLayer.js",
            "View2D/Layer/LineLayer.js",
            "View2D/Layer/BackgroundLayer.js",
            "View2D/Layer/ThematicTileLayer.js",
            "View2D/Layer/CanvasLayer.js",
			"View2D/Layer/TDTLayer.js",
			"View2D/Layer/HotArea.js",
            "View2D/Source/Source.js",
            "View2D/Source/GeoJSONSource.js",
            "View2D/Source/RasterSource.js",
            "View2D/Source/ImageSource.js",
            "View2D/Source/VectorSource.js",
            "View2D/Source/VideoSource.js",
            "View2D/Source/CanvasSource.js",
            "View2D/Marker/Marker.js",
            "View2D/Popup/Popup.js",
            "View2D/control/Control.js",
            "View2D/control/Navigation.js",
            "View2D/control/Attribution.js",
            "View2D/control/Scale.js",
            "View2D/control/Geolocate.js",
            "View2D/control/MapContextMenu.js",
            "View2D/event/Event.js",
            "View2D/event/mapMouseEvent.js",
            "View2D/event/mapTouchEvent.js",
            "View2D/event/mapDataEvent.js",
            "View2D/event/mapBoxZoomEvent.js",
            "View2D/handler/Handler.js",
            "View2D/handler/BoxZoomHandler.js",
            "View2D/handler/DoubleClickZoomHandler.js",
            "View2D/handler/DragPanHandler.js",
            "View2D/handler/DragRotateHandler.js",
            "View2D/handler/KeyboardHandler.js",
            "View2D/handler/ScrollZoomHandler.js",
            "View2D/handler/TouchZoomRotateHandler.js",
            "View2D/AutoFeature/DynamicTrace.js",
            "View2D/AutoFeature/DynamicFeature.js",
			
			"View2D/Geometry/Geometry.js",//sw
            "View2D/Geometry/Collection.js",//sw
            "View2D/Geometry/Point.js",//sw
            "View2D/Geometry/MultiPoint.js",//sw
            "View2D/Geometry/Curve.js",//sw
            "View2D/Geometry/LineString.js",//sw
            "View2D/Geometry/LinearRing.js",//sw
            "View2D/Geometry/Polygon.js",//sw
            "View2D/Geometry/MultiLineString.js",//sw
            "View2D/Geometry/MultiPolygon.js",//sw
			"View2D/Feature/Feature.js",//sw
			//"OpenLayers/Strategy.js",
			"View2D/Filter/Filter.js",
			"View2D/Filter/FeatureId.js",
            "View2D/Filter/Logical.js",
            "View2D/Filter/Comparison.js",
            "View2D/Filter/Spatial.js",
            "View2D/Filter/Function.js",
			"View2D/Protocol/Protocol.js",
			"View2D/Protocol/HTTP.js",
			"View2D/Protocol/WFS.js",
            "View2D/Protocol/WFS/v1.js",
            "View2D/Protocol/WFS/v1_0_0.js",
            "View2D/Protocol/WFS/v1_1_0.js",
			"View2D/Protocol/CSW.js",
            "View2D/Protocol/CSW/v2_0_2.js",
			"View2D/Protocol/Script.js",
		
			"View2D/Format/Format.js",
            "View2D/Format/XML.js",
            "View2D/Format/XML/VersionedOGC.js",
	
			"View2D/Format/GML.js",
            "View2D/Format/GML/Base.js",
            "View2D/Format/GML/v2.js",
            "View2D/Format/GML/v3.js",
			"View2D/Format/KML.js",//sp
            "View2D/Format/OWSCommon.js",//sp
            "View2D/Format/OWSCommon/v1.js",//sp
            "View2D/Format/OWSCommon/v1_0_0.js",//sp
            "View2D/Format/OWSCommon/v1_1_0.js",//sp
			"View2D/Format/WFSCapabilities.js",
            "View2D/Format/WFSCapabilities/v1.js",
            "View2D/Format/WFSCapabilities/v1_0_0.js",
            "View2D/Format/WFSCapabilities/v1_1_0.js",
            "View2D/Format/WFSDescribeFeatureType.js",
            "View2D/Format/WKT.js",//sp
            "View2D/Format/CQL.js",
			"View2D/Format/Filter.js",
            "View2D/Format/Filter/v1.js",
            "View2D/Format/Filter/v1_0_0.js",
            "View2D/Format/Filter/v1_1_0.js",
			"View2D/Format/WFST.js",
            "View2D/Format/WFST/v1.js",
            "View2D/Format/WFST/v1_0_0.js",
            "View2D/Format/WFST/v1_1_0.js",
			"View2D/Format/JSON.js",
            "View2D/Format/GeoJSON.js",
			"View2D/Format/Util/WMTS.js",
            "View2D/Format/Util/WMS.js",
            "View2D/Format/Util/VTS.js",
			"View2D/Format/WMSCapabilities.js",
            "View2D/Format/WMSCapabilities/v1.js",
            "View2D/Format/WMSCapabilities/v1_1.js",
            "View2D/Format/WMSCapabilities/v1_1_0.js",
            "View2D/Format/WMSCapabilities/v1_1_1.js",
            "View2D/Format/WMSCapabilities/v1_1_1_WMSC.js",
            "View2D/Format/WMSCapabilities/v1_3.js",
            "View2D/Format/WMSCapabilities/v1_3_0.js",
            "View2D/Format/WMSUtil.js",
			
            "View2D/Format/WMTSCapabilities.js",
			"View2D/Format/WMTSCapabilities/v1_0_0.js",
            "View2D/Format/WMTSUtil.js",
			"View2D/Format/VTSCapabilities.js",
            "View2D/Format/VTSCapabilities/v1_0_0.js",
			
            "View2D/Format/WPSCapabilities.js",//sp
            "View2D/Format/WPSCapabilities/v1_0_0.js",//sp
			"View2D/Format/WCSGetCoverage.js",//sp
			"View2D/Format/WPSExecute.js",//sp
			"View2D/Format/OGCExceptionReport.js",//sw
			"View2D/Format/QueryStringFilter.js",//sp
			"View2D/Format/BusCapabilities.js",//sp
			"View2D/Format/XML2JSON.js",//sp
			"View2D/Format/CSWGetRecords.js",
            "View2D/Format/CSWGetRecords/v2_0_2.js",
            "View2D/Format/QueryStringFilter.js",
            "View2D/Format/X2JS.js",
			
			"View2D/Analysis/BufferAnalysis.js",//sp
			"View2D/Analysis/GetFeature.js",//sp
			"View2D/Analysis/SpatialAnalysis.js",//sp
			"View2D/Analysis/CoreBufferAnalysis.js",//sp
			"View2D/Query/Service.js",//sp
			"View2D/Query/RouteQuery.js",//sp
			"View2D/Query/RoutesResult.js",//sp
			"View2D/Query/RouteInfoResult.js",//sp
			"View2D/Query/BusQuery.js",//sp
			"View2D/Query/WFSQuery.js",
			"View2D/Query/GeoCodingQuery.js",
			"View2D/Query/GeoCodingQuery/v1.js",
			"View2D/Query/GeoCodingQuery/v1_0_0.js",
			"View2D/Query/GeoCodingQuery/v1_1_0.js",
			//"View2D/Query/GEFSQuery.js",
			//"View2D/Query/GEFSQuery/v1.js",
			//"View2D/Query/GEFSQuery/v1_0_0.js",
			"View2D/Heatmap/HeatMap.js",
"View2D/BaseLayerGroup/BaseLayerGroup.js",
            "View2D/Service/Service.js",
            "View2D/Service/WFST.js",
			"View2D/Service/CTS.js",
			"View2D/Service/VTS.js",
            "View2D/Service/WMS.js",
            "View2D/Service/WMTS.js",
            "View2D/Service/DTJ.js",
            "View2D/Service/Fonts.js",
			"View2D/Statistics/GeoStatisticsService.js",

			"View2D/ElementContainer/ElementContainer.js",
			"View2D/ElementContainer/MaptalksEC.js",
			
			"View2D/tool/Lang.js",
            "View2D/tool/Lang/en.js",
            "View2D/tool/Lang/zh-CN.js"
        ];

        var scriptLocation = "";
        var isGlb = new RegExp("(^|(.*?\\/))(" + scriptName + ")(\\?|$)");

        var scripts = document.getElementsByTagName('script');
        for (var i = 0, len = scripts.length; i < len; i++) {
            var src = scripts[i].getAttribute('src');
            if (src) {
                var match = src.match(isGlb);
                if (match) {
                    scriptLocation = match[1];
                    break;
                }
            }
        }

        var allScriptTags = new Array(jsfiles.length);
        for (var i = 0, len = jsfiles.length; i < len; i++) {
            allScriptTags[i] = "<script src='" + scriptLocation + jsfiles[i] + "'></script>";
        }
        if (allScriptTags.length > 0) {
            document.write(allScriptTags.join(""));
        }
    }
    function removeNode(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }

    /**
     * Property: scriptName
     * {String} GeoGlobeJSAPI脚本文件名，默认值为"GeoGlobeJSAPI.js"。当前使用Geo.getScriptLocation方法
     * 时，该方法将依据本属性值获取GeoGlobeJSAPI所在目录路径。如果引入GeoGlobeJSAPI所用的脚本文件名
     * 不为默认值"GeoGlobeJSAPI.js"，用户可以根据实际情况自己修改。
     */
    GeoGlobe.scriptName = (!GeoGlobe.singleFile) ? "GeoGlobeJSAPI/GeoGlobeJSAPI.js" : "GeoGlobeJS.min.js";

    /**
     * Method: getScriptLocation
     * 获取GeoGlobeJSAPI脚本文件名库脚本文件所在路径。
     *
     * Returns:
     * {String} GeoGlobeJSAPI脚本文件所在路径。
     */
    GeoGlobe.getScriptLocation = function () {
        var scriptLocation = "";
        var isGV = new RegExp("(^|(.*?\\/))(" + GeoGlobe.scriptName + ")(\\?|$)");

        var scripts = document.getElementsByTagName('script');
        for (var i=0, len=scripts.length; i<len; i++) {
            var src = scripts[i].getAttribute('src');
            if (src) {
                var match = src.match(isGV);
                if(match) {
                    scriptLocation = match[1];
                    break;
                }
            }
        }
        return scriptLocation;
    };

    /**
     * Property: imagesPath
     * {String} 指定图片所在路径,三维插件只能接受绝对地址的图片，此处图片路径如:http:www.geostar.com.cn/images/ 或 c:\\images\\。
     */
    GeoGlobe.imagesPath = "";

    /**
     * Method: createNS
     * 创建名字空间,如果指定名字空间中的某一级已经存在不会覆盖已有内容。
     *
     * Parameters:
     * ns - {String} 名称空间。
     *
     */
    GeoGlobe.createNS = function(ns){
        var nsArr = ns.split(".");
        var currObj = window;
        for(var i=0; i<nsArr.length; i++){
            if(!currObj[nsArr[i]]){
                currObj[nsArr[i]] = {};
            }
            currObj = currObj[nsArr[i]];
        }
    };
	
	/**
	 * Property: VERSION_NUMBER
	 * GeoGlobeSDK JS API的版本号。
	 */
	GeoGlobe.VERSION_NUMBER = "GeoGlobeJSAPI 6.4 -- $Version: 1.40.180417 build-20180417 $";
})()


/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires OpenLayers/SingleFile.js
 */

/**
 * Constructor: OpenLayers.Class
 * Base class used to construct all other classes. Includes support for 
 *     multiple inheritance. 
 *     
 * This constructor is new in OpenLayers 2.5.  At OpenLayers 3.0, the old 
 *     syntax for creating classes and dealing with inheritance 
 *     will be removed.
 * 
 * To create a new OpenLayers-style class, use the following syntax:
 * (code)
 *     var MyClass = OpenLayers.Class(prototype);
 * (end)
 *
 * To create a new OpenLayers-style class with multiple inheritance, use the
 *     following syntax:
 * (code)
 *     var MyClass = OpenLayers.Class(Class1, Class2, prototype);
 * (end)
 * 
 * Note that instanceof reflection will only reveal Class1 as superclass.
 *
 */
GeoGlobe.Class = function() {
    var len = arguments.length;
    var P = arguments[0];
    var F = arguments[len-1];

    var C = typeof F.initialize == "function" ?
        F.initialize :
        function(){ P.prototype.initialize.apply(this, arguments); };

    if (len > 1) {
        var newArgs = [C, P].concat(
                Array.prototype.slice.call(arguments).slice(1, len-1), F);
        //GeoGlobe.inherit.apply(null, newArgs);
    } else {
        C.prototype = F;
    }
    return C;
};
GeoGlobe.Class4OL = function() {
    var len = arguments.length;
    var P = arguments[0];
    var F = arguments[len-1];

    var C = typeof F.initialize == "function" ?
        F.initialize :
        function(){ P.prototype.initialize.apply(this, arguments); };

    if (len > 1) {
        var newArgs = [C, P].concat(
                Array.prototype.slice.call(arguments).slice(1, len-1), F);
        GeoGlobe.inherit.apply(null, newArgs);
    } else {
        C.prototype = F;
    }
    return C;
};

/**
 * Function: OpenLayers.inherit
 *
 * Parameters:
 * C - {Object} the class that inherits
 * P - {Object} the superclass to inherit from
 *
 * In addition to the mandatory C and P parameters, an arbitrary number of
 * objects can be passed, which will extend C.
 */
GeoGlobe.inherit = function(C, P) {
   var F = function() {};
   F.prototype = P.prototype;
   C.prototype = new F;
   var i, l, o;
   for(i=2, l=arguments.length; i<l; i++) {
       o = arguments[i];
       if(typeof o === "function") {
           o = o.prototype;
       }
       GeoGlobe.Util.extend(C.prototype, o);
   }
};

/**
 * APIFunction: extend
 * Copy all properties of a source object to a destination object.  Modifies
 *     the passed in destination object.  Any properties on the source object
 *     that are set to undefined will not be (re)set on the destination object.
 *
 * Parameters:
 * destination - {Object} The object that will be modified
 * source - {Object} The object with properties to be set on the destination
 *
 * Returns:
 * {Object} The destination object.
 */
GeoGlobe.Util = GeoGlobe.Util || {};
GeoGlobe.Util.extend = function(destination, source) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            var value = source[property];
            if (value !== undefined) {
                destination[property] = value;
            }
        }

        /**
         * IE doesn't include the toString property when iterating over an object's
         * properties with the for(property in object) syntax.  Explicitly check if
         * the source has its own toString property.
         */

        /*
         * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
         * prototype object" when calling hawOwnProperty if the source object
         * is an instance of window.Event.
         */

        var sourceIsEvt = typeof window.Event == "function"
                          && source instanceof window.Event;

        if (!sourceIsEvt
           && source.hasOwnProperty && source.hasOwnProperty("toString")) {
            destination.toString = source.toString;
        }
    }
    return destination;
};
(function(){
	GeoGlobe.DOM = GeoGlobe.DOM || {};
	GeoGlobe.DOM.create = function (tagName, className, container) {
	    var el = window.document.createElement(tagName);
	    if (className) el.className = className;
	    if (container) container.appendChild(el);
	    return el;
	};
	
	var docStyle = window.document.documentElement.style;
	
	function testProp(props) {
	    for (var i = 0; i < props.length; i++) {
	        if (props[i] in docStyle) {
	            return props[i];
	        }
	    }
	    return props[0];
	}
	
	var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
	    userSelect;
	GeoGlobe.DOM.disableDrag = function () {
	    if (selectProp) {
	        userSelect = docStyle[selectProp];
	        docStyle[selectProp] = 'none';
	    }
	};
	GeoGlobe.DOM.enableDrag = function () {
	    if (selectProp) {
	        docStyle[selectProp] = userSelect;
	    }
	};
	
	var transformProp = testProp(['transform', 'WebkitTransform']);
	GeoGlobe.DOM.setTransform = function(el, value) {
	    el.style[transformProp] = value;
	};
	
	// Suppress the next click, but only if it's immediate.
	function suppressClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    window.removeEventListener('click', suppressClick, true);
	}
	GeoGlobe.DOM.suppressClick = function() {
	    window.addEventListener('click', suppressClick, true);
	    window.setTimeout(function() {
	        window.removeEventListener('click', suppressClick, true);
	    }, 0);
	};
	
	GeoGlobe.DOM.mousePos = function (el, e) {
	    var rect = el.getBoundingClientRect();
	    e = e.touches ? e.touches[0] : e;
	    return new mapboxgl.Point(
	        e.clientX - rect.left - el.clientLeft,
	        e.clientY - rect.top - el.clientTop
	    );
	};
	
	GeoGlobe.DOM.touchPos = function (el, e) {
	    var rect = el.getBoundingClientRect(),
	        points = [];
	    var touches = (e.type === 'touchend') ? e.changedTouches : e.touches;
	    for (var i = 0; i < touches.length; i++) {
	        points.push(new mapboxgl.Point(
	            touches[i].clientX - rect.left - el.clientLeft,
	            touches[i].clientY - rect.top - el.clientTop
	        ));
	    }
	    return points;
	};
	
	GeoGlobe.DOM.remove = function(node) {
	    if (node.parentNode) {
	        node.parentNode.removeChild(node);
	    }
	};
})();/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/BaseTypes/BaseTypes.js
 * @requires View2D/geo/Lng_Lat_bounds_geo.js
 * @requires View2D/geo/Lng_Lat_geo.js
 * @requires View2D/BaseTypes/Element.js
 * @requires View2D/BaseTypes/Pixel.js
 * @requires View2D/BaseTypes/Size.js
 * @requires View2D/Lang.js
 */

/**
 * Namespace: Util
 * 常用的工具方法。
 */
GeoGlobe.Util = GeoGlobe.Util || {};

/** 
 * Function: getElement
 * This is the old $() from prototype
 *
 * Parameters:
 * e - {String or DOMElement or Window}
 *
 * Returns:
 * {Array(DOMElement) or DOMElement}
 */
GeoGlobe.Util.getElement = function() {
    var elements = [];

    for (var i=0, len=arguments.length; i<len; i++) {
        var element = arguments[i];
        if (typeof element == 'string') {
            element = document.getElementById(element);
        }
        if (arguments.length == 1) {
            return element;
        }
        elements.push(element);
    }
    return elements;
};

/**
 * Function: isElement
 * A cross-browser implementation of "e instanceof Element".
 *
 * Parameters:
 * o - {Object} The object to test.
 *
 * Returns:
 * {Boolean}
 */
GeoGlobe.Util.isElement = function(o) {
    return !!(o && o.nodeType === 1);
};

/**
 * Function: isArray
 * Tests that the provided object is an array.
 * This test handles the cross-IFRAME case not caught
 * by "a instanceof Array" and should be used instead.
 * 
 * Parameters:
 * a - {Object} the object test.
 * 
 * Returns:
 * {Boolean} true if the object is an array.
 */
GeoGlobe.Util.isArray = function(a) {
    return (Object.prototype.toString.call(a) === '[object Array]');
};

/** 
 * Function: removeItem
 * Remove an object from an array. Iterates through the array
 *     to find the item, then removes it.
 *
 * Parameters:
 * array - {Array}
 * item - {Object}
 * 
 * Returns:
 * {Array} A reference to the array
 */
GeoGlobe.Util.removeItem = function(array, item) {
    for(var i = array.length - 1; i >= 0; i--) {
        if(array[i] == item) {
            array.splice(i,1);
            //break;more than once??
        }
    }
    return array;
};

/** 
 * Function: indexOf
 * Seems to exist already in FF, but not in MOZ.
 * 
 * Parameters:
 * array - {Array}
 * obj - {*}
 * 
 * Returns:
 * {Integer} The index at which the first object was found in the array.
 *           If not found, returns -1.
 */
GeoGlobe.Util.indexOf = function(array, obj) {
    // use the build-in function if available.
    if (typeof array.indexOf == "function") {
        return array.indexOf(obj);
    } else {
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] == obj) {
                return i;
            }
        }
        return -1;   
    }
};


/**
 * Property: dotless
 * {RegExp}
 * Compiled regular expression to match dots (".").  This is used for replacing
 *     dots in identifiers.  Because object identifiers are frequently used for
 *     DOM element identifiers by the library, we avoid using dots to make for
 *     more sensible CSS selectors.
 *
 * TODO: Use a module pattern to avoid bloating the API with stuff like this.
 */
GeoGlobe.Util.dotless = /\./g;

/**
 * Function: modifyDOMElement
 * 
 * Modifies many properties of a DOM element all at once.  Passing in 
 * null to an individual parameter will avoid setting the attribute.
 *
 * Parameters:
 * element - {DOMElement} DOM element to modify.
 * id - {String} The element id attribute to set.  Note that dots (".") will be
 *     replaced with underscore ("_") in setting the element id.
 * px - {<GeoGlobe.Pixel>|Object} The element left and top position,
 *                                  GeoGlobe.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<GeoGlobe.Size>|Object} The element width and height,
 *                                 GeoGlobe.Size or an object with a
 *                                 'w' and 'h' properties.
 * position - {String}       The position attribute.  eg: absolute, 
 *                           relative, etc.
 * border - {String}         The style.border attribute.  eg:
 *                           solid black 2px
 * overflow - {String}       The style.overview attribute.  
 * opacity - {Float}         Fractional value (0.0 - 1.0)
 */
/*
GeoGlobe.Util.modifyDOMElement = function(element, id, px, sz, position, 
                                            border, overflow, opacity) {

    if (id) {
        element.id = id.replace(GeoGlobe.Util.dotless, "_");
    }
    if (px) {
        element.style.left = px.x + "px";
        element.style.top = px.y + "px";
    }
    if (sz) {
        element.style.width = sz.w + "px";
        element.style.height = sz.h + "px";
    }
    if (position) {
        element.style.position = position;
    }
    if (border) {
        element.style.border = border;
    }
    if (overflow) {
        element.style.overflow = overflow;
    }
    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
        element.style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
        element.style.opacity = opacity;
    } else if (parseFloat(opacity) == 1.0) {
        element.style.filter = '';
        element.style.opacity = '';
    }
};
*/
/** 
 * Function: createDiv
 * Creates a new div and optionally set some standard attributes.
 * Null may be passed to each parameter if you do not wish to
 * set a particular attribute.
 * Note - zIndex is NOT set on the resulting div.
 * 
 * Parameters:
 * id - {String} An identifier for this element.  If no id is
 *               passed an identifier will be created 
 *               automatically.  Note that dots (".") will be replaced with
 *               underscore ("_") when generating ids.
 * px - {<GeoGlobe.Pixel>|Object} The element left and top position,
 *                                  GeoGlobe.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<GeoGlobe.Size>|Object} The element width and height,
 *                                 GeoGlobe.Size or an object with a
 *                                 'w' and 'h' properties.
 * imgURL - {String} A url pointing to an image to use as a 
 *                   background image.
 * position - {String} The style.position value. eg: absolute,
 *                     relative etc.
 * border - {String} The the style.border value. 
 *                   eg: 2px solid black
 * overflow - {String} The style.overflow value. Eg. hidden
 * opacity - {Float} Fractional value (0.0 - 1.0)
 * 
 * Returns: 
 * {DOMElement} A DOM Div created with the specified attributes.
 */
/*
GeoGlobe.Util.createDiv = function(id, px, sz, imgURL, position, 
                                     border, overflow, opacity) {

    var dom = document.createElement('div');

    if (imgURL) {
        dom.style.backgroundImage = 'url(' + imgURL + ')';
    }

    //set generic properties
    if (!id) {
        id = GeoGlobe.Util.createUniqueID("GeoGlobeDiv");
    }
    if (!position) {
        position = "absolute";
    }
    GeoGlobe.Util.modifyDOMElement(dom, id, px, sz, position, 
                                     border, overflow, opacity);

    return dom;
};
*/
/**
 * Function: createImage
 * Creates an img element with specific attribute values.
 *  
 * Parameters:
 * id - {String} The id field for the img.  If none assigned one will be
 *               automatically generated.
 * px - {<GeoGlobe.Pixel>|Object} The element left and top position,
 *                                  GeoGlobe.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<GeoGlobe.Size>|Object} The element width and height,
 *                                 GeoGlobe.Size or an object with a
 *                                 'w' and 'h' properties.
 * imgURL - {String} The url to use as the image source.
 * position - {String} The style.position value.
 * border - {String} The border to place around the image.
 * opacity - {Float} Fractional value (0.0 - 1.0)
 * delayDisplay - {Boolean} If true waits until the image has been
 *                          loaded.
 * 
 * Returns:
 * {DOMElement} A DOM Image created with the specified attributes.
 */
/*
GeoGlobe.Util.createImage = function(id, px, sz, imgURL, position, border,
                                       opacity, delayDisplay) {

    var image = document.createElement("img");

    //set generic properties
    if (!id) {
        id = GeoGlobe.Util.createUniqueID("OpenLayersDiv");
    }
    if (!position) {
        position = "relative";
    }
    GeoGlobe.Util.modifyDOMElement(image, id, px, sz, position, 
                                     border, null, opacity);

    if (delayDisplay) {
        image.style.display = "none";
        function display() {
            image.style.display = "";
            OpenLayers.Event.stopObservingElement(image);
        }
        OpenLayers.Event.observe(image, "load", display);
        OpenLayers.Event.observe(image, "error", display);
    }
    
    //set special properties
    image.style.alt = id;
    image.galleryImg = "no";
    if (imgURL) {
        image.src = imgURL;
    }
        
    return image;
};
*/

/**
 * Property: IMAGE_RELOAD_ATTEMPTS
 * {Integer} How many times should we try to reload an image before giving up?
 *           Default is 0
 */
GeoGlobe.IMAGE_RELOAD_ATTEMPTS = 0;

/**
 * Property: alphaHackNeeded
 * {Boolean} true if the png alpha hack is necessary and possible, false otherwise.
 */
GeoGlobe.Util.alphaHackNeeded = null;

/**
 * Function: alphaHack
 * Checks whether it's necessary (and possible) to use the png alpha
 * hack which allows alpha transparency for png images under Internet
 * Explorer.
 * 
 * Returns:
 * {Boolean} true if the png alpha hack is necessary and possible, false otherwise.
 */
GeoGlobe.Util.alphaHack = function() {
    if (GeoGlobe.Util.alphaHackNeeded == null) {
        var arVersion = navigator.appVersion.split("MSIE");
        var version = parseFloat(arVersion[1]);
        var filter = false;
    
        // IEs4Lin dies when trying to access document.body.filters, because 
        // the property is there, but requires a DLL that can't be provided. This
        // means that we need to wrap this in a try/catch so that this can
        // continue.
    
        try { 
            filter = !!(document.body.filters);
        } catch (e) {}    
    
        GeoGlobe.Util.alphaHackNeeded = (filter && 
                                           (version >= 5.5) && (version < 7));
    }
    return GeoGlobe.Util.alphaHackNeeded;
};

/** 
 * Function: modifyAlphaImageDiv
 * 
 * Parameters:
 * div - {DOMElement} Div containing Alpha-adjusted Image
 * id - {String}
 * px - {<GeoGlobe.Pixel>|Object} GeoGlobe.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<GeoGlobe.Size>|Object} GeoGlobe.Size or an object with
 *                                 a 'w' and 'h' properties.
 * imgURL - {String}
 * position - {String}
 * border - {String}
 * sizing - {String} 'crop', 'scale', or 'image'. Default is "scale"
 * opacity - {Float} Fractional value (0.0 - 1.0)
 */ 
/*
GeoGlobe.Util.modifyAlphaImageDiv = function(div, id, px, sz, imgURL, 
                                               position, border, sizing, 
                                               opacity) {

    GeoGlobe.Util.modifyDOMElement(div, id, px, sz, position,
                                     null, null, opacity);

    var img = div.childNodes[0];

    if (imgURL) {
        img.src = imgURL;
    }
    GeoGlobe.Util.modifyDOMElement(img, div.id + "_innerImage", null, sz, 
                                     "relative", border);
    
    if (GeoGlobe.Util.alphaHack()) {
        if(div.style.display != "none") {
            div.style.display = "inline-block";
        }
        if (sizing == null) {
            sizing = "scale";
        }
        
        div.style.filter = "progid:DXImageTransform.Microsoft" +
                           ".AlphaImageLoader(src='" + img.src + "', " +
                           "sizingMethod='" + sizing + "')";
        if (parseFloat(div.style.opacity) >= 0.0 && 
            parseFloat(div.style.opacity) < 1.0) {
            div.style.filter += " alpha(opacity=" + div.style.opacity * 100 + ")";
        }

        img.style.filter = "alpha(opacity=0)";
    }
};
*/
/** 
 * Function: createAlphaImageDiv
 * 
 * Parameters:
 * id - {String}
 * px - {<GeoGlobe.Pixel>|Object} GeoGlobe.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<GeoGlobe.Size>|Object} GeoGlobe.Size or an object with
 *                                 a 'w' and 'h' properties.
 * imgURL - {String}
 * position - {String}
 * border - {String}
 * sizing - {String} 'crop', 'scale', or 'image'. Default is "scale"
 * opacity - {Float} Fractional value (0.0 - 1.0)
 * delayDisplay - {Boolean} If true waits until the image has been
 *                          loaded.
 * 
 * Returns:
 * {DOMElement} A DOM Div created with a DOM Image inside it. If the hack is 
 *              needed for transparency in IE, it is added.
 */
/*
GeoGlobe.Util.createAlphaImageDiv = function(id, px, sz, imgURL, 
                                               position, border, sizing, 
                                               opacity, delayDisplay) {
    
    var div = GeoGlobe.Util.createDiv();
    var img = GeoGlobe.Util.createImage(null, null, null, null, null, null, 
                                          null, delayDisplay);
    img.className = "olAlphaImg";
    div.appendChild(img);

    GeoGlobe.Util.modifyAlphaImageDiv(div, id, px, sz, imgURL, position, 
                                        border, sizing, opacity);
    
    return div;
};
*/

/** 
 * Function: upperCaseObject
 * Creates a new hashtable and copies over all the keys from the 
 *     passed-in object, but storing them under an uppercased
 *     version of the key at which they were stored.
 * 
 * Parameters: 
 * object - {Object}
 * 
 * Returns: 
 * {Object} A new Object with all the same keys but uppercased
 */
GeoGlobe.Util.upperCaseObject = function (object) {
    var uObject = {};
    for (var key in object) {
        uObject[key.toUpperCase()] = object[key];
    }
    return uObject;
};

/** 
 * Function: applyDefaults
 * Takes an object and copies any properties that don't exist from
 *     another properties, by analogy with GeoGlobe.Util.extend() from
 *     Prototype.js.
 * 
 * Parameters:
 * to - {Object} The destination object.
 * from - {Object} The source object.  Any properties of this object that
 *     are undefined in the to object will be set on the to object.
 *
 * Returns:
 * {Object} A reference to the to object.  Note that the to argument is modified
 *     in place and returned by this function.
 */
GeoGlobe.Util.applyDefaults = function (to, from) {
    to = to || {};
    /*
     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
     * prototype object" when calling hawOwnProperty if the source object is an
     * instance of window.Event.
     */
    var fromIsEvt = typeof window.Event == "function"
                    && from instanceof window.Event;

    for (var key in from) {
        if (to[key] === undefined ||
            (!fromIsEvt && from.hasOwnProperty
             && from.hasOwnProperty(key) && !to.hasOwnProperty(key))) {
            to[key] = from[key];
        }
    }
    /**
     * IE doesn't include the toString property when iterating over an object's
     * properties with the for(property in object) syntax.  Explicitly check if
     * the source has its own toString property.
     */
    if(!fromIsEvt && from && from.hasOwnProperty
       && from.hasOwnProperty('toString') && !to.hasOwnProperty('toString')) {
        to.toString = from.toString;
    }
    
    return to;
};

/**
 * Function: getParameterString
 * 
 * Parameters:
 * params - {Object}
 * 
 * Returns:
 * {String} A concatenation of the properties of an object in 
 *          http parameter notation. 
 *          (ex. <i>"key1=value1&key2=value2&key3=value3"</i>)
 *          If a parameter is actually a list, that parameter will then
 *          be set to a comma-seperated list of values (foo,bar) instead
 *          of being URL escaped (foo%3Abar). 
 */
GeoGlobe.Util.getParameterString = function(params) {
    var paramsArray = [];
    
    for (var key in params) {
      var value = params[key];
      if ((value != null) && (typeof value != 'function')) {
        var encodedValue;
        if (typeof value == 'object' && value.constructor == Array) {
          /* value is an array; encode items and separate with "," */
          var encodedItemArray = [];
          var item;
          for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
            item = value[itemIndex];
            encodedItemArray.push(encodeURIComponent(
                (item === null || item === undefined) ? "" : item)
            );
          }
          encodedValue = encodedItemArray.join(",");
        }
        else {
          /* value is a string; simply encode */
          encodedValue = encodeURIComponent(value);
        }
        paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
      }
    }
    
    return paramsArray.join("&");
};

/**
 * Function: urlAppend
 * Appends a parameter string to a url. This function includes the logic for
 * using the appropriate character (none, & or ?) to append to the url before
 * appending the param string.
 * 
 * Parameters:
 * url - {String} The url to append to
 * paramStr - {String} The param string to append
 * 
 * Returns:
 * {String} The new url
 */
GeoGlobe.Util.urlAppend = function(url, paramStr) {
    var newUrl = url;
    if(paramStr) {
        var parts = (url + " ").split(/[?&]/);
        newUrl += (parts.pop() === " " ?
            paramStr :
            parts.length ? "&" + paramStr : "?" + paramStr);
    }
    return newUrl;
};

/** 
 * Function: getImagesLocation
 * 
 * Returns:
 * {String} The fully formatted image location string
 */
GeoGlobe.Util.getImagesLocation = function() {
    return GeoGlobe.ImgPath || (GeoGlobe._getScriptLocation() + "img/");
};

/** 
 * Function: getImageLocation
 * 
 * Returns:
 * {String} The fully formatted location string for a specified image
 */
GeoGlobe.Util.getImageLocation = function(image) {
    return GeoGlobe.Util.getImagesLocation() + image;
};


/** 
 * Function: Try
 * Execute functions until one of them doesn't throw an error. 
 *     Capitalized because "try" is a reserved word in JavaScript.
 *     Taken directly from GeoGlobe.Util.Try()
 * 
 * Parameters:
 * [*] - {Function} Any number of parameters may be passed to Try()
 *    It will attempt to execute each of them until one of them 
 *    successfully executes. 
 *    If none executes successfully, returns null.
 * 
 * Returns:
 * {*} The value returned by the first successfully executed function.
 */
GeoGlobe.Util.Try = function() {
    var returnValue = null;

    for (var i=0, len=arguments.length; i<len; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) {}
    }

    return returnValue;
};

/**
 * Function: getXmlNodeValue
 * 
 * Parameters:
 * node - {XMLNode}
 * 
 * Returns:
 * {String} The text value of the given node, without breaking in firefox or IE
 */
GeoGlobe.Util.getXmlNodeValue = function(node) {
    var val = null;
    GeoGlobe.Util.Try( 
        function() {
            val = node.text;
            if (!val) {
                val = node.textContent;
            }
            if (!val) {
                val = node.firstChild.nodeValue;
            }
        }, 
        function() {
            val = node.textContent;
        }); 
    return val;
};

/** 
 * Function: mouseLeft
 * 
 * Parameters:
 * evt - {Event}
 * div - {HTMLDivElement}
 * 
 * Returns:
 * {Boolean}
 */
GeoGlobe.Util.mouseLeft = function (evt, div) {
    // start with the element to which the mouse has moved
    var target = (evt.relatedTarget) ? evt.relatedTarget : evt.toElement;
    // walk up the DOM tree.
    while (target != div && target != null) {
        target = target.parentNode;
    }
    // if the target we stop at isn't the div, then we've left the div.
    return (target != div);
};

/**
 * Property: precision
 * {Number} The number of significant digits to retain to avoid
 * floating point precision errors.
 *
 * We use 14 as a "safe" default because, although IEEE 754 double floats
 * (standard on most modern operating systems) support up to about 16
 * significant digits, 14 significant digits are sufficient to represent
 * sub-millimeter accuracy in any coordinate system that anyone is likely to
 * use with OpenLayers.
 *
 * If DEFAULT_PRECISION is set to 0, the original non-truncating behavior
 * of OpenLayers <2.8 is preserved. Be aware that this will cause problems
 * with certain projections, e.g. spherical Mercator.
 *
 */
GeoGlobe.Util.DEFAULT_PRECISION = 14;

/**
 * Function: toFloat
 * Convenience method to cast an object to a Number, rounded to the
 * desired floating point precision.
 *
 * Parameters:
 * number    - {Number} The number to cast and round.
 * precision - {Number} An integer suitable for use with
 *      Number.toPrecision(). Defaults to GeoGlobe.Util.DEFAULT_PRECISION.
 *      If set to 0, no rounding is performed.
 *
 * Returns:
 * {Number} The cast, rounded number.
 */
GeoGlobe.Util.toFloat = function (number, precision) {
    if (precision == null) {
        precision = GeoGlobe.Util.DEFAULT_PRECISION;
    }
    if (typeof number !== "number") {
        number = parseFloat(number);
    }
    return precision === 0 ? number :
                             parseFloat(number.toPrecision(precision));
};

/**
 * Function: rad
 * 
 * Parameters:
 * x - {Float}
 * 
 * Returns:
 * {Float}
 */
GeoGlobe.Util.rad = function(x) {return x*Math.PI/180;};

/**
 * Function: deg
 *
 * Parameters:
 * x - {Float}
 *
 * Returns:
 * {Float}
 */
GeoGlobe.Util.deg = function(x) {return x*180/Math.PI;};

/**
 * Property: VincentyConstants
 * {Object} Constants for Vincenty functions.
 */
GeoGlobe.Util.VincentyConstants = {
    a: 6378137,
    b: 6356752.3142,
    f: 1/298.257223563
};

/**
 * APIFunction: distVincenty
 * Given two objects representing points with geographic coordinates, this
 *     calculates the distance between those points on the surface of an
 *     ellipsoid.
 *
 * Parameters:
 * p1 - {<GeoGlobe.LngLat>} (or any object with both .lat, .lng properties)
 * p2 - {<GeoGlobe.LngLat>} (or any object with both .lat, .lng properties)
 *
 * Returns:
 * {Float} The distance (in km) between the two input points as measured on an
 *     ellipsoid.  Note that the input point objects must be in geographic
 *     coordinates (decimal degrees) and the return distance is in kilometers.
 */
GeoGlobe.Util.distVincenty = function(p1, p2) {
    var ct = GeoGlobe.Util.VincentyConstants;
    var a = ct.a, b = ct.b, f = ct.f;

    var L = GeoGlobe.Util.rad(p2.lng - p1.lng);
    var U1 = Math.atan((1-f) * Math.tan(GeoGlobe.Util.rad(p1.lat)));
    var U2 = Math.atan((1-f) * Math.tan(GeoGlobe.Util.rad(p2.lat)));
    var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
    var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
    var lambda = L, lambdaP = 2*Math.PI;
    var iterLimit = 20;
    while (Math.abs(lambda-lambdaP) > 1e-12 && --iterLimit>0) {
        var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
        var sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +
        (cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda));
        if (sinSigma==0) {
            return 0;  // co-incident points
        }
        var cosSigma = sinU1*sinU2 + cosU1*cosU2*cosLambda;
        var sigma = Math.atan2(sinSigma, cosSigma);
        var alpha = Math.asin(cosU1 * cosU2 * sinLambda / sinSigma);
        var cosSqAlpha = Math.cos(alpha) * Math.cos(alpha);
        var cos2SigmaM = cosSigma - 2*sinU1*sinU2/cosSqAlpha;
        var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
        lambdaP = lambda;
        lambda = L + (1-C) * f * Math.sin(alpha) *
        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));
    }
    if (iterLimit==0) {
        return NaN;  // formula failed to converge
    }
    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
    var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
        B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
    var s = b*A*(sigma-deltaSigma);
    var d = s.toFixed(3)/1000; // round to 1mm precision
    return d;
};

/**
 * APIFunction: destinationVincenty
 * Calculate destination point given start point lat/long (numeric degrees),
 * bearing (numeric degrees) & distance (in m).
 * Adapted from Chris Veness work, see
 * http://www.movable-type.co.uk/scripts/latlong-vincenty-direct.html
 *
 * Parameters:
 * lonlat  - {<GeoGlobe.LngLat>} (or any object with both .lat, .lng
 *     properties) The start point.
 * brng     - {Float} The bearing (degrees).
 * dist     - {Float} The ground distance (meters).
 *
 * Returns:
 * {<GeoGlobe.LngLat>} The destination point.
 */
GeoGlobe.Util.destinationVincenty = function(lonlat, brng, dist) {
    var u = GeoGlobe.Util;
    var ct = u.VincentyConstants;
    var a = ct.a, b = ct.b, f = ct.f;

    var lon1 = lonlat.lng;
    var lat1 = lonlat.lat;

    var s = dist;
    var alpha1 = u.rad(brng);
    var sinAlpha1 = Math.sin(alpha1);
    var cosAlpha1 = Math.cos(alpha1);

    var tanU1 = (1-f) * Math.tan(u.rad(lat1));
    var cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1*cosU1;
    var sigma1 = Math.atan2(tanU1, cosAlpha1);
    var sinAlpha = cosU1 * sinAlpha1;
    var cosSqAlpha = 1 - sinAlpha*sinAlpha;
    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));

    var sigma = s / (b*A), sigmaP = 2*Math.PI;
    while (Math.abs(sigma-sigmaP) > 1e-12) {
        var cos2SigmaM = Math.cos(2*sigma1 + sigma);
        var sinSigma = Math.sin(sigma);
        var cosSigma = Math.cos(sigma);
        var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
            B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
        sigmaP = sigma;
        sigma = s / (b*A) + deltaSigma;
    }

    var tmp = sinU1*sinSigma - cosU1*cosSigma*cosAlpha1;
    var lat2 = Math.atan2(sinU1*cosSigma + cosU1*sinSigma*cosAlpha1,
        (1-f)*Math.sqrt(sinAlpha*sinAlpha + tmp*tmp));
    var lambda = Math.atan2(sinSigma*sinAlpha1, cosU1*cosSigma - sinU1*sinSigma*cosAlpha1);
    var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
    var L = lambda - (1-C) * f * sinAlpha *
        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));

    var revAz = Math.atan2(sinAlpha, -tmp);  // final bearing

    return new GeoGlobe.LngLat(lon1+u.deg(L), u.deg(lat2));
};

/**
 * Function: getParameters
 * Parse the parameters from a URL or from the current page itself into a 
 *     JavaScript Object. Note that parameter values with commas are separated
 *     out into an Array.
 * 
 * Parameters:
 * url - {String} Optional url used to extract the query string.
 *                If url is null or is not supplied, query string is taken 
 *                from the page location.
 * options - {Object} Additional options. Optional.
 *
 * Valid options:
 *   splitArgs - {Boolean} Split comma delimited params into arrays? Default is
 *       true.
 * 
 * Returns:
 * {Object} An object of key/value pairs from the query string.
 */
GeoGlobe.Util.getParameters = function(url, options) {
    options = options || {};
    // if no url specified, take it from the location bar
    url = (url === null || url === undefined) ? window.location.href : url;

    //parse out parameters portion of url string
    var paramsString = "";
    if (GeoGlobe.String.contains(url, '?')) {
        var start = url.indexOf('?') + 1;
        var end = GeoGlobe.String.contains(url, "#") ?
                    url.indexOf('#') : url.length;
        paramsString = url.substring(start, end);
    }

    var parameters = {};
    var pairs = paramsString.split(/[&;]/);
    for(var i=0, len=pairs.length; i<len; ++i) {
        var keyValue = pairs[i].split('=');
        if (keyValue[0]) {

            var key = keyValue[0];
            try {
                key = decodeURIComponent(key);
            } catch (err) {
                key = unescape(key);
            }
            
            // being liberal by replacing "+" with " "
            var value = (keyValue[1] || '').replace(/\+/g, " ");

            try {
                value = decodeURIComponent(value);
            } catch (err) {
                value = unescape(value);
            }
            
            // follow OGC convention of comma delimited values
            if (options.splitArgs !== false) {
                value = value.split(",");
            }

            //if there's only one value, do not return as array                    
            if (value.length == 1) {
                value = value[0];
            }                
            
            parameters[key] = value;
         }
     }
    return parameters;
};

/**
 * Property: lastSeqID
 * {Integer} The ever-incrementing count variable.
 *           Used for generating unique ids.
 */
GeoGlobe.Util.lastSeqID = 0;

/**
 * Function: createUniqueID
 * Create a unique identifier for this session.  Each time this function
 *     is called, a counter is incremented.  The return will be the optional
 *     prefix (defaults to "id_") appended with the counter value.
 * 
 * Parameters:
 * prefix - {String} Optional string to prefix unique id. Default is "id_".
 *     Note that dots (".") in the prefix will be replaced with underscore ("_").
 * 
 * Returns:
 * {String} A unique id string, built on the passed in prefix.
 */
GeoGlobe.Util.createUniqueID = function(prefix) {
    if (prefix == null) {
        prefix = "id_";
    } else {
        prefix = prefix.replace(GeoGlobe.Util.dotless, "_");
    }
    GeoGlobe.Util.lastSeqID += 1; 
    return prefix + GeoGlobe.Util.lastSeqID;        
};

/**
 * Constant: INCHES_PER_UNIT
 * {Object} Constant inches per unit -- borrowed from MapServer mapscale.c
 * derivation of nautical miles from http://en.wikipedia.org/wiki/Nautical_mile
 * Includes the full set of units supported by CS-MAP (http://trac.osgeo.org/csmap/)
 * and PROJ.4 (http://trac.osgeo.org/proj/)
 * The hardcoded table is maintain in a CS-MAP source code module named CSdataU.c
 * The hardcoded table of PROJ.4 units are in pj_units.c.
 */
GeoGlobe.INCHES_PER_UNIT = { 
    'inches': 1.0,
    'ft': 12.0,
    'mi': 63360.0,
    'm': 1/0.0254,//39.37,
    'km': 39370,
    'dd': 4374754,
    'yd': 36
};
GeoGlobe.INCHES_PER_UNIT["in"]= GeoGlobe.INCHES_PER_UNIT.inches;
GeoGlobe.INCHES_PER_UNIT["degrees"] = GeoGlobe.INCHES_PER_UNIT.dd;
GeoGlobe.INCHES_PER_UNIT["nmi"] = 1852 * GeoGlobe.INCHES_PER_UNIT.m;

// Units from CS-Map
GeoGlobe.METERS_PER_INCH = 0.02540005080010160020;
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    "Inch": GeoGlobe.INCHES_PER_UNIT.inches,
    "Meter": 1.0 / GeoGlobe.METERS_PER_INCH,   //EPSG:9001
    "Foot": 0.30480060960121920243 / GeoGlobe.METERS_PER_INCH,   //EPSG:9003
    "IFoot": 0.30480000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9002
    "ClarkeFoot": 0.3047972651151 / GeoGlobe.METERS_PER_INCH,   //EPSG:9005
    "SearsFoot": 0.30479947153867624624 / GeoGlobe.METERS_PER_INCH,   //EPSG:9041
    "GoldCoastFoot": 0.30479971018150881758 / GeoGlobe.METERS_PER_INCH,   //EPSG:9094
    "IInch": 0.02540000000000000000 / GeoGlobe.METERS_PER_INCH,
    "MicroInch": 0.00002540000000000000 / GeoGlobe.METERS_PER_INCH,
    "Mil": 0.00000002540000000000 / GeoGlobe.METERS_PER_INCH,
    "Centimeter": 0.01000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Kilometer": 1000.00000000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9036
    "Yard": 0.91440182880365760731 / GeoGlobe.METERS_PER_INCH,
    "SearsYard": 0.914398414616029 / GeoGlobe.METERS_PER_INCH,   //EPSG:9040
    "IndianYard": 0.91439853074444079983 / GeoGlobe.METERS_PER_INCH,   //EPSG:9084
    "IndianYd37": 0.91439523 / GeoGlobe.METERS_PER_INCH,   //EPSG:9085
    "IndianYd62": 0.9143988 / GeoGlobe.METERS_PER_INCH,   //EPSG:9086
    "IndianYd75": 0.9143985 / GeoGlobe.METERS_PER_INCH,   //EPSG:9087
    "IndianFoot": 0.30479951 / GeoGlobe.METERS_PER_INCH,   //EPSG:9080
    "IndianFt37": 0.30479841 / GeoGlobe.METERS_PER_INCH,   //EPSG:9081
    "IndianFt62": 0.3047996 / GeoGlobe.METERS_PER_INCH,   //EPSG:9082
    "IndianFt75": 0.3047995 / GeoGlobe.METERS_PER_INCH,   //EPSG:9083
    "Mile": 1609.34721869443738887477 / GeoGlobe.METERS_PER_INCH,
    "IYard": 0.91440000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9096
    "IMile": 1609.34400000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9093
    "NautM": 1852.00000000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9030
    "Lat-66": 110943.316488932731 / GeoGlobe.METERS_PER_INCH,
    "Lat-83": 110946.25736872234125 / GeoGlobe.METERS_PER_INCH,
    "Decimeter": 0.10000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Millimeter": 0.00100000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Dekameter": 10.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Decameter": 10.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Hectometer": 100.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "GermanMeter": 1.0000135965 / GeoGlobe.METERS_PER_INCH,   //EPSG:9031
    "CaGrid": 0.999738 / GeoGlobe.METERS_PER_INCH,
    "ClarkeChain": 20.1166194976 / GeoGlobe.METERS_PER_INCH,   //EPSG:9038
    "GunterChain": 20.11684023368047 / GeoGlobe.METERS_PER_INCH,   //EPSG:9033
    "BenoitChain": 20.116782494375872 / GeoGlobe.METERS_PER_INCH,   //EPSG:9062
    "SearsChain": 20.11676512155 / GeoGlobe.METERS_PER_INCH,   //EPSG:9042
    "ClarkeLink": 0.201166194976 / GeoGlobe.METERS_PER_INCH,   //EPSG:9039
    "GunterLink": 0.2011684023368047 / GeoGlobe.METERS_PER_INCH,   //EPSG:9034
    "BenoitLink": 0.20116782494375872 / GeoGlobe.METERS_PER_INCH,   //EPSG:9063
    "SearsLink": 0.2011676512155 / GeoGlobe.METERS_PER_INCH,   //EPSG:9043
    "Rod": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "IntnlChain": 20.1168 / GeoGlobe.METERS_PER_INCH,   //EPSG:9097
    "IntnlLink": 0.201168 / GeoGlobe.METERS_PER_INCH,   //EPSG:9098
    "Perch": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "Pole": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "Furlong": 201.1684023368046 / GeoGlobe.METERS_PER_INCH,
    "Rood": 3.778266898 / GeoGlobe.METERS_PER_INCH,
    "CapeFoot": 0.3047972615 / GeoGlobe.METERS_PER_INCH,
    "Brealey": 375.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "ModAmFt": 0.304812252984505969011938 / GeoGlobe.METERS_PER_INCH,
    "Fathom": 1.8288 / GeoGlobe.METERS_PER_INCH,
    "NautM-UK": 1853.184 / GeoGlobe.METERS_PER_INCH,
    "50kilometers": 50000.0 / GeoGlobe.METERS_PER_INCH,
    "150kilometers": 150000.0 / GeoGlobe.METERS_PER_INCH
});

//unit abbreviations supported by PROJ.4
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    "mm": GeoGlobe.INCHES_PER_UNIT["Meter"] / 1000.0,
    "cm": GeoGlobe.INCHES_PER_UNIT["Meter"] / 100.0,
    "dm": GeoGlobe.INCHES_PER_UNIT["Meter"] * 100.0,
    "km": GeoGlobe.INCHES_PER_UNIT["Meter"] * 1000.0,
    "kmi": GeoGlobe.INCHES_PER_UNIT["nmi"],    //International Nautical Mile
    "fath": GeoGlobe.INCHES_PER_UNIT["Fathom"], //International Fathom
    "ch": GeoGlobe.INCHES_PER_UNIT["IntnlChain"],  //International Chain
    "link": GeoGlobe.INCHES_PER_UNIT["IntnlLink"], //International Link
    "us-in": GeoGlobe.INCHES_PER_UNIT["inches"], //U.S. Surveyor's Inch
    "us-ft": GeoGlobe.INCHES_PER_UNIT["Foot"], //U.S. Surveyor's Foot
    "us-yd": GeoGlobe.INCHES_PER_UNIT["Yard"], //U.S. Surveyor's Yard
    "us-ch": GeoGlobe.INCHES_PER_UNIT["GunterChain"], //U.S. Surveyor's Chain
    "us-mi": GeoGlobe.INCHES_PER_UNIT["Mile"],   //U.S. Surveyor's Statute Mile
    "ind-yd": GeoGlobe.INCHES_PER_UNIT["IndianYd37"],  //Indian Yard
    "ind-ft": GeoGlobe.INCHES_PER_UNIT["IndianFt37"],  //Indian Foot
    "ind-ch": 20.11669506 / GeoGlobe.METERS_PER_INCH  //Indian Chain
});

/** 
 * Constant: DOTS_PER_INCH
 * {Integer} 96 (A sensible default)
 */
GeoGlobe.DOTS_PER_INCH = 96;

/**
 * Function: normalizeScale
 * 
 * Parameters:
 * scale - {float}
 * 
 * Returns:
 * {Float} A normalized scale value, in 1 / X format. 
 *         This means that if a value less than one ( already 1/x) is passed
 *         in, it just returns scale directly. Otherwise, it returns 
 *         1 / scale
 */
GeoGlobe.Util.normalizeScale = function (scale) {
    var normScale = (scale > 1.0) ? (1.0 / scale) 
                                  : scale;
    return normScale;
};

/**
 * Function: getResolutionFromScale
 * 
 * Parameters:
 * scale - {Float}
 * units - {String} Index into GeoGlobe.INCHES_PER_UNIT hashtable.
 *                  Default is degrees
 * 
 * Returns:
 * {Float} The corresponding resolution given passed-in scale and unit 
 *     parameters.  If the given scale is falsey, the returned resolution will
 *     be undefined.
 */
GeoGlobe.Util.getResolutionFromScale = function (scale, units) {
    var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = GeoGlobe.Util.normalizeScale(scale);
        resolution = 1 / (normScale * GeoGlobe.INCHES_PER_UNIT[units]
                                        * GeoGlobe.DOTS_PER_INCH);        
    }
    return resolution;
};

/**
 * Function: getScaleFromResolution
 * 
 * Parameters:
 * resolution - {Float}
 * units - {String} Index into GeoGlobe.INCHES_PER_UNIT hashtable.
 *                  Default is degrees
 * 
 * Returns:
 * {Float} The corresponding scale given passed-in resolution and unit 
 *         parameters.
 */
GeoGlobe.Util.getScaleFromResolution = function (resolution, units) {

    if (units == null) {
        units = "degrees";
    }

    var scale = resolution * GeoGlobe.INCHES_PER_UNIT[units] *
                    GeoGlobe.DOTS_PER_INCH;
    return scale;
};

/**
 * Function: pagePosition
 * Calculates the position of an element on the page (see
 * http://code.google.com/p/doctype/wiki/ArticlePageOffset)
 *
 * GeoGlobe.Util.pagePosition is based on Yahoo's getXY method, which is
 * Copyright (c) 2006, Yahoo! Inc.
 * All rights reserved.
 * 
 * Redistribution and use of this software in source and binary forms, with or
 * without modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Yahoo! Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission of Yahoo! Inc.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Parameters:
 * forElement - {DOMElement}
 * 
 * Returns:
 * {Array} two item array, Left value then Top value.
 */
GeoGlobe.Util.pagePosition =  function(forElement) {
    // NOTE: If element is hidden (display none or disconnected or any the
    // ancestors are hidden) we get (0,0) by default but we still do the
    // accumulation of scroll position.

    var pos = [0, 0];
    var viewportElement = GeoGlobe.Util.getViewportElement();
    if (!forElement || forElement == window || forElement == viewportElement) {
        // viewport is always at 0,0 as that defined the coordinate system for
        // this function - this avoids special case checks in the code below
        return pos;
    }

    // Gecko browsers normally use getBoxObjectFor to calculate the position.
    // When invoked for an element with an implicit absolute position though it
    // can be off by one. Therefore the recursive implementation is used in
    // those (relatively rare) cases.
    var BUGGY_GECKO_BOX_OBJECT =
        GeoGlobe.IS_GECKO && document.getBoxObjectFor &&
        GeoGlobe.Element.getStyle(forElement, 'position') == 'absolute' &&
        (forElement.style.top == '' || forElement.style.left == '');

    var parent = null;
    var box;

    if (forElement.getBoundingClientRect) { // IE
        box = forElement.getBoundingClientRect();
        var scrollTop = window.pageYOffset || viewportElement.scrollTop;
        var scrollLeft = window.pageXOffset || viewportElement.scrollLeft;
        
        pos[0] = box.left + scrollLeft;
        pos[1] = box.top + scrollTop;

    } else if (document.getBoxObjectFor && !BUGGY_GECKO_BOX_OBJECT) { // gecko
        // Gecko ignores the scroll values for ancestors, up to 1.9.  See:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=328881 and
        // https://bugzilla.mozilla.org/show_bug.cgi?id=330619

        box = document.getBoxObjectFor(forElement);
        var vpBox = document.getBoxObjectFor(viewportElement);
        pos[0] = box.screenX - vpBox.screenX;
        pos[1] = box.screenY - vpBox.screenY;

    } else { // safari/opera
        pos[0] = forElement.offsetLeft;
        pos[1] = forElement.offsetTop;
        parent = forElement.offsetParent;
        if (parent != forElement) {
            while (parent) {
                pos[0] += parent.offsetLeft;
                pos[1] += parent.offsetTop;
                parent = parent.offsetParent;
            }
        }

        var browser = GeoGlobe.BROWSER_NAME;

        // opera & (safari absolute) incorrectly account for body offsetTop
        if (browser == "opera" || (browser == "safari" &&
              GeoGlobe.Element.getStyle(forElement, 'position') == 'absolute')) {
            pos[1] -= document.body.offsetTop;
        }

        // accumulate the scroll positions for everything but the body element
        parent = forElement.offsetParent;
        while (parent && parent != document.body) {
            pos[0] -= parent.scrollLeft;
            // see https://bugs.opera.com/show_bug.cgi?id=249965
            if (browser != "opera" || parent.tagName != 'TR') {
                pos[1] -= parent.scrollTop;
            }
            parent = parent.offsetParent;
        }
    }
    
    return pos;
};

/**
 * Function: getViewportElement
 * Returns die viewport element of the document. The viewport element is
 * usually document.documentElement, except in IE,where it is either
 * document.body or document.documentElement, depending on the document's
 * compatibility mode (see
 * http://code.google.com/p/doctype/wiki/ArticleClientViewportElement)
 *
 * Returns:
 * {DOMElement}
 */
GeoGlobe.Util.getViewportElement = function() {
    var viewportElement = arguments.callee.viewportElement;
    if (viewportElement == undefined) {
        viewportElement = (GeoGlobe.BROWSER_NAME == "msie" &&
            document.compatMode != 'CSS1Compat') ? document.body :
            document.documentElement;
        arguments.callee.viewportElement = viewportElement;
    }
    return viewportElement;
};

/** 
 * Function: isEquivalentUrl
 * Test two URLs for equivalence. 
 * 
 * Setting 'ignoreCase' allows for case-independent comparison.
 * 
 * Comparison is based on: 
 *  - Protocol
 *  - Host (evaluated without the port)
 *  - Port (set 'ignorePort80' to ignore "80" values)
 *  - Hash ( set 'ignoreHash' to disable)
 *  - Pathname (for relative <-> absolute comparison) 
 *  - Arguments (so they can be out of order)
 *  
 * Parameters:
 * url1 - {String}
 * url2 - {String}
 * options - {Object} Allows for customization of comparison:
 *                    'ignoreCase' - Default is True
 *                    'ignorePort80' - Default is True
 *                    'ignoreHash' - Default is True
 *
 * Returns:
 * {Boolean} Whether or not the two URLs are equivalent
 */
GeoGlobe.Util.isEquivalentUrl = function(url1, url2, options) {
    options = options || {};

    GeoGlobe.Util.applyDefaults(options, {
        ignoreCase: true,
        ignorePort80: true,
        ignoreHash: true,
        splitArgs: false
    });

    var urlObj1 = GeoGlobe.Util.createUrlObject(url1, options);
    var urlObj2 = GeoGlobe.Util.createUrlObject(url2, options);

    //compare all keys except for "args" (treated below)
    for(var key in urlObj1) {
        if(key !== "args") {
            if(urlObj1[key] != urlObj2[key]) {
                return false;
            }
        }
    }

    // compare search args - irrespective of order
    for(var key in urlObj1.args) {
        if(urlObj1.args[key] != urlObj2.args[key]) {
            return false;
        }
        delete urlObj2.args[key];
    }
    // urlObj2 shouldn't have any args left
    for(var key in urlObj2.args) {
        return false;
    }
    
    return true;
};

/**
 * Function: createUrlObject
 * 
 * Parameters:
 * url - {String}
 * options - {Object} A hash of options.
 *
 * Valid options:
 *   ignoreCase - {Boolean} lowercase url,
 *   ignorePort80 - {Boolean} don't include explicit port if port is 80,
 *   ignoreHash - {Boolean} Don't include part of url after the hash (#).
 *   splitArgs - {Boolean} Split comma delimited params into arrays? Default is
 *       true.
 * 
 * Returns:
 * {Object} An object with separate url, a, port, host, and args parsed out 
 *          and ready for comparison
 */
GeoGlobe.Util.createUrlObject = function(url, options) {
    options = options || {};

    // deal with relative urls first
    if(!(/^\w+:\/\//).test(url)) {
        var loc = window.location;
        var port = loc.port ? ":" + loc.port : "";
        var fullUrl = loc.protocol + "//" + loc.host.split(":").shift() + port;
        if(url.indexOf("/") === 0) {
            // full pathname
            url = fullUrl + url;
        } else {
            // relative to current path
            var parts = loc.pathname.split("/");
            parts.pop();
            url = fullUrl + parts.join("/") + "/" + url;
        }
    }
  
    if (options.ignoreCase) {
        url = url.toLowerCase(); 
    }

    var a = document.createElement('a');
    a.href = url;
    
    var urlObject = {};
    
    //host (without port)
    urlObject.host = a.host.split(":").shift();

    //protocol
    urlObject.protocol = a.protocol;  

    //port (get uniform browser behavior with port 80 here)
    if(options.ignorePort80) {
        urlObject.port = (a.port == "80" || a.port == "0") ? "" : a.port;
    } else {
        urlObject.port = (a.port == "" || a.port == "0") ? "80" : a.port;
    }

    //hash
    urlObject.hash = (options.ignoreHash || a.hash === "#") ? "" : a.hash;  
    
    //args
    var queryString = a.search;
    if (!queryString) {
        var qMark = url.indexOf("?");
        queryString = (qMark != -1) ? url.substr(qMark) : "";
    }
    urlObject.args = GeoGlobe.Util.getParameters(queryString,
            {splitArgs: options.splitArgs});

    // pathname
    //
    // This is a workaround for Internet Explorer where
    // window.location.pathname has a leading "/", but
    // a.pathname has no leading "/".
    urlObject.pathname = (a.pathname.charAt(0) == "/") ? a.pathname : "/" + a.pathname;
    
    return urlObject; 
};
 
/**
 * Function: removeTail
 * Takes a url and removes everything after the ? and #
 * 
 * Parameters:
 * url - {String} The url to process
 * 
 * Returns:
 * {String} The string with all queryString and Hash removed
 */
GeoGlobe.Util.removeTail = function(url) {
    var head = null;
    
    var qMark = url.indexOf("?");
    var hashMark = url.indexOf("#");

    if (qMark == -1) {
        head = (hashMark != -1) ? url.substr(0,hashMark) : url;
    } else {
        head = (hashMark != -1) ? url.substr(0,Math.min(qMark, hashMark)) 
                                  : url.substr(0, qMark);
    }
    return head;
};

/**
 * Constant: IS_GECKO
 * {Boolean} True if the userAgent reports the browser to use the Gecko engine
 */
GeoGlobe.IS_GECKO = (function() {
    var ua = navigator.userAgent.toLowerCase();
    return ua.indexOf("webkit") == -1 && ua.indexOf("gecko") != -1;
})();

/**
 * Constant: CANVAS_SUPPORTED
 * {Boolean} True if canvas 2d is supported.
 */
GeoGlobe.CANVAS_SUPPORTED = (function() {
    var elem = document.createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d'));
})();

/**
 * Constant: BROWSER_NAME
 * {String}
 * A substring of the navigator.userAgent property.  Depending on the userAgent
 *     property, this will be the empty string or one of the following:
 *     * "opera" -- Opera
 *     * "msie"  -- Internet Explorer
 *     * "safari" -- Safari
 *     * "firefox" -- Firefox
 *     * "mozilla" -- Mozilla
 */
GeoGlobe.BROWSER_NAME = (function() {
    var name = "";
    var ua = navigator.userAgent.toLowerCase();
    if (ua.indexOf("opera") != -1) {
        name = "opera";
    } else if (ua.indexOf("msie") != -1) {
        name = "msie";
    } else if (ua.indexOf("safari") != -1) {
        name = "safari";
    } else if (ua.indexOf("mozilla") != -1) {
        if (ua.indexOf("firefox") != -1) {
            name = "firefox";
        } else {
            name = "mozilla";
        }
    }
    return name;
})();

/**
 * Function: getBrowserName
 * 
 * Returns:
 * {String} A string which specifies which is the current 
 *          browser in which we are running. 
 * 
 *          Currently-supported browser detection and codes:
 *           * 'opera' -- Opera
 *           * 'msie'  -- Internet Explorer
 *           * 'safari' -- Safari
 *           * 'firefox' -- Firefox
 *           * 'mozilla' -- Mozilla
 * 
 *          If we are unable to property identify the browser, we 
 *           return an empty string.
 */
GeoGlobe.Util.getBrowserName = function() {
    return GeoGlobe.BROWSER_NAME;
};

/**
 * Method: getRenderedDimensions
 * Renders the contentHTML offscreen to determine actual dimensions for
 *     popup sizing. As we need layout to determine dimensions the content
 *     is rendered -9999px to the left and absolute to ensure the 
 *     scrollbars do not flicker
 *     
 * Parameters:
 * contentHTML
 * size - {<GeoGlobe.Size>} If either the 'w' or 'h' properties is 
 *     specified, we fix that dimension of the div to be measured. This is 
 *     useful in the case where we have a limit in one dimension and must 
 *     therefore meaure the flow in the other dimension.
 * options - {Object}
 *
 * Allowed Options:
 *     displayClass - {String} Optional parameter.  A CSS class name(s) string
 *         to provide the CSS context of the rendered content.
 *     containerElement - {DOMElement} Optional parameter. Insert the HTML to 
 *         this node instead of the body root when calculating dimensions. 
 * 
 * Returns:
 * {<GeoGlobe.Size>}
 */
GeoGlobe.Util.getRenderedDimensions = function(contentHTML, size, options) {
    
    var w, h;
    
    // create temp container div with restricted size
    var container = document.createElement("div");
    container.style.visibility = "hidden";
        
    var containerElement = (options && options.containerElement) 
        ? options.containerElement : document.body;
    
    // Opera and IE7 can't handle a node with position:aboslute if it inherits
    // position:absolute from a parent.
    var parentHasPositionAbsolute = false;
    var superContainer = null;
    var parent = containerElement;
    while (parent && parent.tagName.toLowerCase()!="body") {
        var parentPosition = GeoGlobe.Element.getStyle(parent, "position");
        if(parentPosition == "absolute") {
            parentHasPositionAbsolute = true;
            break;
        } else if (parentPosition && parentPosition != "static") {
            break;
        }
        parent = parent.parentNode;
    }
    if(parentHasPositionAbsolute && (containerElement.clientHeight === 0 || 
                                     containerElement.clientWidth === 0) ){
        superContainer = document.createElement("div");
        superContainer.style.visibility = "hidden";
        superContainer.style.position = "absolute";
        superContainer.style.overflow = "visible";
        superContainer.style.width = document.body.clientWidth + "px";
        superContainer.style.height = document.body.clientHeight + "px";
        superContainer.appendChild(container);
    }
    container.style.position = "absolute";

    //fix a dimension, if specified.
    if (size) {
        if (size.w) {
            w = size.w;
            container.style.width = w + "px";
        } else if (size.h) {
            h = size.h;
            container.style.height = h + "px";
        }
    }

    //add css classes, if specified
    if (options && options.displayClass) {
        container.className = options.displayClass;
    }
    
    // create temp content div and assign content
    var content = document.createElement("div");
    content.innerHTML = contentHTML;
    
    // we need overflow visible when calculating the size
    content.style.overflow = "visible";
    if (content.childNodes) {
        for (var i=0, l=content.childNodes.length; i<l; i++) {
            if (!content.childNodes[i].style) continue;
            content.childNodes[i].style.overflow = "visible";
        }
    }
    
    // add content to restricted container 
    container.appendChild(content);
    
    // append container to body for rendering
    if (superContainer) {
        containerElement.appendChild(superContainer);
    } else {
        containerElement.appendChild(container);
    }
    
    // calculate scroll width of content and add corners and shadow width
    if (!w) {
        w = parseInt(content.scrollWidth);
    
        // update container width to allow height to adjust
        container.style.width = w + "px";
    }        
    // capture height and add shadow and corner image widths
    if (!h) {
        h = parseInt(content.scrollHeight);
    }

    // remove elements
    container.removeChild(content);
    if (superContainer) {
        superContainer.removeChild(container);
        containerElement.removeChild(superContainer);
    } else {
        containerElement.removeChild(container);
    }
    
    return new GeoGlobe.Size(w, h);
};

/**
 * APIFunction: getScrollbarWidth
 * This function has been modified by the OpenLayers from the original version,
 *     written by Matthew Eernisse and released under the Apache 2 
 *     license here:
 * 
 *     http://www.fleegix.org/articles/2006/05/30/getting-the-scrollbar-width-in-pixels
 * 
 *     It has been modified simply to cache its value, since it is physically 
 *     impossible that this code could ever run in more than one browser at 
 *     once. 
 * 
 * Returns:
 * {Integer}
 */
GeoGlobe.Util.getScrollbarWidth = function() {
    
    var scrollbarWidth = GeoGlobe.Util._scrollbarWidth;
    
    if (scrollbarWidth == null) {
        var scr = null;
        var inn = null;
        var wNoScroll = 0;
        var wScroll = 0;
    
        // Outer scrolling div
        scr = document.createElement('div');
        scr.style.position = 'absolute';
        scr.style.top = '-1000px';
        scr.style.left = '-1000px';
        scr.style.width = '100px';
        scr.style.height = '50px';
        // Start with no scrollbar
        scr.style.overflow = 'hidden';
    
        // Inner content div
        inn = document.createElement('div');
        inn.style.width = '100%';
        inn.style.height = '200px';
    
        // Put the inner div in the scrolling div
        scr.appendChild(inn);
        // Append the scrolling div to the doc
        document.body.appendChild(scr);
    
        // Width of the inner div sans scrollbar
        wNoScroll = inn.offsetWidth;
    
        // Add the scrollbar
        scr.style.overflow = 'scroll';
        // Width of the inner div width scrollbar
        wScroll = inn.offsetWidth;
    
        // Remove the scrolling div from the doc
        document.body.removeChild(document.body.lastChild);
    
        // Pixel width of the scroller
        GeoGlobe.Util._scrollbarWidth = (wNoScroll - wScroll);
        scrollbarWidth = GeoGlobe.Util._scrollbarWidth;
    }

    return scrollbarWidth;
};

/**
 * APIFunction: getFormattedLonLat
 * This function will return latitude or longitude value formatted as 
 *
 * Parameters:
 * coordinate - {Float} the coordinate value to be formatted
 * axis - {String} value of either 'lat' or 'lon' to indicate which axis is to
 *          to be formatted (default = lat)
 * dmsOption - {String} specify the precision of the output can be one of:
 *           'dms' show degrees minutes and seconds
 *           'dm' show only degrees and minutes
 *           'd' show only degrees
 * 
 * Returns:
 * {String} the coordinate value formatted as a string
 */
/*
GeoGlobe.Util.getFormattedLonLat = function(coordinate, axis, dmsOption) {
    if (!dmsOption) {
        dmsOption = 'dms';    //default to show degree, minutes, seconds
    }

    coordinate = (coordinate+540)%360 - 180; // normalize for sphere being round

    var abscoordinate = Math.abs(coordinate);
    var coordinatedegrees = Math.floor(abscoordinate);

    var coordinateminutes = (abscoordinate - coordinatedegrees)/(1/60);
    var tempcoordinateminutes = coordinateminutes;
    coordinateminutes = Math.floor(coordinateminutes);
    var coordinateseconds = (tempcoordinateminutes - coordinateminutes)/(1/60);
    coordinateseconds =  Math.round(coordinateseconds*10);
    coordinateseconds /= 10;

    if( coordinateseconds >= 60) { 
        coordinateseconds -= 60; 
        coordinateminutes += 1; 
        if( coordinateminutes >= 60) { 
            coordinateminutes -= 60; 
            coordinatedegrees += 1; 
        } 
    }
    
    if( coordinatedegrees < 10 ) {
        coordinatedegrees = "0" + coordinatedegrees;
    }
    var str = coordinatedegrees + "\u00B0";

    if (dmsOption.indexOf('dm') >= 0) {
        if( coordinateminutes < 10 ) {
            coordinateminutes = "0" + coordinateminutes;
        }
        str += coordinateminutes + "'";
  
        if (dmsOption.indexOf('dms') >= 0) {
            if( coordinateseconds < 10 ) {
                coordinateseconds = "0" + coordinateseconds;
            }
            str += coordinateseconds + '"';
        }
    }
    
    if (axis == "lon") {
        str += coordinate < 0 ? GeoGlobe.i18n("W") : GeoGlobe.i18n("E");
    } else {
        str += coordinate < 0 ? GeoGlobe.i18n("S") : GeoGlobe.i18n("N");
    }
    return str;
};
*/
//生成num个数的随机字符串
GeoGlobe.Util.randomStr = function (num) {
	var random = "";
	var randArr = [];
	for(var i=0;i<num;i++){
		var randNum = Math.ceil(Math.random() * 25);
		randArr.push(String.fromCharCode(97+randNum));
	}
	for(var i=0;i<num;i++){
		random += randArr[i];
	}
	return random;
};
//执行js
GeoGlobe.Util.globalEval = function(data) {
	if (data && GeoGlobe.String.trim(data)){
		// We use execScript on Internet Explorer
		// We use an anonymous function so that context is window
		// rather than in Firefox
		(window.execScript || function(data){
			window["eval"].call(window, data);
		})(data);
	}
};

//根据比例尺，单位和dpi获取分辨率
GeoGlobe.Util.getResolutionFromScale_DPI = function(scale, units, dpi){
	var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = GeoGlobe.Util.normalizeScale(scale);
        resolution = 1 / (normScale * GeoGlobe.INCHES_PER_UNIT[units] * dpi);
    }
    return resolution;
};

//根据分辨率，单位和dpi获取比例尺
GeoGlobe.Util.getScaleFromResolution_DPI = function(resolution, units, dpi){
	if (units == null) {
        units = "degrees";
    }

    var scale = resolution * GeoGlobe.INCHES_PER_UNIT[units] * dpi;
    return scale;
};

/**
 * APIMethod: getMapLevelFormResolution
 * 根据分辨率获取层级
 */
GeoGlobe.Util.getMapLevelFormResolution = function(map, resolution){
    if (!resolution) {
        return 0;
    }
	var zoom, i, diff;
	var minDiff = Number.POSITIVE_INFINITY;
	var resolutions = map.getResolutions();
	for (i = 0, len = resolutions.length; i < len; i++) {
		//判断当前分辨率与金字塔中分辨率最接近的
        diff = Math.abs(resolutions[i] - resolution);
        if (diff > minDiff) {
            break;
        }
        minDiff = diff;
	}
	zoom = Math.max(0, i - 1);//0和(i - 1)中取大数。
	return zoom ;
};

/**
 * APIMethod: getMapLevelFormScale
 * 根据比例尺获取层级
 */
GeoGlobe.Util.getMapLevelFormScale = function(map, scale, units, dpi){
	////var lvl_arcgis_gd = getLevelFormScale(2.792281947544293E8); //1
	var units = units ? units : "degrees";
	var dpi = dpi ? dpi : 96;
	var resolution = GeoGlobe.Util.getResolutionFromScale_DPI(scale, units, dpi);
	var lvl = GeoGlobe.Util.getMapLevelFormResolution(map, resolution);
	return lvl;
};

/**
 * APIMethod: delayFun
 * 这里返回一个函数，如果它被不间断地调用，它将不会得到执行。
 * 该函数在停止调用 N 毫秒后，再次调用它才会得到执行。
 * 如果有传递 ‘immediate’ 参数，会马上将函数安排到执行队列中，而不会延迟。
 * exam: 	var myEfficientFn = GeoGlobe.Util.delayFun (function() {
 * 				// 所有繁重的操作
 * 			}, 250);
 * 			window.addEventListener('resize', myEfficientFn);
 */
GeoGlobe.Util.delayFun = function(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this, args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.proj4cn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;
var gcj02 = require('./gcj-02');

var PI = Math.PI;
var X_PI = PI * 3000 / 180;

var toGCJ02 = exports.toGCJ02 = forEachPoint(function(input, output, offset) {
  var x = input[offset] - 0.0065;
  var y = input[offset + 1] - 0.006;
  var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * X_PI);
  var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * X_PI);
  output[offset] = z * Math.cos(theta);
  output[offset + 1] = z * Math.sin(theta);
  return output;
});

var fromGCJ02 = exports.fromGCJ02 = forEachPoint(function(input, output, offset) {
  var x = input[offset];
  var y = input[offset + 1];
  var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * X_PI);
  var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * X_PI);
  output[offset] = z * Math.cos(theta) + 0.0065;
  output[offset + 1] = z * Math.sin(theta) + 0.006;
  return output;
});

exports.toWGS84 = function(input, opt_output, opt_dimension) {
  var output = toGCJ02(input, opt_output, opt_dimension);
  return gcj02.toWGS84(output, output, opt_dimension);
};

exports.fromWGS84 = function(input, opt_output, opt_dimension) {
  var output = gcj02.fromWGS84(input, opt_output, opt_dimension);
  return fromGCJ02(output, output, opt_dimension);
};

},{"../util":8,"./gcj-02":2}],2:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;

var PI = Math.PI;
var AXIS = 6378245.0;
var OFFSET = 0.00669342162296594323;  // (a^2 - b^2) / a^2

function delta(wgLon, wgLat) {
  var dLat = transformLat(wgLon - 105.0, wgLat - 35.0);
  var dLon = transformLon(wgLon - 105.0, wgLat - 35.0);
  var radLat = wgLat / 180.0 * PI;
  var magic = Math.sin(radLat);
  magic = 1 - OFFSET * magic * magic;
  var sqrtMagic = Math.sqrt(magic);
  dLat = (dLat * 180.0) / ((AXIS * (1 - OFFSET)) / (magic * sqrtMagic) * PI);
  dLon = (dLon * 180.0) / (AXIS / sqrtMagic * Math.cos(radLat) * PI);
  return [dLon, dLat];
}

function outOfChina(lon, lat) {
  if (lon < 72.004 || lon > 137.8347) {
    return true;
  }
  if (lat < 0.8293 || lat > 55.8271) {
    return true;
  }
  return false;
}

function transformLat(x, y) {
  var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
  ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0;
  ret += (160.0 * Math.sin(y / 12.0 * PI) + 320 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0;
  return ret;
}

function transformLon(x, y) {
  var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
  ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0;
  ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0;
  return ret;
}

exports.toWGS84 = forEachPoint(function(input, output, offset) {
  var lng = input[offset];
  var lat = input[offset + 1];
  if (!outOfChina(lng, lat)) {
    var deltaD = delta(lng, lat);
    lng = lng - deltaD[0];
    lat = lat - deltaD[1];
  }
  output[offset] = lng;
  output[offset + 1] = lat;
});

exports.fromWGS84 = forEachPoint(function(input, output, offset) {
  var lng = input[offset];
  var lat = input[offset + 1];
  if (!outOfChina(lng, lat)) {
    var deltaD = delta(lng, lat);
    lng = lng + deltaD[0];
    lat = lat + deltaD[1];
  }
  output[offset] = lng;
  output[offset + 1] = lat;
});

},{"../util":8}],3:[function(require,module,exports){
exports.bd09 = require('./bd-09');
exports.gcj02 = require('./gcj-02');

},{"./bd-09":1,"./gcj-02":2}],4:[function(require,module,exports){
var projection = require('./projection/index');
var datum = require('./datum/index');

exports.smerc2bmerc = function(input, opt_output, opt_dimension) {
  var output = projection.sphericalMercator.inverse(input, opt_output, opt_dimension);
  output = datum.bd09.fromWGS84(output, output, opt_dimension);
  return projection.baiduMercator.forward(output, output, opt_dimension);
};

exports.bmerc2smerc = function(input, opt_output, opt_dimension) {
  var output = projection.baiduMercator.inverse(input, opt_output, opt_dimension);
  output = datum.bd09.toWGS84(output, output, opt_dimension);
  return projection.sphericalMercator.forward(output, output, opt_dimension);
};

exports.bmerc2ll = function(input, opt_output, opt_dimension) {
  var output = projection.baiduMercator.inverse(input, opt_output, opt_dimension);
  return datum.bd09.toWGS84(output, output, opt_dimension);
};

exports.ll2bmerc = function(input, opt_output, opt_dimension) {
  var output = datum.bd09.fromWGS84(input, opt_output, opt_dimension);
  return projection.baiduMercator.forward(output, output, opt_dimension);
};

exports.ll2smerc = projection.sphericalMercator.forward;
exports.smerc2ll = projection.sphericalMercator.inverse;
exports.datum = datum;
exports.projection = projection;

//note 20170807: add
exports.gcj02towgs84 = function(input, opt_output, opt_dimension){
	return datum.gcj02.toWGS84(input, opt_output, opt_dimension);
}
exports.wgs84togcj02 = function(input, opt_output, opt_dimension){
	return datum.gcj02.fromWGS84(input, opt_output, opt_dimension);
}

},{"./datum/index":3,"./projection/index":6}],5:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;

var MCBAND = [12890594.86, 8362377.87,
    5591021, 3481989.83, 1678043.12, 0];

var LLBAND = [75, 60, 45, 30, 15, 0];

var MC2LL = [
    [1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331,
        200.9824383106796, -187.2403703815547, 91.6087516669843,
        -23.38765649603339, 2.57121317296198, -0.03801003308653,
        17337981.2],
    [-7.435856389565537e-9, 0.000008983055097726239,
        -0.78625201886289, 96.32687599759846, -1.85204757529826,
        -59.36935905485877, 47.40033549296737, -16.50741931063887,
        2.28786674699375, 10260144.86],
    [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616,
        59.74293618442277, 7.357984074871, -25.38371002664745,
        13.45380521110908, -3.29883767235584, 0.32710905363475,
        6856817.37],
    [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591,
        40.31678527705744, 0.65659298677277, -4.44255534477492,
        0.85341911805263, 0.12923347998204, -0.04625736007561,
        4482777.06],
    [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062,
        23.10934304144901, -0.00023663490511, -0.6321817810242,
        -0.00663494467273, 0.03430082397953, -0.00466043876332,
        2555164.4],
    [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8,
        7.47137025468032, -0.00000353937994, -0.02145144861037,
        -0.00001234426596, 0.00010322952773, -0.00000323890364,
        826088.5]];

var LL2MC = [
    [-0.0015702102444, 111320.7020616939, 1704480524535203,
        -10338987376042340, 26112667856603880,
        -35149669176653700, 26595700718403920,
        -10725012454188240, 1800819912950474, 82.5],
    [0.0008277824516172526, 111320.7020463578, 647795574.6671607,
        -4082003173.641316, 10774905663.51142, -15171875531.51559,
        12053065338.62167, -5124939663.577472, 913311935.9512032,
        67.5],
    [0.00337398766765, 111320.7020202162, 4481351.045890365,
        -23393751.19931662, 79682215.47186455, -115964993.2797253,
        97236711.15602145, -43661946.33752821, 8477230.501135234,
        52.5],
    [0.00220636496208, 111320.7020209128, 51751.86112841131,
        3796837.749470245, 992013.7397791013, -1221952.21711287,
        1340652.697009075, -620943.6990984312, 144416.9293806241,
        37.5],
    [-0.0003441963504368392, 111320.7020576856, 278.2353980772752,
        2485758.690035394, 6070.750963243378, 54821.18345352118,
        9540.606633304236, -2710.55326746645, 1405.483844121726,
        22.5],
    [-0.0003218135878613132, 111320.7020701615, 0.00369383431289,
        823725.6402795718, 0.46104986909093, 2351.343141331292,
        1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]];


function getRange(v, min, max) {
  v = Math.max(v, min);
  v = Math.min(v, max);

  return v;
}

function getLoop(v, min, max) {
  var d = max - min;
  while (v > max) {
    v -= d;
  }
  while (v < min) {
    v += d;
  }

  return v;
}

function convertor(input, output, offset, table) {
  var px = input[offset];
  var py = input[offset + 1];
  var x = table[0] + table[1] * Math.abs(px);
  var d = Math.abs(py) / table[9];
  var y = table[2]
      + table[3]
      * d
      + table[4]
      * d
      * d
      + table[5]
      * d
      * d
      * d
      + table[6]
      * d
      * d
      * d
      * d
      + table[7]
      * d
      * d
      * d
      * d
      * d
      + table[8]
      * d
      * d
      * d
      * d
      * d
      * d;

  output[offset] = x * (px < 0 ? -1 : 1);
  output[offset + 1] = y * (py < 0 ? -1 : 1);
}

exports.forward = forEachPoint(function(input, output, offset) {
  var lng = getLoop(input[offset], -180, 180);
  var lat = getRange(input[offset + 1], -74, 74);

  var table = null;
  var j;
  for (j = 0; j < LLBAND.length; ++j) {
    if (lat >= LLBAND[j]) {
      table = LL2MC[j];
      break;
    }
  }
  if (table === null) {
    for (j = LLBAND.length - 1; j >= 0; --j) {
      if (lat <= -LLBAND[j]) {
        table = LL2MC[j];
        break;
      }
    }
  }
  output[offset] = lng;
  output[offset + 1] = lat;
  convertor(output, output, offset, table);
});

exports.inverse = forEachPoint(function(input, output, offset) {
  var y_abs = Math.abs(input[offset + 1]);

  var table = null;
  for (var j = 0; j < MCBAND.length; j++) {
    if (y_abs >= MCBAND[j]) {
      table = MC2LL[j];
      break;
    }
  }

  convertor(input, output, offset, table);
});

},{"../util":8}],6:[function(require,module,exports){
exports.baiduMercator = require('./baidu-mercator');
exports.sphericalMercator = require('./spherical-mercator');

},{"./baidu-mercator":5,"./spherical-mercator":7}],7:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;

var RADIUS = 6378137;
var MAX_LATITUDE = 85.0511287798;
var RAD_PER_DEG = Math.PI / 180;

exports.forward = forEachPoint(function(input, output, offset) {
  var lat = Math.max(Math.min(MAX_LATITUDE, input[offset + 1]), -MAX_LATITUDE);
  var sin = Math.sin(lat * RAD_PER_DEG);

  output[offset] = RADIUS * input[offset] * RAD_PER_DEG;
  output[offset + 1] = RADIUS * Math.log((1 + sin) / (1 - sin)) / 2;
});

exports.inverse = forEachPoint(function(input, output, offset) {
  output[offset] = input[offset] / RADIUS / RAD_PER_DEG;
  output[offset + 1] = (2 * Math.atan(Math.exp(input[offset + 1] / RADIUS)) - (Math.PI / 2)) / RAD_PER_DEG;
});

},{"../util":8}],8:[function(require,module,exports){

exports.forEachPoint = function(func) {
  return function(input, opt_output, opt_dimension) {
    var len = input.length;
    var dimension = opt_dimension ? opt_dimension : 2;
    var output;
    if (opt_output) {
      output = opt_output;
    } else {
      if (dimension !== 2) {
        output = input.slice();
      } else {
        output = new Array(len);
      }
    }
    for (var offset = 0; offset < len; offset += dimension) {
      func(input, output, offset);
    }
    return output;
  };
};

},{}]},{},[4])(4)
});
if(GeoGlobe){GeoGlobe.Proj4cn = proj4cn};
/**
 * Namespace: GeoGlobe.ProjAxisOrder
 * 本命名空间是对在GeoGlobe原生的基础上进行的扩展，用于定义常用投影坐标轴读取的方向。
 *
 * 说明:
 * 目前WMS图层类的添加；WMTS能力描述信息的解析，以及WFS能力描述信息的解析需要用到本命名空间下的属性。
 */
GeoGlobe.ProjAxisOrder = {
	//East/North ordering (lat/lon)
	AXIS_ORDER_EN: true, //经度，纬度
	AXIS_ORDER_NE: false //纬度，经度
};
//
GeoGlobe.ProjAxisOrder.AxisOrder = {
	'EPSG:900913': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'WGS84': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'IGNF:WGS84G': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:4326': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,//纬度，经度
	"EPSG:4490": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,//纬度，经度
	'EPSG:4269': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:2361': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:27700': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:904490': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	
	'EPSG:4171'	: GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE, 
	
	'EPSG:32637': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32638': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32639': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32640': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32641': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,			 
	
	'EPSG:28991': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:28992': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,					 
	
	'EPSG:31300': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:31370': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,			
	
	'EPSG:2176': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2177': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2178': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2179': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2180': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	
	'EPSG:2154'	: GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN, 	
	
	'EPSG:3346' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:3857' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2065' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN
};GeoGlobe.SpatialReference = GeoGlobe.Class({

    /**
     * Property: proj
     * {Object} Proj4js.Proj instance.
     */
    proj: null,
    
    /**
     * Property: projCode
     * {String}
     */
    projCode: null,
    
    /**
     * Property: titleRegEx
     * {RegExp} regular expression to strip the title from a proj4js definition
     */
    titleRegEx: /\+title=[^\+]*/,

    /**
     * Constructor: OpenLayers.Projection
     * This class offers several methods for interacting with a wrapped 
     *     pro4js projection object. 
     *
     * Parameters:
     * projCode - {String} A string identifying the Well Known Identifier for
     *    the projection.
     * options - {Object} An optional object to set additional properties
     *     on the projection.
     *
     * Returns:
     * {<OpenLayers.Projection>} A projection object.
     */
    initialize: function(projCode, options) {
        GeoGlobe.Util.extend(this, options);
        this.projCode = projCode;
        if (typeof Proj4js == "object") {
            this.proj = new Proj4js.Proj(projCode);
        }
    },
    
    /**
     * APIMethod: getCode
     * Get the string SRS code.
     *
     * Returns:
     * {String} The SRS code.
     */
    getCode: function() {
        return this.proj ? this.proj.srsCode : this.projCode;
    },
   
    /**
     * APIMethod: getUnits
     * Get the units string for the projection -- returns null if 
     *     proj4js is not available.
     *
     * Returns:
     * {String} The units abbreviation.
     */
    getUnits: function() {
        return this.proj ? this.proj.units : null;
    },

    /**
     * Method: toString
     * Convert projection to string (getCode wrapper).
     *
     * Returns:
     * {String} The projection code.
     */
    toString: function() {
        return this.getCode();
    },

    /**
     * Method: equals
     * Test equality of two projection instances.  Determines equality based
     *     soley on the projection code.
     *
     * Returns:
     * {Boolean} The two projections are equivalent.
     */
    equals: function(projection) {
        var p = projection, equals = false;
        if (p) {
            if (!(p instanceof GeoGlobe.SpatialReference)) {
                p = new GeoGlobe.SpatialReference(p);
            }
            if ((typeof Proj4js == "object") && this.proj.defData && p.proj.defData) {
                equals = this.proj.defData.replace(this.titleRegEx, "") ==
                    p.proj.defData.replace(this.titleRegEx, "");
            } else if (p.getCode) {
                var source = this.getCode(), target = p.getCode();
                equals = source == target ||
                    !!GeoGlobe.SpatialReference.transforms[source] &&
                    GeoGlobe.SpatialReference.transforms[source][target] ===
                    GeoGlobe.SpatialReference.nullTransform;
            }
        }
        return equals;   
    },

    /* Method: destroy
     * Destroy projection object.
     */
    destroy: function() {
        delete this.proj;
        delete this.projCode;
    },
    
    CLASS_NAME: "GeoGlobe.SpatialReference"
});     

/**
 * Property: transforms
 * {Object} Transforms is an object, with from properties, each of which may
 * have a to property. This allows you to define projections without 
 * requiring support for proj4js to be included.
 *
 * This object has keys which correspond to a 'source' projection object.  The
 * keys should be strings, corresponding to the projection.getCode() value.
 * Each source projection object should have a set of destination projection
 * keys included in the object. 
 * 
 * Each value in the destination object should be a transformation function,
 * where the function is expected to be passed an object with a .x and a .y
 * property.  The function should return the object, with the .x and .y
 * transformed according to the transformation function.
 *
 * Note - Properties on this object should not be set directly.  To add a
 *     transform method to this object, use the <addTransform> method.  For an
 *     example of usage, see the OpenLayers.Layer.SphericalMercator file.
 */
GeoGlobe.SpatialReference.transforms = {};

/**
 * APIProperty: defaults
 * {Object} Defaults for the SRS codes known to OpenLayers (currently
 * EPSG:4326, CRS:84, urn:ogc:def:crs:EPSG:6.6:4326, EPSG:900913, EPSG:3857,
 * EPSG:102113 and EPSG:102100). Keys are the SRS code, values are units,
 * maxExtent (the validity extent for the SRS) and yx (true if this SRS is
 * known to have a reverse axis order).
 */
GeoGlobe.SpatialReference.defaults = {
    "EPSG:4326": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90],
        yx: true
    },
    "CRS:84": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90]
    },
    "EPSG:900913": {
        units: "m",
        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
    }
};

/**
 * APIMethod: addTransform
 * Set a custom transform method between two projections.  Use this method in
 *     cases where the proj4js lib is not available or where custom projections
 *     need to be handled.
 *
 * Parameters:
 * from - {String} The code for the source projection
 * to - {String} the code for the destination projection
 * method - {Function} A function that takes a point as an argument and
 *     transforms that point from the source to the destination projection
 *     in place.  The original point should be modified.
 */
GeoGlobe.SpatialReference.addTransform = function(from, to, method) {
    if (method === GeoGlobe.SpatialReference.nullTransform) {
        var defaults = GeoGlobe.SpatialReference.defaults[from];
        if (defaults && !GeoGlobe.SpatialReference.defaults[to]) {
            GeoGlobe.SpatialReference.defaults[to] = defaults;
        }
    }
    if(!GeoGlobe.SpatialReference.transforms[from]) {
        GeoGlobe.SpatialReference.transforms[from] = {};
    }
    GeoGlobe.SpatialReference.transforms[from][to] = method;
};

/**
 * APIMethod: transform
 * Transform a point coordinate from one projection to another.  Note that
 *     the input point is transformed in place.
 * 
 * Parameters:
 * point - {<OpenLayers.Geometry.Point> | Object} An object with x and y
 *     properties representing coordinates in those dimensions.
 * source - {OpenLayers.Projection} Source map coordinate system
 * dest - {OpenLayers.Projection} Destination map coordinate system
 *
 * Returns:
 * point - {object} A transformed coordinate.  The original point is modified.
 */
GeoGlobe.SpatialReference.transform = function(point, source, dest) {
    if (source && dest) {
        if (!(source instanceof GeoGlobe.SpatialReference)) {
            source = new GeoGlobe.SpatialReference(source);
        }
        if (!(dest instanceof GeoGlobe.SpatialReference)) {
            dest = new GeoGlobe.SpatialReference(dest);
        }
        if (source.proj && dest.proj) {
            point = Proj4js.transform(source.proj, dest.proj, point);
        } else {
            var sourceCode = source.getCode();
            var destCode = dest.getCode();
            var transforms = GeoGlobe.SpatialReference.transforms;
            if (transforms[sourceCode] && transforms[sourceCode][destCode]) {
                transforms[sourceCode][destCode](point);
            }
        }
    }
    return point;
};

/**
 * APIFunction: nullTransform
 * A null transformation - useful for defining projection aliases when
 * proj4js is not available:
 *
 * (code)
 * OpenLayers.Projection.addTransform("EPSG:3857", "EPSG:900913",
 *     OpenLayers.Projection.nullTransform);
 * OpenLayers.Projection.addTransform("EPSG:900913", "EPSG:3857",
 *     OpenLayers.Projection.nullTransform);
 * (end)
 */
GeoGlobe.SpatialReference.nullTransform = function(point) {
    return point;
};

/**
 * Note: Transforms for web mercator <-> geographic
 * OpenLayers recognizes EPSG:3857, EPSG:900913, EPSG:102113 and EPSG:102100.
 * OpenLayers originally started referring to EPSG:900913 as web mercator.
 * The EPSG has declared EPSG:3857 to be web mercator.
 * ArcGIS 10 recognizes the EPSG:3857, EPSG:102113, and EPSG:102100 as
 * equivalent.  See http://blogs.esri.com/Dev/blogs/arcgisserver/archive/2009/11/20/ArcGIS-Online-moving-to-Google-_2F00_-Bing-tiling-scheme_3A00_-What-does-this-mean-for-you_3F00_.aspx#12084.
 * For geographic, OpenLayers recognizes EPSG:4326, CRS:84 and
 * urn:ogc:def:crs:EPSG:6.6:4326. OpenLayers also knows about the reverse axis
 * order for EPSG:4326. 
 */
(function() {

    var pole = 20037508.34;

    function inverseMercator(xy) {
        xy.x = 180 * xy.x / pole;
        xy.y = 180 / Math.PI * (2 * Math.atan(Math.exp((xy.y / pole) * Math.PI)) - Math.PI / 2);
        return xy;
    }

    function forwardMercator(xy) {
        xy.x = xy.x * pole / 180;
        var y = Math.log(Math.tan((90 + xy.y) * Math.PI / 360)) / Math.PI * pole;
        xy.y = Math.max(-20037508.34, Math.min(y, 20037508.34));
        return xy;
    }

    function map(base, codes) {
        var add = GeoGlobe.SpatialReference.addTransform;
        var same = GeoGlobe.SpatialReference.nullTransform;
        var i, len, code, other, j;
        for (i=0, len=codes.length; i<len; ++i) {
            code = codes[i];
            add(base, code, forwardMercator);
            add(code, base, inverseMercator);
            for (j=i+1; j<len; ++j) {
                other = codes[j];
                add(code, other, same);
                add(other, code, same);
            }
        }
    }
    
    // list of equivalent codes for web mercator
    var mercator = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"],
        geographic = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"],
        i;
    for (i=mercator.length-1; i>=0; --i) {
        map(mercator[i], geographic);
    }
    for (i=geographic.length-1; i>=0; --i) {
        map(geographic[i], mercator);
    }

})();
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires OpenLayers/SingleFile.js
 */

/** 
 * Header: OpenLayers Base Types
 * OpenLayers custom string, number and function functions are described here.
 * 自定义字符串，数量和功能函数介绍。
 */

/**
 * Namespace: GeoGlobe.String
 * Contains convenience functions for string manipulation.
 * 包含对字符串方便操作的方法。
 */
GeoGlobe.String = {

    /**
     * APIFunction: startsWith
     * Test whether a string starts with another string. 
     * 
     * Parameters:
     * str - {String} The string to test.
     * sub - {String} The substring to look for.
     *  
     * Returns:
     * {Boolean} The first string starts with the second.
     */
    startsWith: function(str, sub) {
        return (str.indexOf(sub) == 0);
    },

    /**
     * APIFunction: contains
     * Test whether a string contains another string.
     * 
     * Parameters:
     * str - {String} The string to test.
     * sub - {String} The substring to look for.
     * 
     * Returns:
     * {Boolean} The first string contains the second.
     */
    contains: function(str, sub) {
        return (str.indexOf(sub) != -1);
    },
    
    /**
     * APIFunction: trim
     * Removes leading and trailing whitespace characters from a string.
     * 
     * Parameters:
     * str - {String} The (potentially) space padded string.  This string is not
     *     modified.
     * 
     * Returns:
     * {String} A trimmed version of the string with all leading and 
     *     trailing spaces removed.
     */
    trim: function(str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },
    
    /**
     * APIFunction: camelize
     * Camel-case a hyphenated string. 
     *     Ex. "chicken-head" becomes "chickenHead", and
     *     "-chicken-head" becomes "ChickenHead".
     *
     * Parameters:
     * str - {String} The string to be camelized.  The original is not modified.
     * 
     * Returns:
     * {String} The string, camelized
     */
    camelize: function(str) {
        var oStringList = str.split('-');
        var camelizedString = oStringList[0];
        for (var i=1, len=oStringList.length; i<len; i++) {
            var s = oStringList[i];
            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
        }
        return camelizedString;
    },
    
    /**
     * APIFunction: format
     * Given a string with tokens in the form ${token}, return a string
     *     with tokens replaced with properties from the given context
     *     object.  Represent a literal "${" by doubling it, e.g. "${${".
     *
     * Parameters:
     * template - {String} A string with tokens to be replaced.  A template
     *     has the form "literal ${token}" where the token will be replaced
     *     by the value of context["token"].
     * context - {Object} An optional object with properties corresponding
     *     to the tokens in the format string.  If no context is sent, the
     *     window object will be used.
     * args - {Array} Optional arguments to pass to any functions found in
     *     the context.  If a context property is a function, the token
     *     will be replaced by the return from the function called with
     *     these arguments.
     *
     * Returns:
     * {String} A string with tokens replaced from the context object.
     */
    format: function(template, context, args) {
        if(!context) {
            context = window;
        }

        // Example matching: 
        // str   = ${foo.bar}
        // match = foo.bar
        var replacer = function(str, match) {
            var replacement;

            // Loop through all subs. Example: ${a.b.c}
            // 0 -> replacement = context[a];
            // 1 -> replacement = context[a][b];
            // 2 -> replacement = context[a][b][c];
            var subs = match.split(/\.+/);
            for (var i=0; i< subs.length; i++) {
                if (i == 0) {
                    replacement = context;
                }
                if (replacement === undefined) {
                    break;
                }
                replacement = replacement[subs[i]];
            }

            if(typeof replacement == "function") {
                replacement = args ?
                    replacement.apply(null, args) :
                    replacement();
            }

            // If replacement is undefined, return the string 'undefined'.
            // This is a workaround for a bugs in browsers not properly 
            // dealing with non-participating groups in regular expressions:
            // http://blog.stevenlevithan.com/archives/npcg-javascript
            if (typeof replacement == 'undefined') {
                return 'undefined';
            } else {
                return replacement; 
            }
        };

        return template.replace(GeoGlobe.String.tokenRegEx, replacer);
    },

    /**
     * Property: tokenRegEx
     * Used to find tokens in a string.
     * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}
     */
    tokenRegEx:  /\$\{([\w.]+?)\}/g,
    
    /**
     * Property: numberRegEx
     * Used to test strings as numbers.
     */
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,
    
    /**
     * APIFunction: isNumeric
     * Determine whether a string contains only a numeric value.
     *
     * Examples:
     * (code)
     * GeoGlobe.String.isNumeric("6.02e23") // true
     * GeoGlobe.String.isNumeric("12 dozen") // false
     * GeoGlobe.String.isNumeric("4") // true
     * GeoGlobe.String.isNumeric(" 4 ") // false
     * (end)
     *
     * Returns:
     * {Boolean} String contains only a number.
     */
    isNumeric: function(value) {
        return GeoGlobe.String.numberRegEx.test(value);
    },
    
    /**
     * APIFunction: numericIf
     * Converts a string that appears to be a numeric value into a number.
     * 
     * Parameters:
     * value - {String}
     * trimWhitespace - {Boolean}
     *
     * Returns:
     * {Number|String} a Number if the passed value is a number, a String
     *     otherwise. 
     */
    numericIf: function(value, trimWhitespace) {
        var originalValue = value;
        if (trimWhitespace === true && value != null && value.replace) {
            value = value.replace(/^\s*|\s*$/g, "");
        }
        return GeoGlobe.String.isNumeric(value) ? parseFloat(value) : originalValue;
    }

};

/**
 * Namespace: GeoGlobe.Number
 * Contains convenience functions for manipulating numbers.
 */
GeoGlobe.Number = {

    /**
     * Property: decimalSeparator
     * Decimal separator to use when formatting numbers.
     */
    decimalSeparator: ".",
    
    /**
     * Property: thousandsSeparator
     * Thousands separator to use when formatting numbers.
     */
    thousandsSeparator: ",",
    
    /**
     * APIFunction: limitSigDigs
     * Limit the number of significant digits on a float.
     * 
     * Parameters:
     * num - {Float}
     * sig - {Integer}
     * 
     * Returns:
     * {Float} The number, rounded to the specified number of significant
     *     digits.
     */
    limitSigDigs: function(num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    },
    
    /**
     * APIFunction: format
     * Formats a number for output.
     * 
     * Parameters:
     * num  - {Float}
     * dec  - {Integer} Number of decimal places to round to.
     *        Defaults to 0. Set to null to leave decimal places unchanged.
     * tsep - {String} Thousands separator.
     *        Default is ",".
     * dsep - {String} Decimal separator.
     *        Default is ".".
     *
     * Returns:
     * {String} A string representing the formatted number.
     */
    format: function(num, dec, tsep, dsep) {
        dec = (typeof dec != "undefined") ? dec : 0; 
        tsep = (typeof tsep != "undefined") ? tsep :
            GeoGlobe.Number.thousandsSeparator; 
        dsep = (typeof dsep != "undefined") ? dsep :
            GeoGlobe.Number.decimalSeparator;

        if (dec != null) {
            num = parseFloat(num.toFixed(dec));
        }

        var parts = num.toString().split(".");
        if (parts.length == 1 && dec == null) {
            // integer where we do not want to touch the decimals
            dec = 0;
        }
        
        var integer = parts[0];
        if (tsep) {
            var thousands = /(-?[0-9]+)([0-9]{3})/; 
            while(thousands.test(integer)) { 
                integer = integer.replace(thousands, "$1" + tsep + "$2"); 
            }
        }
        
        var str;
        if (dec == 0) {
            str = integer;
        } else {
            var rem = parts.length > 1 ? parts[1] : "0";
            if (dec != null) {
                rem = rem + new Array(dec - rem.length + 1).join("0");
            }
            str = integer + dsep + rem;
        }
        return str;
    },

    /**
     * Method: zeroPad
     * Create a zero padded string optionally with a radix for casting numbers.
     *
     * Parameters:
     * num - {Number} The number to be zero padded.
     * len - {Number} The length of the string to be returned.
     * radix - {Number} An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    }    
};

/**
 * Namespace: GeoGlobe.Function
 * Contains convenience functions for function manipulation.
 */
GeoGlobe.Function = {
    /**
     * APIFunction: bind
     * Bind a function to an object.  Method to easily create closures with
     *     'this' altered.
     * 
     * Parameters:
     * func - {Function} Input function.
     * object - {Object} The object to bind to the input function (as this).
     * 
     * Returns:
     * {Function} A closure with 'this' set to the passed in object.
     */
    bind: function(func, object) {
        // create a reference to all arguments past the second one
        var args = Array.prototype.slice.apply(arguments, [2]);
        return function() {
            // Push on any additional arguments from the actual function call.
            // These will come after those sent to the bind call.
            var newArgs = args.concat(
                Array.prototype.slice.apply(arguments, [0])
            );
            return func.apply(object, newArgs);
        };
    },
    
    /**
     * APIFunction: bindAsEventListener
     * Bind a function to an object, and configure it to receive the event
     *     object as first parameter when called. 
     * 
     * Parameters:
     * func - {Function} Input function to serve as an event listener.
     * object - {Object} A reference to this.
     * 
     * Returns:
     * {Function}
     */
    bindAsEventListener: function(func, object) {
        return function(event) {
            return func.call(object, event || window.event);
        };
    },
    
    /**
     * APIFunction: False
     * A simple function to that just does "return false". We use this to 
     * avoid attaching anonymous functions to DOM event handlers, which 
     * causes "issues" on IE<8.
     * 
     * Usage:
     * document.onclick = GeoGlobe.Function.False;
     * 
     * Returns:
     * {Boolean}
     */
    False : function() {
        return false;
    },

    /**
     * APIFunction: True
     * A simple function to that just does "return true". We use this to 
     * avoid attaching anonymous functions to DOM event handlers, which 
     * causes "issues" on IE<8.
     * 
     * Usage:
     * document.onclick = GeoGlobe.Function.True;
     * 
     * Returns:
     * {Boolean}
     */
    True : function() {
        return true;
    },
    
    /**
     * APIFunction: Void
     * A reusable function that returns ``undefined``.
     *
     * Returns:
     * {undefined}
     */
    Void: function() {}

};

/**
 * Namespace: GeoGlobe.Array
 * Contains convenience functions for array manipulation.
 */
GeoGlobe.Array = {

    /**
     * APIMethod: filter
     * Filter an array.  Provides the functionality of the
     *     Array.prototype.filter extension to the ECMA-262 standard.  Where
     *     available, Array.prototype.filter will be used.
     *
     * Based on well known example from http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter
     *
     * Parameters:
     * array - {Array} The array to be filtered.  This array is not mutated.
     *     Elements added to this array by the callback will not be visited.
     * callback - {Function} A function that is called for each element in
     *     the array.  If this function returns true, the element will be
     *     included in the return.  The function will be called with three
     *     arguments: the element in the array, the index of that element, and
     *     the array itself.  If the optional caller parameter is specified
     *     the callback will be called with this set to caller.
     * caller - {Object} Optional object to be set as this when the callback
     *     is called.
     *
     * Returns:
     * {Array} An array of elements from the passed in array for which the
     *     callback returns true.
     */
    filter: function(array, callback, caller) {
        var selected = [];
        if (Array.prototype.filter) {
            selected = array.filter(callback, caller);
        } else {
            var len = array.length;
            if (typeof callback != "function") {
                throw new TypeError();
            }
            for(var i=0; i<len; i++) {
                if (i in array) {
                    var val = array[i];
                    if (callback.call(caller, val, i, array)) {
                        selected.push(val);
                    }
                }
            }        
        }
        return selected;
    }
    
};


/**
 * Method: endsWith
 * 处理浏览器兼容性问题的扩展函数endsWith
 * 
 * @param {Object} searchString
 * @param {Object} position
 * 
 * Examples:
 * 
 * var str = 'To be, or not to be, that is the question.';
 * 
 * console.log(str.endsWith('question.')); // true
 * console.log(str.endsWith('to be'));     // false
 * console.log(str.endsWith('to be', 19)); // true
 */
if (!String.prototype.endsWith) {
    String.prototype.endsWith = function(searchString, position){
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.lastIndexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
}/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires OpenLayers/BaseTypes/Class.js
 */

/**
 * Class: GeoGlobe.Pixel
 * This class represents a screen coordinate, in x and y coordinates
 * 屏幕像素坐标类。
 */
GeoGlobe.Pixel = GeoGlobe.Class4OL({
    
    /**
     * APIProperty: x
     * {Number} The x coordinate
     */
    x: 0.0,

    /**
     * APIProperty: y
     * {Number} The y coordinate
     */
    y: 0.0,
    
    /**
     * Constructor: GeoGlobe.Pixel
     * Create a new GeoGlobe.Pixel instance
     *
     * Parameters:
     * x - {Number} The x coordinate
     * y - {Number} The y coordinate
     *
     * Returns:
     * An instance of GeoGlobe.Pixel
     */
    initialize: function(x, y) {
        this.x = parseFloat(x);
        this.y = parseFloat(y);
    },
    
    /**
     * Method: toString
     * Cast this object into a string
     *
     * Returns:
     * {String} The string representation of Pixel. ex: "x=200.4,y=242.2"
     */
    toString:function() {
        return ("x=" + this.x + ",y=" + this.y);
    },

    /**
     * APIMethod: clone
     * Return a clone of this pixel object
     *
     * Returns:
     * {<GeoGlobe.Pixel>} A clone pixel
     */
    clone:function() {
        return new GeoGlobe.Pixel(this.x, this.y); 
    },
    
    /**
     * APIMethod: equals
     * Determine whether one pixel is equivalent to another
     *
     * Parameters:
     * px - {<GeoGlobe.Pixel>|Object} An GeoGlobe.Pixel or an object with
     *                                  a 'x' and 'y' properties.
     *
     * Returns:
     * {Boolean} The point passed in as parameter is equal to this. Note that
     * if px passed in is null, returns false.
     */
    equals:function(px) {
        var equals = false;
        if (px != null) {
            equals = ((this.x == px.x && this.y == px.y) ||
                      (isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y)));
        }
        return equals;
    },

    /**
     * APIMethod: distanceTo
     * Returns the distance to the pixel point passed in as a parameter.
     *
     * Parameters:
     * px - {<GeoGlobe.Pixel>}
     *
     * Returns:
     * {Float} The pixel point passed in as parameter to calculate the
     *     distance to.
     */
    distanceTo:function(px) {
        return Math.sqrt(
            Math.pow(this.x - px.x, 2) +
            Math.pow(this.y - px.y, 2)
        );
    },

    /**
     * APIMethod: add
     *
     * Parameters:
     * x - {Integer}
     * y - {Integer}
     *
     * Returns:
     * {<GeoGlobe.Pixel>} A new Pixel with this pixel's x&y augmented by the 
     * values passed in.
     */
    add:function(x, y) {
        if ( (x == null) || (y == null) ) {
            throw new TypeError('Pixel.add cannot receive null values');
        }
        return new GeoGlobe.Pixel(this.x + x, this.y + y);
    },

    /**
    * APIMethod: offset
    * 
    * Parameters
    * px - {<GeoGlobe.Pixel>|Object} An GeoGlobe.Pixel or an object with
    *                                  a 'x' and 'y' properties.
    * 
    * Returns:
    * {<GeoGlobe.Pixel>} A new Pixel with this pixel's x&y augmented by the 
    *                      x&y values of the pixel passed in.
    */
    offset:function(px) {
        var newPx = this.clone();
        if (px) {
            newPx = this.add(px.x, px.y);
        }
        return newPx;
    },

    CLASS_NAME: "GeoGlobe.Pixel"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires OpenLayers/BaseTypes/Class.js
 */

/**
 * Class: GeoGlobe.Size
 * Instances of this class represent a width/height pair
 * 尺寸类，用宽和高表示一个矩形区域的尺寸大小。
 */
GeoGlobe.Size = GeoGlobe.Class4OL({

    /**
     * APIProperty: w
     * {Number} width
     */
    w: 0.0,
    
    /**
     * APIProperty: h
     * {Number} height
     */
    h: 0.0,


    /**
     * Constructor: GeoGlobe.Size
     * Create an instance of GeoGlobe.Size
     *
     * Parameters:
     * w - {Number} width
     * h - {Number} height
     */
    initialize: function(w, h) {
        this.w = parseFloat(w);
        this.h = parseFloat(h);
    },

    /**
     * Method: toString
     * Return the string representation of a size object
     *
     * Returns:
     * {String} The string representation of GeoGlobe.Size object. 
     * (e.g. <i>"w=55,h=66"</i>)
     */
    toString:function() {
        return ("w=" + this.w + ",h=" + this.h);
    },

    /**
     * APIMethod: clone
     * Create a clone of this size object
     *
     * Returns:
     * {<GeoGlobe.Size>} A new GeoGlobe.Size object with the same w and h
     * values
     */
    clone:function() {
        return new GeoGlobe.Size(this.w, this.h);
    },

    /**
     *
     * APIMethod: equals
     * Determine where this size is equal to another
     *
     * Parameters:
     * sz - {<GeoGlobe.Size>|Object} An GeoGlobe.Size or an object with
     *                                  a 'w' and 'h' properties.
     *
     * Returns: 
     * {Boolean} The passed in size has the same h and w properties as this one.
     * Note that if sz passed in is null, returns false.
     */
    equals:function(sz) {
        var equals = false;
        if (sz != null) {
            equals = ((this.w == sz.w && this.h == sz.h) ||
                      (isNaN(this.w) && isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h)));
        }
        return equals;
    },

    CLASS_NAME: "GeoGlobe.Size"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * Namespace: GeoGlobe.Date
 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 */
GeoGlobe.Date = {

    /** 
     * APIProperty: dateRegEx
     * The regex to be used for validating dates. You can provide your own
     * regex for instance for adding support for years before BC. Default
     * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
     */
    dateRegEx: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/,

    /**
     * APIMethod: toISOString
     * Generates a string representing a date.  The format of the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  If the toISOString method is
     *     available on the Date prototype, that is used.  The toISOString
     *     method for Date instances is defined in ECMA-262.
     *
     * Parameters:
     * date - {Date} A date object.
     *
     * Returns:
     * {String} A string representing the date (e.g.
     *     "2010-08-07T16:58:23.123Z").  If the date does not have a valid time
     *     (i.e. isNaN(date.getTime())) this method returns the string "Invalid
     *     Date".  The ECMA standard says the toISOString method should throw
     *     RangeError in this case, but Firefox returns a string instead.  For
     *     best results, use isNaN(date.getTime()) to determine date validity
     *     before generating date strings.
     */
    toISOString: (function() {
        if ("toISOString" in Date.prototype) {
            return function(date) {
                return date.toISOString();
            };
        } else {
            return function(date) {
                var str;
                if (isNaN(date.getTime())) {
                    // ECMA-262 says throw RangeError, Firefox returns
                    // "Invalid Date"
                    str = "Invalid Date";
                } else {
                    str =
                        date.getUTCFullYear() + "-" +
                        GeoGlobe.Number.zeroPad(date.getUTCMonth() + 1, 2) + "-" +
                        GeoGlobe.Number.zeroPad(date.getUTCDate(), 2) + "T" +
                        GeoGlobe.Number.zeroPad(date.getUTCHours(), 2) + ":" +
                        GeoGlobe.Number.zeroPad(date.getUTCMinutes(), 2) + ":" +
                        GeoGlobe.Number.zeroPad(date.getUTCSeconds(), 2) + "." +
                        GeoGlobe.Number.zeroPad(date.getUTCMilliseconds(), 3) + "Z";
                }
                return str;
            };
        }

    })(),

    /**
     * APIMethod: parse
     * Generate a date object from a string.  The format for the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  We don't call the native
     *     Date.parse because of inconsistency between implmentations.  In
     *     Chrome, calling Date.parse with a string that doesn't contain any
     *     indication of the timezone (e.g. "2011"), the date is interpreted
     *     in local time.  On Firefox, the assumption is UTC.
     *
     * Parameters:
     * str - {String} A string representing the date (e.g.
     *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
     *     "2010-08-07T11:58:23.123-06").
     *
     * Returns:
     * {Date} A date object.  If the string could not be parsed, an invalid
     *     date is returned (i.e. isNaN(date.getTime())).
     */
    parse: function(str) {
        var date;
        var match = str.match(this.dateRegEx);
        if (match && (match[1] || match[7])) { // must have at least year or time
            var year = parseInt(match[1], 10) || 0;
            var month = (parseInt(match[2], 10) - 1) || 0;
            var day = parseInt(match[3], 10) || 1;
            date = new Date(Date.UTC(year, month, day));
            // optional time
            var type = match[7];
            if (type) {
                var hours = parseInt(match[4], 10);
                var minutes = parseInt(match[5], 10);
                var secFrac = parseFloat(match[6]);
                var seconds = secFrac | 0;
                var milliseconds = Math.round(1000 * (secFrac - seconds));
                date.setUTCHours(hours, minutes, seconds, milliseconds);
                // check offset
                if (type !== "Z") {
                    var hoursOffset = parseInt(type, 10);
                    var minutesOffset = parseInt(match[8], 10) || 0;
                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
                    date = new Date(date.getTime() + offset);
                }
            }
        } else {
            date = new Date("invalid");
        }
        return date;
    }
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/tool/Class.js
 */

/**
 * Namespace: GeoGlobe.Console
 * The GeoGlobe.Console namespace is used for debugging and error logging.
 * If the Firebug Lite (../Firebug/firebug.js) is included before this script,
 * calls to GeoGlobe.Console methods will get redirected to window.console.
 * This makes use of the Firebug extension where available and allows for
 * cross-browser debugging Firebug style.
 *
 * Note:
 * Note that behavior will differ with the Firebug extention and Firebug Lite.
 * Most notably, the Firebug Lite console does not currently allow for
 * hyperlinks to code or for clicking on object to explore their properties.
 * 
 */
GeoGlobe.Console = {
    /**
     * Create empty functions for all console methods.  The real value of these
     * properties will be set if Firebug Lite (../Firebug/firebug.js script) is
     * included.  We explicitly require the Firebug Lite script to trigger
     * functionality of the GeoGlobe.Console methods.
     */
    
    /**
     * APIFunction: log
     * Log an object in the console.  The Firebug Lite console logs string
     * representation of objects.  Given multiple arguments, they will
     * be cast to strings and logged with a space delimiter.  If the first
     * argument is a string with printf-like formatting, subsequent arguments
     * will be used in string substitution.  Any additional arguments (beyond
     * the number substituted in a format string) will be appended in a space-
     * delimited line.
     * 
     * Parameters:
     * object - {Object}
     */
    log: function() {},

    /**
     * APIFunction: debug
     * Writes a message to the console, including a hyperlink to the line
     * where it was called.
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     * 
     * Parameters:
     * object - {Object}
     */
    debug: function() {},

    /**
     * APIFunction: info
     * Writes a message to the console with the visual "info" icon and color
     * coding and a hyperlink to the line where it was called.
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     * 
     * Parameters:
     * object - {Object}
     */
    info: function() {},

    /**
     * APIFunction: warn
     * Writes a message to the console with the visual "warning" icon and
     * color coding and a hyperlink to the line where it was called.
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     * 
     * Parameters:
     * object - {Object}
     */
    warn: function() {},

    /**
     * APIFunction: error
     * Writes a message to the console with the visual "error" icon and color
     * coding and a hyperlink to the line where it was called.
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     * 
     * Parameters:
     * object - {Object}
     */
    error: function() {},
    
    /**
     * APIFunction: userError
     * A single interface for showing error messages to the user. The default
     * behavior is a Javascript alert, though this can be overridden by
     * reassigning GeoGlobe.Console.userError to a different function.
     *
     * Expects a single error message
     * 
     * Parameters:
     * error - {Object}
     */
    userError: function(error) {
        alert(error);
    },

    /**
     * APIFunction: assert
     * Tests that an expression is true. If not, it will write a message to
     * the console and throw an exception.
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     * 
     * Parameters:
     * object - {Object}
     */
    assert: function() {},

    /**
     * APIFunction: dir
     * Prints an interactive listing of all properties of the object. This
     * looks identical to the view that you would see in the DOM tab.
     * 
     * Parameters:
     * object - {Object}
     */
    dir: function() {},

    /**
     * APIFunction: dirxml
     * Prints the XML source tree of an HTML or XML element. This looks
     * identical to the view that you would see in the HTML tab. You can click
     * on any node to inspect it in the HTML tab.
     * 
     * Parameters:
     * object - {Object}
     */
    dirxml: function() {},

    /**
     * APIFunction: trace
     * Prints an interactive stack trace of JavaScript execution at the point
     * where it is called.  The stack trace details the functions on the stack,
     * as well as the values that were passed as arguments to each function.
     * You can click each function to take you to its source in the Script tab,
     * and click each argument value to inspect it in the DOM or HTML tabs.
     * 
     */
    trace: function() {},

    /**
     * APIFunction: group
     * Writes a message to the console and opens a nested block to indent all
     * future messages sent to the console. Call GeoGlobe.Console.groupEnd()
     * to close the block.
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     * 
     * Parameters:
     * object - {Object}
     */
    group: function() {},

    /**
     * APIFunction: groupEnd
     * Closes the most recently opened block created by a call to
     * GeoGlobe.Console.group
     */
    groupEnd: function() {},
    
    /**
     * APIFunction: time
     * Creates a new timer under the given name. Call
     * GeoGlobe.Console.timeEnd(name)
     * with the same name to stop the timer and print the time elapsed.
     *
     * Parameters:
     * name - {String}
     */
    time: function() {},

    /**
     * APIFunction: timeEnd
     * Stops a timer created by a call to GeoGlobe.Console.time(name) and
     * writes the time elapsed.
     *
     * Parameters:
     * name - {String}
     */
    timeEnd: function() {},

    /**
     * APIFunction: profile
     * Turns on the JavaScript profiler. The optional argument title would
     * contain the text to be printed in the header of the profile report.
     *
     * This function is not currently implemented in Firebug Lite.
     * 
     * Parameters:
     * title - {String} Optional title for the profiler
     */
    profile: function() {},

    /**
     * APIFunction: profileEnd
     * Turns off the JavaScript profiler and prints its report.
     * 
     * This function is not currently implemented in Firebug Lite.
     */
    profileEnd: function() {},

    /**
     * APIFunction: count
     * Writes the number of times that the line of code where count was called
     * was executed. The optional argument title will print a message in
     * addition to the number of the count.
     *
     * This function is not currently implemented in Firebug Lite.
     *
     * Parameters:
     * title - {String} Optional title to be printed with count
     */
    count: function() {},

    CLASS_NAME: "GeoGlobe.Console"
};

/**
 * Execute an anonymous function to extend the GeoGlobe.Console namespace
 * if the firebug.js script is included.  This closure is used so that the
 * "scripts" and "i" variables don't pollute the global namespace.
 */
(function() {
    /**
     * If Firebug Lite is included (before this script), re-route all
     * GeoGlobe.Console calls to the console object.
     */
    var scripts = document.getElementsByTagName("script");
    for(var i=0, len=scripts.length; i<len; ++i) {
        if(scripts[i].src.indexOf("firebug.js") != -1) {
            if(console) {
                GeoGlobe.Util.extend(GeoGlobe.Console, console);
                break;
            }
        }
    }
})();
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/tool/Request/XMLHttpRequest.js
 */

/**
 * TODO: deprecate me
 * Use GeoGlobe.Request.proxy instead.
 */
GeoGlobe.ProxyHost = "";

/**
 * Namespace: GeoGlobe.Request
 * The GeoGlobe.Request namespace contains convenience methods for working
 *     with XMLHttpRequests.  These methods work with a cross-browser
 *     W3C compliant <GeoGlobe.Request.XMLHttpRequest> class.
 */
if (!GeoGlobe.Request) {
    /**
     * This allows for tool/Request/XMLHttpRequest.js to be included
     * before or after this script.
     */
    GeoGlobe.Request = {};
}
GeoGlobe.Util.extend(GeoGlobe.Request, {
    
    /**
     * Constant: DEFAULT_CONFIG
     * {Object} Default configuration for all requests.
     */
    DEFAULT_CONFIG: {
        method: "GET",
        url: window.location.href,
        async: true,
        user: undefined,
        password: undefined,
        params: null,
        proxy: GeoGlobe.ProxyHost,
        headers: {},
        data: null,
        callback: function() {},
        success: null,
        failure: null,
        scope: null
    },
    
    /**
     * Constant: URL_SPLIT_REGEX
     */
    URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
    
    /**
     * APIProperty: events
     * {<GeoGlobe.Events>} An events object that handles all 
     *     events on the {<GeoGlobe.Request>} object.
     *
     * All event listeners will receive an event object with three properties:
     * request - {<GeoGlobe.Request.XMLHttpRequest>} The request object.
     * config - {Object} The config object sent to the specific request method.
     * requestUrl - {String} The request url.
     * 
     * Supported event types:
     * complete - Triggered when we have a response from the request, if a
     *     listener returns false, no further response processing will take
     *     place.
     * success - Triggered when the HTTP response has a success code (200-299).
     * failure - Triggered when the HTTP response does not have a success code.
     */
    //events: new GeoGlobe.Events(this),
    
    /**
     * Method: makeSameOrigin
     * Using the specified proxy, returns a same origin url of the provided url.
     *
     * Parameters:
     * url - {String} An arbitrary url
     * proxy {String|Function} The proxy to use to make the provided url a
     *     same origin url.
     *
     * Returns
     * {String} the same origin url. If no proxy is provided, the returned url
     *     will be the same as the provided url.
     */
    makeSameOrigin: function(url, proxy) {
        var sameOrigin = url.indexOf("http") !== 0;
        var urlParts = !sameOrigin && url.match(this.URL_SPLIT_REGEX);
        if (urlParts) {
            var location = window.location;
            sameOrigin =
                urlParts[1] == location.protocol &&
                urlParts[3] == location.hostname;
            var uPort = urlParts[4], lPort = location.port;
            if (uPort != 80 && uPort != "" || lPort != "80" && lPort != "") {
                sameOrigin = sameOrigin && uPort == lPort;
            }
        }
        if (!sameOrigin) {
            if (proxy) {
                if (typeof proxy == "function") {
                    url = proxy(url);
                } else {
                      if(url.indexOf("cts?") >= 0){
                        url = proxy + url;
                    }else{
                        url = proxy + encodeURIComponent(url);
                    }
                }
            }
        }
        return url;
    },

    /**
     * APIMethod: issue
     * Create a new XMLHttpRequest object, open it, set any headers, bind
     *     a callback to done state, and send any data.  It is recommended that
     *     you use one <GET>, <POST>, <PUT>, <DELETE>, <OPTIONS>, or <HEAD>.
     *     This method is only documented to provide detail on the configuration
     *     options available to all request methods.
     *
     * Parameters:
     * config - {Object} Object containing properties for configuring the
     *     request.  Allowed configuration properties are described below.
     *     This object is modified and should not be reused.
     *
     * Allowed config properties:
     * method - {String} One of GET, POST, PUT, DELETE, HEAD, or
     *     OPTIONS.  Default is GET.
     * url - {String} URL for the request.
     * async - {Boolean} Open an asynchronous request.  Default is true.
     * user - {String} User for relevant authentication scheme.  Set
     *     to null to clear current user.
     * password - {String} Password for relevant authentication scheme.
     *     Set to null to clear current password.
     * proxy - {String} Optional proxy.  Defaults to
     *     <GeoGlobe.ProxyHost>.
     * params - {Object} Any key:value pairs to be appended to the
     *     url as a query string.  Assumes url doesn't already include a query
     *     string or hash.  Typically, this is only appropriate for <GET>
     *     requests where the query string will be appended to the url.
     *     Parameter values that are arrays will be
     *     concatenated with a comma (note that this goes against form-encoding)
     *     as is done with <GeoGlobe.Util.getParameterString>.
     * headers - {Object} Object with header:value pairs to be set on
     *     the request.
     * data - {String | Document} Optional data to send with the request.
     *     Typically, this is only used with <POST> and <PUT> requests.
     *     Make sure to provide the appropriate "Content-Type" header for your
     *     data.  For <POST> and <PUT> requests, the content type defaults to
     *     "application-xml".  If your data is a different content type, or
     *     if you are using a different HTTP method, set the "Content-Type"
     *     header to match your data type.
     * callback - {Function} Function to call when request is done.
     *     To determine if the request failed, check request.status (200
     *     indicates success).
     * success - {Function} Optional function to call if request status is in
     *     the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * failure - {Function} Optional function to call if request status is not
     *     in the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * scope - {Object} If callback is a public method on some object,
     *     set the scope to that object.
     *
     * Returns:
     * {XMLHttpRequest} Request object.  To abort the request before a response
     *     is received, call abort() on the request object.
     */
    issue: function(config) {        
        // apply default config - proxy host may have changed
        var defaultConfig = GeoGlobe.Util.extend(
            this.DEFAULT_CONFIG,
            {proxy: GeoGlobe.ProxyHost}
        );
        config = config || {};
        config.headers = config.headers || {};
        config = GeoGlobe.Util.applyDefaults(config, defaultConfig);
        config.headers = GeoGlobe.Util.applyDefaults(config.headers, defaultConfig.headers);
        // Always set the "X-Requested-With" header to signal that this request
        // was issued through the XHR-object. Since header keys are case 
        // insensitive and we want to allow overriding of the "X-Requested-With"
        // header through the user we cannot use applyDefaults, but have to 
        // check manually whether we were called with a "X-Requested-With"
        // header.
        var customRequestedWithHeader = false,
            headerKey;
        for(headerKey in config.headers) {
            if (config.headers.hasOwnProperty( headerKey )) {
                if (headerKey.toLowerCase() === 'x-requested-with') {
                    customRequestedWithHeader = true;
                }
            }
        }
        if (customRequestedWithHeader === false) {
            // we did not have a custom "X-Requested-With" header
            config.headers['X-Requested-With'] = 'XMLHttpRequest';
        }

        // create request, open, and set headers
        var request = new GeoGlobe.Request.XMLHttpRequest();
		config.url = encodeURI(config.url);//20170911，进行编码一次，解决带中文的url，无法请求的问题。
        var url = GeoGlobe.Util.urlAppend(config.url, 
            GeoGlobe.Util.getParameterString(config.params || {}));
        url = GeoGlobe.Request.makeSameOrigin(url, config.proxy);
        request.open(
            config.method, url, config.async, config.user, config.password
        );
        for(var header in config.headers) {
            request.setRequestHeader(header, config.headers[header]);
        }

        //var events = this.events;

        // we want to execute runCallbacks with "this" as the
        // execution scope
        var self = this;
        
        request.onreadystatechange = function() {
            if(request.readyState == GeoGlobe.Request.XMLHttpRequest.DONE) {
				/*
                var proceed = events.triggerEvent(
                    "complete",
                    {request: request, config: config, requestUrl: url}
                );
                */
				var proceed = null;//TODO by sw.2017.5.8 
                if(proceed !== false) {
                    self.runCallbacks(
                        {request: request, config: config, requestUrl: url}
                    );
                }
            }
        };
        
        // send request (optionally with data) and return
        // call in a timeout for asynchronous requests so the return is
        // available before readyState == 4 for cached docs
        if(config.async === false) {
            request.send(config.data);
        } else {
            window.setTimeout(function(){
                if (request.readyState !== 0) { // W3C: 0-UNSENT
                    request.send(config.data);
                }
            }, 0);
        }
        return request;
    },
    
    /**
     * Method: runCallbacks
     * Calls the complete, success and failure callbacks. Application
     *    can listen to the "complete" event, have the listener 
     *    display a confirm window and always return false, and
     *    execute GeoGlobe.Request.runCallbacks if the user
     *    hits "yes" in the confirm window.
     *
     * Parameters:
     * options - {Object} Hash containing request, config and requestUrl keys
     */
    runCallbacks: function(options) {
        var request = options.request;
        var config = options.config;
        
        // bind callbacks to readyState 4 (done)
        var complete = (config.scope) ?
            GeoGlobe.Function.bind(config.callback, config.scope) :
            config.callback;
        
        // optional success callback
        var success;
        if(config.success) {
            success = (config.scope) ?
                GeoGlobe.Function.bind(config.success, config.scope) :
                config.success;
        }

        // optional failure callback
        var failure;
        if(config.failure) {
            failure = (config.scope) ?
                GeoGlobe.Function.bind(config.failure, config.scope) :
                config.failure;
        }

        if (GeoGlobe.Util.createUrlObject(config.url).protocol == "file:" &&
                                                        request.responseText) {
            request.status = 200;
        }
        complete(request);

        if (!request.status || (request.status >= 200 && request.status < 300)) {
            //this.events.triggerEvent("success", options);//TODO
            if(success) {
                success(request);
            }
        }
        if(request.status && (request.status < 200 || request.status >= 300)) {                    
            //this.events.triggerEvent("failure", options);//TODO
            if(failure) {
                failure(request);
            }
        }
    },
    
    /**
     * APIMethod: GET
     * Send an HTTP GET request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to GET.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    GET: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "GET"});
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * APIMethod: POST
     * Send a POST request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to POST and "Content-Type" header set to "application/xml".
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    POST: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "POST"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * APIMethod: PUT
     * Send an HTTP PUT request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to PUT and "Content-Type" header set to "application/xml".
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    PUT: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "PUT"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * APIMethod: DELETE
     * Send an HTTP DELETE request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to DELETE.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    DELETE: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "DELETE"});
        return GeoGlobe.Request.issue(config);
    },
  
    /**
     * APIMethod: HEAD
     * Send an HTTP HEAD request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to HEAD.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    HEAD: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "HEAD"});
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * APIMethod: OPTIONS
     * Send an HTTP OPTIONS request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to OPTIONS.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    OPTIONS: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "OPTIONS"});
        return GeoGlobe.Request.issue(config);
    }

});


/**
 * Function: GeoGlobe.nullHandler
 * @param {} request
 */
GeoGlobe.nullHandler = function(request) {
    GeoGlobe.Console.userError(GeoGlobe.i18n("unhandledRequest", {'statusText':request.statusText}));
};

/** 
 * APIFunction: GeoGlobe.loadURL
 * Background load a document.
 * *Deprecated*.  Use <GeoGlobe.Request.GET> method instead.
 *
 * Parameters:
 * uri - {String} URI of source doc
 * params - {String} or {Object} GET params. Either a string in the form
 *     "?hello=world&foo=bar" (do not forget the leading question mark)
 *     or an object in the form {'hello': 'world', 'foo': 'bar}
 * caller - {Object} object which gets callbacks
 * onComplete - {Function} Optional callback for success.  The callback
 *     will be called with this set to caller and will receive the request
 *     object as an argument.  Note that if you do not specify an onComplete
 *     function, <GeoGlobe.nullHandler> will be called (which pops up a 
 *     user friendly error message dialog).
 * onFailure - {Function} Optional callback for failure.  In the event of
 *     a failure, the callback will be called with this set to caller and will
 *     receive the request object as an argument.  Note that if you do not
 *     specify an onComplete function, <GeoGlobe.nullHandler> will be called
 *     (which pops up a user friendly error message dialog).
 *
 * Returns:
 * {<GeoGlobe.Request.XMLHttpRequest>}  The request object. To abort loading,
 *     call request.abort().
 */
GeoGlobe.loadURL = function(uri, params, caller,
                                  onComplete, onFailure) {
    
    if(typeof params == 'string') {
        params = GeoGlobe.Util.getParameters(params);
    }
    var success = (onComplete) ? onComplete : GeoGlobe.nullHandler;
    var failure = (onFailure) ? onFailure : GeoGlobe.nullHandler;
    
    return GeoGlobe.Request.GET({
        url: uri, params: params,
        success: success, failure: failure, scope: caller
    });
};

/**
 * APIMethod: setProxyHost
 * 设置代理地址,根据自己的代理器地址来配置
 * 
 * Parameters:
 * proxyHost - {String} 代理地址
 * 
 */
GeoGlobe.Request.setProxyHost = function(proxyHost){
	GeoGlobe.ProxyHost = proxyHost;
};

/**
 * APIMethod: getProxyHost
 * 代理地址
 *
 * Returns:
 * {String} 代理地址
 */
GeoGlobe.Request.getProxyHost = function(){
	return GeoGlobe.ProxyHost;
};

/**
 * APIMethod: appendToProxy
 * 处理带中文的url
 *
 * Returns:
 * {String} 带代理地址的url
 */
GeoGlobe.appendToProxy = function(url){
	var arr = url.split("?");
	var u1 = GeoGlobe.ProxyHost + encodeURI(encodeURI(arr[0]));
	if(arr.length === 2){
		u1 += "?" + arr[1];
	}
	return u1;
};

/**
 * APIMethod: loadScript
 * 加载javascript文件
 *
 * Parameters:
 * url - {String} js文件路径。
 */
GeoGlobe.loadScript = function(url){
	GeoGlobe.Request.GET({
		url: url,
		async: false,
		headers: {
			"Accept": "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01"
		},
		//callback: callback,
		success: function(e){
			GeoGlobe.Util.globalEval(e.responseText);
			//if(typeof(callback) === "function"){
			//	callback(e);
			//}
		},
		failure: function(e){
			alert("加载:"+url+" 失败。");
		}
	});
};
// XMLHttpRequest.js Copyright (C) 2010 Sergey Ilinsky (http://www.ilinsky.com)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @requires View2D/tool/Request/Request.js
 */

(function () {

    // Save reference to earlier defined object implementation (if any)
    var oXMLHttpRequest    = window.XMLHttpRequest;

    // Define on browser type
    var bGecko    = !!window.controllers,
        bIE        = window.document.all && !window.opera,
        bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);

    // Enables "XMLHttpRequest()" call next to "new XMLHttpReques()"
    function fXMLHttpRequest() {
        this._object    = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject("Microsoft.XMLHTTP");
        this._listeners    = [];
    };

    // Constructor
    function cXMLHttpRequest() {
        return new fXMLHttpRequest;
    };
    cXMLHttpRequest.prototype    = fXMLHttpRequest.prototype;

    // BUGFIX: Firefox with Firebug installed would break pages if not executed
    if (bGecko && oXMLHttpRequest.wrapped)
        cXMLHttpRequest.wrapped    = oXMLHttpRequest.wrapped;

    // Constants
    cXMLHttpRequest.UNSENT                = 0;
    cXMLHttpRequest.OPENED                = 1;
    cXMLHttpRequest.HEADERS_RECEIVED    = 2;
    cXMLHttpRequest.LOADING                = 3;
    cXMLHttpRequest.DONE                = 4;

    // Public Properties
    cXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;
    cXMLHttpRequest.prototype.responseText    = '';
    cXMLHttpRequest.prototype.responseXML    = null;
    cXMLHttpRequest.prototype.status        = 0;
    cXMLHttpRequest.prototype.statusText    = '';

    // Priority proposal
    cXMLHttpRequest.prototype.priority        = "NORMAL";

    // Instance-level Events Handlers
    cXMLHttpRequest.prototype.onreadystatechange    = null;

    // Class-level Events Handlers
    cXMLHttpRequest.onreadystatechange    = null;
    cXMLHttpRequest.onopen                = null;
    cXMLHttpRequest.onsend                = null;
    cXMLHttpRequest.onabort                = null;

    // Public Methods
    cXMLHttpRequest.prototype.open    = function(sMethod, sUrl, bAsync, sUser, sPassword) {
        // Delete headers, required when object is reused
        delete this._headers;

        // When bAsync parameter value is omitted, use true as default
        if (arguments.length < 3)
            bAsync    = true;

        // Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests
        this._async        = bAsync;

        // Set the onreadystatechange handler
        var oRequest    = this,
            nState        = this.readyState,
            fOnUnload;

        // BUGFIX: IE - memory leak on page unload (inter-page leak)
        if (bIE && bAsync) {
            fOnUnload = function() {
                if (nState != cXMLHttpRequest.DONE) {
                    fCleanTransport(oRequest);
                    // Safe to abort here since onreadystatechange handler removed
                    oRequest.abort();
                }
            };
            window.attachEvent("onunload", fOnUnload);
        }

        // Add method sniffer
        if (cXMLHttpRequest.onopen)
            cXMLHttpRequest.onopen.apply(this, arguments);

        if (arguments.length > 4)
            this._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
        else
        if (arguments.length > 3)
            this._object.open(sMethod, sUrl, bAsync, sUser);
        else
            this._object.open(sMethod, sUrl, bAsync);

        /*
         * 解决在IE10下请求后返回的XML数据不是文档类型，从而无法使用selectNodes方法的问题。
         * 在此设置响应返回的数据类型为"msxml-document"，就可以得到XML document，也能使用selectNodes方法了。
         */
		try {
			this._object.responseType = "msxml-document";
		}catch(e){
			
		}
		this.readyState    = cXMLHttpRequest.OPENED;
        fReadyStateChange(this);

        this._object.onreadystatechange    = function() {
            if (bGecko && !bAsync)
                return;

            // Synchronize state
            oRequest.readyState        = oRequest._object.readyState;

            //
            fSynchronizeValues(oRequest);

            // BUGFIX: Firefox fires unnecessary DONE when aborting
            if (oRequest._aborted) {
                // Reset readyState to UNSENT
                oRequest.readyState    = cXMLHttpRequest.UNSENT;

                // Return now
                return;
            }

            if (oRequest.readyState == cXMLHttpRequest.DONE) {
                // Free up queue
                delete oRequest._data;
/*                if (bAsync)
                    fQueue_remove(oRequest);*/
                //
                fCleanTransport(oRequest);
// Uncomment this block if you need a fix for IE cache
/*
                // BUGFIX: IE - cache issue
                if (!oRequest._object.getResponseHeader("Date")) {
                    // Save object to cache
                    oRequest._cached    = oRequest._object;

                    // Instantiate a new transport object
                    cXMLHttpRequest.call(oRequest);

                    // Re-send request
                    if (sUser) {
                         if (sPassword)
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
                        else
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser);
                    }
                    else
                        oRequest._object.open(sMethod, sUrl, bAsync);
                    oRequest._object.setRequestHeader("If-Modified-Since", oRequest._cached.getResponseHeader("Last-Modified") || new window.Date(0));
                    // Copy headers set
                    if (oRequest._headers)
                        for (var sHeader in oRequest._headers)
                            if (typeof oRequest._headers[sHeader] == "string")    // Some frameworks prototype objects with functions
                                oRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);

                    oRequest._object.onreadystatechange    = function() {
                        // Synchronize state
                        oRequest.readyState        = oRequest._object.readyState;

                        if (oRequest._aborted) {
                            //
                            oRequest.readyState    = cXMLHttpRequest.UNSENT;

                            // Return
                            return;
                        }

                        if (oRequest.readyState == cXMLHttpRequest.DONE) {
                            // Clean Object
                            fCleanTransport(oRequest);

                            // get cached request
                            if (oRequest.status == 304)
                                oRequest._object    = oRequest._cached;

                            //
                            delete oRequest._cached;

                            //
                            fSynchronizeValues(oRequest);

                            //
                            fReadyStateChange(oRequest);

                            // BUGFIX: IE - memory leak in interrupted
                            if (bIE && bAsync)
                                window.detachEvent("onunload", fOnUnload);
                        }
                    };
                    oRequest._object.send(null);

                    // Return now - wait until re-sent request is finished
                    return;
                };
*/
                // BUGFIX: IE - memory leak in interrupted
                if (bIE && bAsync)
                     window.detachEvent("onunload", fOnUnload);
            }

            // BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice
            if (nState != oRequest.readyState)
                fReadyStateChange(oRequest);

            nState    = oRequest.readyState;
        }
    };
    function fXMLHttpRequest_send(oRequest) {
        oRequest._object.send(oRequest._data);

        // BUGFIX: Gecko - missing readystatechange calls in synchronous requests
        if (bGecko && !oRequest._async) {
            oRequest.readyState    = cXMLHttpRequest.OPENED;

            // Synchronize state
            fSynchronizeValues(oRequest);

            // Simulate missing states
            while (oRequest.readyState < cXMLHttpRequest.DONE) {
                oRequest.readyState++;
                fReadyStateChange(oRequest);
                // Check if we are aborted
                if (oRequest._aborted)
                    return;
            }
        }
    };
    cXMLHttpRequest.prototype.send    = function(vData) {
        // Add method sniffer
        if (cXMLHttpRequest.onsend)
            cXMLHttpRequest.onsend.apply(this, arguments);

        if (!arguments.length)
            vData    = null;

        // BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required
        // BUGFIX: IE - rewrites any custom mime-type to "text/xml" in case an XMLNode is sent
        // BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)
        if (vData && vData.nodeType) {
            vData    = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;
            if (!this._headers["Content-Type"])
                this._object.setRequestHeader("Content-Type", "application/xml");
        }

        this._data    = vData;
/*
        // Add to queue
        if (this._async)
            fQueue_add(this);
        else*/
            fXMLHttpRequest_send(this);
    };
    cXMLHttpRequest.prototype.abort    = function() {
        // Add method sniffer
        if (cXMLHttpRequest.onabort)
            cXMLHttpRequest.onabort.apply(this, arguments);

        // BUGFIX: Gecko - unnecessary DONE when aborting
        if (this.readyState > cXMLHttpRequest.UNSENT)
            this._aborted    = true;

        this._object.abort();

        // BUGFIX: IE - memory leak
        fCleanTransport(this);

        this.readyState    = cXMLHttpRequest.UNSENT;

        delete this._data;
/*        if (this._async)
            fQueue_remove(this);*/
    };
    cXMLHttpRequest.prototype.getAllResponseHeaders    = function() {
        return this._object.getAllResponseHeaders();
    };
    cXMLHttpRequest.prototype.getResponseHeader    = function(sName) {
        return this._object.getResponseHeader(sName);
    };
    cXMLHttpRequest.prototype.setRequestHeader    = function(sName, sValue) {
        // BUGFIX: IE - cache issue
        if (!this._headers)
            this._headers    = {};
        this._headers[sName]    = sValue;

        return this._object.setRequestHeader(sName, sValue);
    };

    // EventTarget interface implementation
    cXMLHttpRequest.prototype.addEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                return;
        // Add listener
        this._listeners.push([sName, fHandler, bUseCapture]);
    };

    cXMLHttpRequest.prototype.removeEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                break;
        // Remove listener
        if (oListener)
            this._listeners.splice(nIndex, 1);
    };

    cXMLHttpRequest.prototype.dispatchEvent    = function(oEvent) {
        var oEventPseudo    = {
            'type':            oEvent.type,
            'target':        this,
            'currentTarget':this,
            'eventPhase':    2,
            'bubbles':        oEvent.bubbles,
            'cancelable':    oEvent.cancelable,
            'timeStamp':    oEvent.timeStamp,
            'stopPropagation':    function() {},    // There is no flow
            'preventDefault':    function() {},    // There is no default action
            'initEvent':        function() {}    // Original event object should be initialized
        };

        // Execute onreadystatechange
        if (oEventPseudo.type == "readystatechange" && this.onreadystatechange)
            (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);

        // Execute listeners
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == oEventPseudo.type && !oListener[2])
                (oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);
    };

    //
    cXMLHttpRequest.prototype.toString    = function() {
        return '[' + "object" + ' ' + "XMLHttpRequest" + ']';
    };

    cXMLHttpRequest.toString    = function() {
        return '[' + "XMLHttpRequest" + ']';
    };

    // Helper function
    function fReadyStateChange(oRequest) {
        // Sniffing code
        if (cXMLHttpRequest.onreadystatechange)
            cXMLHttpRequest.onreadystatechange.apply(oRequest);

        // Fake event
        oRequest.dispatchEvent({
            'type':            "readystatechange",
            'bubbles':        false,
            'cancelable':    false,
            'timeStamp':    new Date + 0
        });
    };

    function fGetDocument(oRequest) {
        var oDocument    = oRequest.responseXML,
            sResponse    = oRequest.responseText;
        // Try parsing responseText
        if (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/)) {
            oDocument    = new window.ActiveXObject("Microsoft.XMLDOM");
            oDocument.async                = false;
            oDocument.validateOnParse    = false;
            oDocument.loadXML(sResponse);
        }
        // Check if there is no error in document
        if (oDocument)
            if ((bIE && oDocument.parseError != 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == "parsererror"))
                return null;
        return oDocument;
    };

    function fSynchronizeValues(oRequest) {
        try {    oRequest.responseText    = oRequest._object.responseText;    } catch (e) {}
        try {    oRequest.responseXML    = fGetDocument(oRequest._object);    } catch (e) {}
        try {    oRequest.status            = oRequest._object.status;            } catch (e) {}
        try {    oRequest.statusText        = oRequest._object.statusText;        } catch (e) {}
    };

    function fCleanTransport(oRequest) {
        // BUGFIX: IE - memory leak (on-page leak)
        oRequest._object.onreadystatechange    = new window.Function;
    };
/*
    // Queue manager
    var oQueuePending    = {"CRITICAL":[],"HIGH":[],"NORMAL":[],"LOW":[],"LOWEST":[]},
        aQueueRunning    = [];
    function fQueue_add(oRequest) {
        oQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : "NORMAL"].push(oRequest);
        //
        setTimeout(fQueue_process);
    };

    function fQueue_remove(oRequest) {
        for (var nIndex = 0, bFound    = false; nIndex < aQueueRunning.length; nIndex++)
            if (bFound)
                aQueueRunning[nIndex - 1]    = aQueueRunning[nIndex];
            else
            if (aQueueRunning[nIndex] == oRequest)
                bFound    = true;
        if (bFound)
            aQueueRunning.length--;
        //
        setTimeout(fQueue_process);
    };

    function fQueue_process() {
        if (aQueueRunning.length < 6) {
            for (var sPriority in oQueuePending) {
                if (oQueuePending[sPriority].length) {
                    var oRequest    = oQueuePending[sPriority][0];
                    oQueuePending[sPriority]    = oQueuePending[sPriority].slice(1);
                    //
                    aQueueRunning.push(oRequest);
                    // Send request
                    fXMLHttpRequest_send(oRequest);
                    break;
                }
            }
        }
    };
*/
    // Internet Explorer 5.0 (missing apply)
    if (!window.Function.prototype.apply) {
        window.Function.prototype.apply    = function(oRequest, oArguments) {
            if (!oArguments)
                oArguments    = [];
            oRequest.__func    = this;
            oRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);
            delete oRequest.__func;
        };
    };

    // Register new object with window
    /**
     * Class: GeoGlobe.Request.XMLHttpRequest
     * Standard-compliant (W3C) cross-browser implementation of the
     *     XMLHttpRequest object.  From
     *     http://code.google.com/p/xmlhttprequest/.
     */
    if (!GeoGlobe.Request) {
        /**
         * This allows for tool/Request/Request.js to be included
         * before or after this script.
         */
        GeoGlobe.Request = {};
    }
    GeoGlobe.Request.XMLHttpRequest = cXMLHttpRequest;
})();
﻿/**
 * Class: GeoGlobe.Map
 * 地图对象类，继承mapboxgl.FreeCRSMap，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *   <mapboxgl.FreeCRSMap>
 */
GeoGlobe.Map = GeoGlobe.Class(mapboxgl.FreeCRSMap,{

    /**
     * Property: container
     * {string} 地图的容器名称。
     */
    container: null,

    /**
     * Property: hash
     * {Boolaen} 地图上的位置（缩放，中心纬度、经度和中心，轴承间距）将同步散列片段的页面的URL。
     */
    hash: false,

    /**
     * Property: interactive
     * {Boolaen} 是否激活外部设备
     */
    interactive: true,

    /**
     * Property: preserveDrawingBuffer
     * {Boolaen} 地图可以导出为PNG使用地图
     */
    preserveDrawingBuffer: false,

    /**
     * Property: zoom
     * {int} 地图的当前级别。
     */
    zoom: 0,

    /**
     * Property: center
     * {<GeoGlobe.LonLat>} 地图的中心点坐标。
     */
    center: [0,0],

    /**
     * Property: minzoom
     * {int} 地图的最小级别。
     */
    minzoom: 0,

    /**
     * Property: maxzoom
     * {int} 地图的最大级别。
     */
    maxzoom: 20,

    /**
     * Property: pitch3Dzoom
     * {int} 可选，3D倾斜层级,默认为16。
     */
    pitch3Dzoom:16,

    /**
     * Property: is3Dpitching
     * {boolean} 设置是否倾斜。
     */
    is3Dpitching:true,

    /**
     * Property: isAttributionControl
     * {Boolean} 地图中是否添加属性控件，默认为true。
     */
    isAttributionControl: true,

    /**
     * Property: maxBounds
     * {GeoGlobe.Bounds} 地图的最大地理范围。
     */
    maxBounds: null,

    /**
     * Property: isScrollZoom
     * {Boolean} 是否允许滚动缩放。
     */
    isScrollZoom: true,

    /**
     * Property: isBooxZoom
     * {Boolean} 是否允许范围缩放，默认为true。
     */
    isBooxZoom: true,

    /**
     * Property: isDragRotate
     * {Boolean} 是否允许旋转，默认为true。
     */
    isDragRotate: true,

    /**
     * Property: isDragPan
     * {Boolean} 是否允许拖拽移动，默认为true。
     */
    isDragPan: true,

    /**
     * Property: isKeyboard
     * {Boolean} 是否开启键盘，默认为true。
     */
    isKeyboard: true,

    /**
     * Property: isDoubleClickZoom
     * {Boolean} 双击鼠标左键，是否进行放大地图操作，默认为true。
     */
    isDoubleClickZoom: true,

    /**
     * Property: isTouchZoomRotate
     * {Boolean} 是否允许触摸旋转缩放，默认为true。
     */
    isTouchZoomRotate: true,

    /**
     * Property: isTrackResize
     * {Boolean} 地图尺寸改变缩放自动响应，默认为true。
     */
    isTrackResize: true,

    /**
     * Property: logoPosition
     * {Boolean} 地图上的相对位置，默认为bottom-left。
     */
    logoPosition : true,

    /**
     * Property: bearingSnap
     * {int} 快速旋转
     */
    bearingSnap: 0,

    /**
     * Property: bearing
     * {int} 旋转程度
     */
    bearing: 0,

    /**
     * Property: pitch
     * {int} 倾斜程度。
     */
    pitch: 0,

    /**
     * Property: showTileBoundaries
     * {Boolaen} 是否在每一个瓦片周围绘制一个轮廓
     */
    showTileBoundaries: false,

    /**
     * Property: showCollisionBoxes
     * {Boolaen} 是否映射到数据源中的所有符号周围的框，并显示出由于冲突而渲染的符号或隐藏的符号
     */
    showCollisionBoxes: false,

    /**
     * Property: repaint
     * {Boolaen} 是否将不断重绘地图
     */
    repaint: true,

    /**
     * Property: epsg
     * {<String>}  获取地图epsg号。默认"EPSG:3857"
     */
    epsg: "EPSG:3857",


    /**
     * Property: units
     * {<String>}  获取地图单位。默认"degrees"。可能的值有"degrees","m"
     */
    units: null,

    /**
     * Constructor: GeoGlobe.Map
     * GeoGlobe.Map构造函数。
     *
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     *
     * Examples：
     * var simple = {
     * "version":8,
     * "source":{
     *  "geostar": {
     * "type": "raster",
     *  "tiles": ["http://t2.tianditu.com/DataServer?T=vec_w&x={x}&y={y}&l={z}"],
     *  "tileSize": 256
     * },
     *"layers": [
     * {
     * "id": "1",
     * "type": "raster",
     * "source": "geostar",
     * "raster-opacity":1
     * }
     * ]
     * }
     * var map = new GeoGlobe.Map({
     * style:simple,
     * container:'map',
     * zoom:4,
     * center:[112.939,31.377],
     * isAttributionControl:false
     * });
     */
    initialize: function(options){
        //map中属性的重定义
        this.options = options;
        if(options.isAttributionControl == false){
            options.attributionControl = options.isAttributionControl;
        }
        if(options.isScrollZoom == false){
            options.scrollZoom  = options.isScrollZoom;
        }
        if(options.isBooxZoom == false){
            options.boxZoom  = options.isBooxZoom;
        }
        if(options.isDragRotate == false){
            options.dragRotate  = options.isDragRotate;
        }
        if(options.isDragPan == false){
            options.dragPan  = options.isDragPan;
        }
        if(options.isKeyboard == false){
            options.keyboard  = options.isKeyboard;
        }
        if(options.isDoubleClickZoom == false){
            options.doubleClickZoom  = options.isDoubleClickZoom;
        }
        if(options.isTouchZoomRotate == false){
            options.touchZoomRotate  = options.isTouchZoomRotate;
        }
        if(options.isTrackResize == false){
            options.trackResize  = options.isTrackResize;
        }
        if(!options.epsg){
            options.epsg  = "EPSG:3857";
        }
        if(!options.units){
            options.units  = "degrees";
        }
        if(!options.isConstrain){
            options.isConstrain = false;//默认false
        }
		
		if(window.GeoGlobe && options.mapCRS){
			 window.GeoGlobe.MapOptions = {
			 	topTileExtent: options.mapCRS.topTileExtent,
			 	units: options.units
			 }
		}

        this.map = new mapboxgl.FreeCRSMap(options);
        //设置epsg号
        this.map.epsg = options.epsg;
        //地图单位
        this.map.units = options.units;
        //设置地图是否在地图边界以内拖动,默认false
        this.map.setIsConstrain(options.isConstrain);

        this.map.pitch3Dzoom = this.options.pitch3Dzoom? this.options.pitch3Dzoom: 16;
        this.map.setIs3DPZoom(this.options.is3Dpitching);
        return this.map;
    },

    /**
     * Method: setStyle
     * 设置地图样式。
     *
     * Parameters:
     * style - 地图的样式。
     */
    setStyle: function (style){
        this.map.setStyle(style);
    },

    /**
     * Method: getStyle
     * 获取指定地图样式对象。
     *
     * returns:
     * style - 地图样式对象。
     */
    getStyle: function (){
        return this.map.getStyle();
    },

    /**
     * Method: addControl
     * 添加单个控件
     *
     * Parameters:
     * control - {Control} 控件对象
     * position - {string} 添加的控件的位置，包括'top-left' , 'top-right' , 'bottom-left' , and 'bottom-right' . 默认 'top-right' .
     */
    addControl:function(control,position){
        this.map.addControl(control);
    },

    /**
     * Method: removeControl
     * 删除控件
     *
     * Parameters:
     * control - {Control} 控件对象
     */
    removeControl:function(control){
        this.map.removeControl(control);
    },

    /**
     * Method: getBounds
     * 获取地图地理范围
     *
     * returns:
     * LngLatBounds - {GeoGlobe.LngLatBounds} 获取地图地理范围.
     */
    getBounds:function(){
        return this.map.getBounds();
    },

    /**
     * Method: setMaxBounds
     * 设置地图最大地理范围
     *
     * Parameters:
     * lnglatbounds - {GeoGlobe.LngLatBounds} 指定范围 .
     */
    setMaxBounds:function(lnglatbounds){
        this.map.setMaxBounds(lnglatbounds);
    },

    /**
     * Method: setMaxZoom
     * 设置地图的最大级别
     *
     * Parameters:
     * maxzoom - {int} 最大级别.
     */
    setMaxZoom:function(maxzoom){
        this.map.setMaxZoom(maxzoom);
    },

    /**
     * Method: getMaxZoom
     * 获取地图的最大级别
     *
     * returns:
     * zoom - {number} 地图的最大级别.
     */
    getMaxZoom:function(){
        return this.map.getMaxZoom();
    },

    /**
     * Method: setMInZoom
     * 设置地图最小级别
     *
     * Parameters:
     * minzoom - {int} 最小级别.
     */
    setMinZoom:function(minzoom){
        this.map.setMinZoom(minzoom);
    },

    /**
     * Method: getMinZoom
     * 获取地图的最小级别
     *
     * returns:
     * zoom - {number} 地图的最大级别.
     */
    getMinZoom:function(){
        return this.map.getMinZoom();
    },

    /**
     * Method: project
     * 投影到指定位置的坐标点
     *
     * Parameters:
     * GeoGlobe.LngLat - {GeoGlobe.LngLat} 经纬度投影坐标.
     *
     * returns:
     * Point - {GeoGlobe.Point} 坐标像素点.
     */
    project:function(lnglat){
        return this.map.project(lnglat);
    },

    /**
     * Method: unproject
     * 像素点转换为经纬度
     *
     * Parameters:
     * point - {Point} 坐标像素点.
     *
     * returns:
     * LngLat - {LngLat} 经纬坐标.
     */
    unproject: function(point) {
        return this.map.unproject(point);
    },

    /**
     * Method: addSource
     * 地图样式添加来源。
     *
     * Parameters:
     * id -{string} 源id。
     * source -{string} 数据源对象
     */
    addSource: function(id, source) {
        this.map.addSource(id,source);
    },

    /**
     * Method: isSourceLoaded
     * 判断数据源是否加载完全。
     *
     * Parameters:
     * id -{string} 源id。
     *
     * returns:
     * boolean - {boolean} 数据源是否加载完全.
     */
    isSourceLoaded: function(id) {
        this.map.isSourceLoaded(id);
    },

    /**
     * Method: getSource
     * 获取地图样式中指定id的源。
     *
     * Parameters:
     * id - {string} 源id。
     *
     * returns:
     * object - {object} 获取指定id的数据源或者undefined.
     */
    getSource: function(id) {
        return this.map.getSource(id);
    },

    /**
     * Method: removeSource
     * 移除地图样式的来源。
     *
     * Parameters:
     * id - {string} 源id。
     */
    removeSource: function(id) {
        this.map.removeSource(id);
    },

    /**
     * Method: addLayer
     * 添加图层。
     *
     * Parameters:
     * layer - {GeoGlobe。Layer} 二维视图图层对象。
     */
    addLayer: function(layer, before) {
        this.map.addLayer(layer,before);
    },

    /**
     * Method: removeLayer
     * 删除图层
     *
     * Parameters:
     * id - {string} 要删除的图层id.
     */
    removeLayer:function(id){
        this.map.removeLayer(id);
    },

    /**
     * Method: getLayer
     * 获取指定ID图层对象
     *
     * Parameters:
     * id - {string} 要获取的图层id.
     */
    getLayer: function(id) {
        return this.map.getLayer(id);
    },

    /**
     * Method: moveLayer
     * 移动图层到不同的位置
     *
     * Parameters:
     * id - {string} 移动图层的id.
     */
    moveLayer: function(id) {
        this.map.moveLayer(id);
    },

    /**
     * Method: setFilter
     * 设置图层的过滤
     *
     * Parameters:
     * layer - {string} 要过滤的图层id
     * filter - {filter} 要过滤的条件.
     */
    setFilter: function(layer, filter) {
        this.map.setFilter(layer, filter);
    },

    /**
     * Method: setlayerZoomRange
     * 设置指定id图层的缩放范围
     *
     * Parameters:
     * layerId - {string} 要过滤的图层id
     * minzoom - {int} 最大级别
     * maxzoom - {int} 最小级别.
     */
    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this.map.setLayerZoomRange(layerId, minzoom, maxzoom);
    },

    /**
     * Method: getFilter
     * 获取图层过滤
     *
     * Parameters:
     * layer - {string}要过滤的图层id
     *
     * returns:
     * filter - {filter} 图层过滤条件
     */
    getFilter: function(layer) {
        return this.map.getFilter(layer);
    },

    /**
     * Method: setPaintProperty
     * 在指定的样式层中设置一个绘画属性的值
     *
     * Parameters:
     * layer - {string} 要过滤的图层id
     * name - {string} 绘图属性名.
     * value - {string} 属性值
     */
    setPaintProperty: function(layer, name, value, klass) {
        this.map.setPaintProperty(layer, name, value, klass);
    },

    /**
     * Method: getPaintProperty
     * 获取指定样式层的绘画属性
     *
     * Parameters:
     * layer - {string} 要过滤的图层id
     * name - {string} 绘图属性名.
     *
     * returns:
     * paint - {object} 图层绘画的属性
     */
    getPaintProperty: function(layer, name, klass) {
        return this.map.getPaintProperty(layer, name, klass);
    },

    /**
     * Method: setLayoutProperty
     * 在指定的样式层中设置布局属性的值
     *
     * Parameters:
     * layer - {string} 要过滤的图层id
     * name - {string} 布局属性名.
     * value - {string} 属性值
     */
    setLayoutProperty: function(layer, name, value) {
        this.map.setLayoutProperty(layer, name, value);

    },

    /**
     * Method: getLayoutProperty
     * 获取指定样式层的布局属性
     *
     * Parameters:
     * layer - {string} 要过滤的图层id
     * name - {string} 布局属性名.
     *
     * returns；
     * layout - {object} 图层布局属性
     */
    getLayoutProperty: function(layer, name) {
        return this.map.getLayoutProperty(layer, name);
    },

    /**
     * Method: queryRenderedFeatures
     * 获取绘制（可见）Featrues
     *
     * returns:
     * array - {object} 返回GeoJSON feature object
     */
    queryRenderedFeatures: function(geometry, param) {
        return this.map.queryRenderedFeatures(geometry, param);
    },

    /**
     * Method: querySourceFeatures
     * 获取数据源（所有）Featrues
     *
     * returns:
     * query - {object} 返回GeoJSON feature object
     */
    querySourceFeatures: function(sourceID, params) {
        return this.map.getPaintProperty(layer, name, klass);
    },

    /**
     * Method: addClass
     * 添加class
     *
     * Parameters:
     * class - {string} 添加的class
     */
    addClass: function(klass, options) {
        this.map.addClass(klass,options);
    },

    /**
     * Method: removeClass
     * 移除class
     *
     * Parameters:
     * 移除class - {string} 移除class
     */
    removeClass: function(klass, options) {
        this.map.removeClass(klass,options);
    },

    /**
     * Method: setClasses
     * 替换class
     *
     * Parameters:
     * class - {string} 设置的class
     */
    setClasses: function(klasses, options) {
        this.map.setClasses(klasses,options);
    },

    /**
     * Method: hasClasses
     * 替换class
     *
     * Parameters:
     * class - {string} 设置的class
     *
     * returns:
     * true - {boolean} 判断map是否有指定的class
     */
    hasClasses: function(klasses) {
        return this.map.hasClasses(klasses);
    },

    /**
     * Method: getClasses
     * 获取style的class
     *
     * returns:
     * class - {string} 返回style的class
     */
    getClasses: function() {
        return this.map.getClasses();
    },

    /**
     * Method: resize
     * 根据容器的大小来调整地图
     */
    resize:function(){
        this.map.resize();
    },

    /**
     * Method: isloaded
     * 判断地图是否加载完全
     *
     * returns:
     * load - {boolean} 地图是否加载完全.
     */
    isloaded: function (){
        return this.map.loaded();
    },

    /**
     * Method: getCenter
     * 获取地图中心点坐标
     *
     * returns；
     * LngLat - {LngLat} 地图中心点坐标
     */
    getCenter:function(){
        return this.map.getCenter();
    },

    /**
     * Method: setCenter
     * 改变地图中心点坐标.
     *
     * Parameters：
     * center - {LngLatLike} 中心点坐标.
     *
     */
    setCenter:function(center, eventData){
        this.map.setCenter(center, eventData);
    },

    /**
     * Method: getLight
     * 获取亮度属性.
     *
     * returns:
     * light - {object} 返回style中亮度属性.
     */
    getLight:function(){
        return this.map.getLight();

    },

    /**
     * Method: setLight
     * 设置亮度属性的组合.
     *
     * Parameters:
     * options - {object} 亮度属性.
     */
    setLight: function(lightOptions) {
        this.map.setLight(lightOptions);
    },

    /**
     * Method: remove
     * 移除所有对象.
     *
     */
    remove: function() {

        this.map.remove();
    },

    /**
     * Method: panBy
     * 平移指定像素
     *
     * Parameters:
     * dx - {int} x轴向增量.
     * dy - {int} y轴向增量.
     */
    panBy:function(offset, options, eventData){
        this.map.panBy(offset, options, eventData);
    },

    /**
     * Method: panTo
     * 平移到指定地理坐标
     *
     * Parameters；
     * lnglat - {GeoGlobe.LngLat} 地理坐标
     */
    panTo:function(lnglat, options, eventData){
        this.map.panTo(lnglat, options, eventData);
    },

    /**
     * Method: getZoom
     * 获取地图当前级别
     *
     * returns：
     * zoom - {int} 地图当前级别
     */
    getZoom:function(){
        return this.map.getZoom();
    },

    /**
     * Method: setZoom
     * 设置地图到指定级别
     *
     * Parameters：
     * zoom - {int} 缩放到指定级别
     */
    setZoom:function(zoom, eventData){
        this.map.setZoom(zoom, eventData);
    },

    /**
     * Method: zoomTo
     * 缩放到指定地图级别
     *
     * Parameters::
     * zoom：{int} 缩放到指定级别
     */
    zoomTo:function(zoom, options, eventData){
        this.map.zoomTo(zoom, options, eventData);
    },

    /**
     * Method: zoomIn
     * 放大地图级别一级
     *
     */
    ZoomIn:function(options, eventData){
        this.map.zoomIn(options, eventData);
    },

    /**
     * Method: zoomOut
     * 缩小地图级别一级
     *
     */
    ZoomOut:function(options, eventData){
        this.map.zoomOut(options, eventData);
    },

    /**
     * Method: getBearing
     * 获取当前地图旋转程度
     *
     * returns：
     * bearing - {int} 地图旋转程度
     */
    getBearing:function(){
        return this.map.getBearing();
    },

    /**
     * Method: setBearing
     * 设置地图旋转程度
     *
     * Parameters：
     * bearing - {int} 旋转程度
     */
    setBearing:function(bearing, eventData){
        this.map.setBearing(bearing, eventData);
    },

    /**
     * Method: rotateTo
     * 旋转到指定程度
     *
     * Parameters：
     * bearing - {int} 旋转程度`
     */
    rotateTo:function(bearing, options, eventData){
        this.map.rotateTo(bearing, options, eventData);
    },

    /**
     * Method: getPitch
     * 获取当前地图的倾斜程度
     *
     * returns：
     * pitch - {int} 倾斜程度
     */
    getPitch:function(){
        return this.map.getPitch();
    },

    /**
     * Method: setPitch
     * 设置地图倾斜程度
     *
     * Parameters：
     * pitch - {int} 倾斜程度
     */
    setPitch:function(pitch, eventData){
        this.map.setPitch(pitch, eventData);
    },

    /**
     * Method: fitBounds
     * 平移和缩放地图到适合的范围.
     *
     * Parameters：
     * bounds - {GeoGlobe.LngLatbounds} 适合的范围
     */
    fitBounds:function(bounds, options, eventData){
        this.map.fitBounds(bounds, options, eventData);
    },

    /**
     * Method: resetNorth
     * 旋转地图的方位（北）（动画过渡）
     *
     */
    resetNorth: function(options, eventData) {
        this.map.resetNorth(options, eventData);
    },

    /**
     * Method: snapToNorth
     * 把地图的轴承为正北
     *
     */
    snapToNorth: function(options, eventData) {
        this.map.snapToNorth(options, eventData);
    },

    /**
     * Method: getContainer
     * 获取地图容器的html元素
     *
     * returns：
     * container - {HTMLElement} 地图容器.
     */
    getContainer:function(){
        return this.map.getContainer();
    },

    /**
     * Method: getCanvasContainer
     * 获取地图容器的html元素
     *
     * returns：
     * container - {HTMLElement} 地图容器中画布元素.
     */
    getCanvasContainer: function() {
        return this.map.getCanvasContainer();
    },

    /**
     * Method: getCanvas
     * 获取画布元素
     *
     * returns：
     * canvas - {HTMLElement} 画布元素.
     */
    getCanvas: function() {
        return this.map.getCanvas();
    },

    /**
     * Method: jumpTo
     * 无过渡的改变地图属性
     *
     * Parameters：
     * options -  {object} 中心点、缩放、旋转、倾斜等
     */
    jumpTo:function(options, eventData){
        this.map.jumpTo(options, eventData);
    },

    /**
     * Method: easeTo
     * 有过渡的改变地图属性
     *
     * Parameters：
     * options -  {object} 中心点、缩放、旋转、倾斜等
     */
    easeTo:function(options, eventData){
        this.map.easeTo(options, eventData);
    },

    /**
     * Method: flyTo
     * 飞行改变地图属性
     *
     * Parameters：
     * options -  {object} 中心点、缩放、旋转、倾斜等
     */
    flyTo:function(options, eventData){
        this.map.flyTo(options, eventData);
    },

    /**
     * Method: isMoving
     * 判断镜头是否移动
     *
     * returns：
     * Boolean - 镜头是否移动
     *
     */
    isMoving:function(){
        this.map.stop();
    },

    /**
     * Method: stop
     * 停止任何动画过渡
     *
     */
    stop:function(){
        this.map.stop();
    },

    /**
     * Method: SpatialReference
     * 获取坐标参考。
     */
    SpatialReference:function(){
        var SpatialReference = null;
        if (this.baseLayer != null) {
            SpatialReference = this.SpatialReference;
        }
        return SpatialReference ? SpatialReference.getCode() : null;
    },

    CLASS_NAME: "GeoGlobe.Map"
});

/**
 * APIMethod: addCanvasLayer
 * 添加canvas图层
 */
mapboxgl.FreeCRSMap.prototype.addCanvasLayer = function(canvaslayer){
    canvaslayer.addTo(this);
};

/**
 * APIMethod: removeCanvasLayer
 * 移除canvas图层
 */
mapboxgl.FreeCRSMap.prototype.removeCanvasLayer = function(canvaslayer){
    canvaslayer.remove();
};

/**
 * APIMethod: setIs3DPZoom
 * 判断是否倾斜
 */
mapboxgl.FreeCRSMap.prototype.setIs3DPZoom = function(is3Dpitching){
    if(is3Dpitching){
        //this.setZoompitch = GeoGlobe.Function.bind(this.setZoompitch, this);
        this.on('zoom', this.setZoompitch);
    }else{
        this.off('zoom', this.setZoompitch);
    }
};
/**
 * APIMethod: set3Dzoom
 * 设置倾斜的层级,层级在zoom和zoom+1之间的情况下，都会自动倾斜
 */
mapboxgl.FreeCRSMap.prototype.set3Dzoom = function(zoom){
    if(zoom){
        this.pitch3Dzoom = zoom;
    }
};
/**
 * APIMethod: setZoompitch
 * 设置地图倾斜
 */
mapboxgl.FreeCRSMap.prototype.setZoompitch = function(){
    var currentzoom = this.getZoom();
    var zoom = this.pitch3Dzoom;

    if(parseInt(currentzoom) == zoom){
        this.setPitch(60);
    }
};
/**
 * APIMethod: addLayers
 * 添加多个图层
 */
mapboxgl.FreeCRSMap.prototype.addLayers = function(layers){
    if(layers.length > 0){
        for(var i = 0; i < layers.length;i++){
            this.addLayer(layers[i]);
        }
    }
};

/**
 * APIMethod: getResolutions
 * 获取地图分辨率
 */
mapboxgl.FreeCRSMap.prototype.getResolutions = function(){
    var resolutions = new Array();
    for (var i = 0; i <= 20; i++) {
        resolutions.push(this.getResolutionForLevel(i));
    }
    return resolutions;
};

/**
 * APIMethod: getResolutionForLevel
 * 根据层级获取分辨率
 */
mapboxgl.FreeCRSMap.prototype.getResolutionForLevel = function(level, tileSize){
    var topTileWidth = Math.abs(this._tileExtent[2] - this._tileExtent[0]);//360
    var tileSize = tileSize ? tileSize : 256;//256
    var maxResolution = topTileWidth / tileSize; //(360 / 256);
    return maxResolution / Math.pow(2, level);
};

/**
 * APIMethod: setIsConstrain
 * 设置地图是否在地图边界以内拖动
 */
mapboxgl.FreeCRSMap.prototype.setIsConstrain = function(isConstrain){
    this.isConstrain = isConstrain;
    this.transform._constraining = !this.isConstrain;
};
/**
 * APIMethod: addLayer
 * 添加图层
 */
mapboxgl.FreeCRSMap.prototype.addLayer = function(layer, before){
    if(layer.CLASS_NAME === "GeoGlobe.Layer.VTS" || layer.layerType ==="VTS"){
        var vtsLayer = layer;

        var layers = vtsLayer.layers;
        this.addSource(vtsLayer.source_id, vtsLayer.source);
        if(layers.length > 0){
            for(var i = 0; i < layers.length;i++){
                this.addLayer(layers[i]);
            }
        }
        return this;
    }

    if(layer.layerOption && layer.layerOption.metadata.type === "wms" && layer.layerOption.metadata.isTile === false ){
        layer.addTo(this);

        this.style.addLayer(layer.layerOption, before);
        this._update(true);
        return this;
    }
    if(layer.layerOption && layer.layerOption.metadata.type === "hotarea"){
        layer.addTo(this);
        return this;
    }

    if (typeof layer.source === 'object') {
        if(this._mapCRS && layer.source && layer.source.type == "geojson" && layer.source.data && !layer.source.data.customprj){
            layer.source.data.customprj = this._geojson_customprj;
        }
    }

    this.style.addLayer(layer, before);
    this._update(true);
    return this;
};

/**
 * APIMethod: removeLayerAndSource
 * 删除layer的同时删除与layerid一致的source
 */
mapboxgl.FreeCRSMap.prototype.removeLayerAndSource = function(layerid){
    if(this.getLayer(layerid)){
        this.removeLayer(layerid);
        this.removeSource(layerid);
    }else{
        throw new Error("Layer not found");
    }
};

/**
 * APIMethod: loadSprite
 * 加载sprite文件
 *
 * Parameters：
 * sprite - {String} 路径
 * imgPrefix - {String} 可选。sprite内小图片名称的前缀
 */
mapboxgl.FreeCRSMap.prototype.loadSprite = function(sprite, imgPrefix){
    this.style._loadSprite(sprite, imgPrefix);
};

/**
 * APIMethod: removeAllImages
 * 删除所有的图片符号
 *
 */
mapboxgl.FreeCRSMap.prototype.removeAllImages = function(){
    var imageManager = this.style.imageManager;
    for(var key in imageManager.images){
        imageManager.removeImage(key);
    }
};

/**
 * APIMethod: removeAllLayers
 * 删除所有的图层
 *
 */
mapboxgl.FreeCRSMap.prototype.removeAllLayers = function(){
    var layers = this.style._layers;
    for(var key in layers){
        this.removeLayer(key);
    }
};

/**
 * APIMethod: removeAllSources
 * 删除所有的source
 *
 */
mapboxgl.FreeCRSMap.prototype.removeAllSources = function(){
    var sourceCaches = this.style.sourceCaches;
    for(var key in sourceCaches){
        this.removeSource(key);
    }
};/**
 * Class: GeoGlobe.LngLatBounds
 * LngLatBounds是以西南和东北点的经度和纬度，来表示的地理边界。
 *
 * Inherits from:
 *  - <GeoGlobe.LngLatBounds>
 */
GeoGlobe.LngLatBounds = GeoGlobe.Class(mapboxgl.LngLatBounds,{

    /**
     * Property: sw
     * {object} 西南边界。
     */
    sw: null,

    /**
     * Property: ne
     * {object} 东北边界。
     */
    ne: null,

    /**
     * Constructor: GeoGlobe.LngLatBounds
     * GeoGlobe.LngLatBounds构造函数。
     *
     * Parameters:
     * options - {Object} LngLatBounds相关选项设置。
     *
     * Examples:
     * var sw = new GeoGlobe.LngLat(-73.9876, 40.7661);
     * var ne = new GeoGlobe.LngLat(-73.9397, 40.8002);
     * var llb = new GeoGlobe.LngLatBounds(sw, ne);
     *
     */

    initialize: function(sw,ne){
        this.LngLatBounds = new mapboxgl.LngLatBounds(sw,ne);
        return this.LngLatBounds;
    },

    /**
     * Method: convert
     * 将两个坐标的数组转换为LngLatBounds对象返回。
     *
     * Parameters:
     * arr - {array} 数组坐标。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 数组转成的坐标对象.
     *
     * Examples:
     * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
     * var llb = GeoGlobe.LngLatBounds.convert(arr);
     * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
     *
     */
    convert:function(arr){
        return this.LngLatBounds.convert(arr);
    },

    /**
     * Method: setNorthEast
     * 设置西南边界。
     *
     * Parameters:
     * ne - {array} 西南边界坐标。
     *
     */
    setNorthEast:function(ne){
        this.LngLatBounds.setNorthEast(ne);
    },

    /**
     * Method: setNorthEast
     * 设置东北边界。
     *
     * Parameters:
     * sw - {array} 东北边界。
     *
     */
    setSouthWest:function(sw){
        this.LngLatBounds.setSouthWest(sw);
    },

    /**
     * Method: extend
     * 扩展到指定范围。
     *
     * Parameters:
     * obj - {GeoGlobe.LngLatBounds} 指定范围。
     *
     */
    extend:function(obj){
        this.LngLatBounds.extend(obj);
    },

    /**
     * Method: getCenter
     * 返回边界框地理坐标。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 边界框地理坐标
     *
     * Examples:
     * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
     *
     */
    getCenter:function(){
        return this.LngLatBounds.getCenter();
    },

    /**
     * Method: getSouthWest
     * 返回边界的西南角。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 边界的西南角
     *
     */
    getSouthWest:function(){
        return this.LngLatBounds.getSouthWest();
    },

    /**
     * Method: getNorthEast
     * 返回边界的东北角。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 边界的东北角
     *
     */
    getNorthEast:function(){
        return this.LngLatBounds.getNorthEast();
    },

    /**
     * Method: getNorthWest
     * 返回边界的西北角。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 边界的西北角
     *
     */
    getNorthWest:function(){
        return this.LngLatBounds.getNorthWest();
    },

    /**
     * Method: getSouthEast
     * 返回边界的东南角。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 边界的东南角
     *
     */
    getSouthEast:function(){
        return this.LngLatBounds.getSouthEast();
    },

    /**
     * Method: getWest
     * 返回西边界的边缘。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 西边界的边缘
     *
     */
    getWest:function(){
        return this.LngLat.getWest();
    },

    /**
     * Method: getEast
     * 返回东边界的边缘。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 东边界的边缘
     *
     */
    getEast:function(){
        return this.LngLatBounds.getEast();
    },

    /**
     * Method: getSouth
     * 返回南边界的边缘。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 南边界的边缘
     *
     */
    getSouth:function(){
        return this.LngLatBounds.getSouth();
    },

    /**
     * Method: getNorth
     * 返回北边界的边缘。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 返回北边界的边缘
     *
     */
    getNorth:function(){
        return this.LngLatBounds.getNorth();
    },

    /**
     * Method: toArray
     * 返回边界的一个数组。
     *
     * returns:
     * array - {array} 边界的一个数组
     *
     * Examples:
     * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
     *
     */
    toArray:function(){
        return this.LngLatBounds.toArray();
    },

    /**
     * Method: toString
     * 返回边界为字符串。
     *
     * returns:
     * string - {string} 边界为字符串
     *
     * Examples:
     * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     *  llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
     *
     */
    toString:function(){
        return this.LngLat.toString();
    },
	
	/**
     * Method: equals
     * Test a two bounds for equivalence.
     *
     * Parameters:
     * bounds - {<GeoGlobe.LngLatBounds>}
     *
     * Returns:
     * {Boolean} The passed-in bounds object has the same left,
     *           right, top, bottom components as this.  Note that if bounds 
     *           passed in is null, returns false.
     */
    equals:function(bounds) {
		//用原型对象来扩展接口
    },
	
    /**
     * APIMethod: getWidth
     * Returns the width of the bounds.
     * 
     * Returns:
     * {Float} The width of the bounds (right minus left).
     */
    getWidth: function() {
        //用原型对象来扩展接口
    },
	
	/**
     * APIMethod: containsLonLat
     * Returns whether the bounds object contains the given <GeoGlobe.LngLat>.
     * 
     * Parameters:
     * ll - {<GeoGlobe.LngLat>|Object} GeoGlobe.LngLat or an
     *     object with a 'lon' and 'lat' properties.
     * options - {Object} Optional parameters
     *
     * Acceptable options:
     * inclusive - {Boolean} Whether or not to include the border.
     *     Default is true.
     * worldBounds - {<GeoGlobe.LngLatBounds>} If a worldBounds is provided, the
     *     ll will be considered as contained if it exceeds the world bounds,
     *     but can be wrapped around the dateline so it is contained by this
     *     bounds.
     *
     * Returns:
     * {Boolean} The passed-in lonlat is within this bounds.
     */
    containsLonLat: function(ll, options) {
        //用原型对象来扩展接口
    },
	
	/**
     * APIMethod: contains
     * Returns whether the bounds object contains the given x and y.
     * 
     * Parameters:
     * x - {Float}
     * y - {Float}
     * inclusive - {Boolean} Whether or not to include the border. Default is
     *     true.
     *
     * Returns:
     * {Boolean} Whether or not the passed-in coordinates are within this
     *     bounds.
     */
    contains: function(x, y, inclusive) {
		//用原型对象来扩展接口
    },
	
	/**
     * Method: clone
     * Create a cloned instance of this bounds.
     *
     * Returns:
     * {<GeoGlobe.LngLatBounds>} A fresh copy of the bounds
     */
    clone: function(){
        //return new OpenLayers.Bounds(this.left, this.bottom, this.right, this.top);
        //用原型对象来扩展接口
    },
    
    /** 
     * APIMethod: toBBOX
     * 生成一个描述范围的字符串。
     * 
     * Parameters:
     * decimal - {Integer} 小数点的精度，默认精确到小数点后6位。
     * reverseAxisOrder - {Boolean} 是否需要反转坐标。
     * 
     * Returns:
     * {String} 范围字符串(e.g. "5,42,10,45")
     */
    toBBOX: function(decimal, reverseAxisOrder) {
    	//用原型对象来扩展接口
    },
    
    /**
     * APIMethod: toGeometry
     * 基于这个范围对象创建一个新的几何面。
     *
     * Returns:
     * {<GeoGlobe.Geometry.Polygon>} 新的几何面。
     */
    toGeometry: function() {
    	//用原型对象来扩展接口
    },
	
	/**
     * APIMethod: getCenterLonLat
     * 返回范围的中心点对象。
     *
     * Returns:
     * {<GeoGlobe.LngLat>} 范围的中心点。
     */
    getCenterLonLat:function() {
        //用原型对象来扩展接口
    },

    CLASS_NAME: "GeoGlobe.LngLatBounds"
});

//因为GeoGlobe.Class此方法存在问题，造成类定义的接口无法调用，
//现在临时使用原型对象来扩展接口，达到外部可以调用的效果。
mapboxgl.LngLatBounds.prototype.clone = function(){
	return new mapboxgl.LngLatBounds(this._sw, this._ne);
};

mapboxgl.LngLatBounds.prototype.contains = function(x, y, inclusive){
	//set default
    if (inclusive == null) {
        inclusive = true;
    }

    if (x == null || y == null) {
        return false;
    }

    x = GeoGlobe.Util.toFloat(x);
    y = GeoGlobe.Util.toFloat(y);

    var contains = false;
    if (inclusive) {
        contains = ((x >= this._sw.lng) && (x <= this._ne.lng) && 
                    (y >= this._sw.lat) && (y <= this._ne.lat));
    } else {
        contains = ((x > this._sw.lng) && (x < this._ne.lng) && 
                    (y > this._sw.lat) && (y < this._ne.lat));
    }              
    return contains;
};

mapboxgl.LngLatBounds.prototype.getWidth = function(){
	return (this._ne.lng - this._sw.lng);
};

mapboxgl.LngLatBounds.prototype.containsLonLat = function(ll, options){
	if (typeof options === "boolean") {
        options =  {inclusive: options};
    }
    options = options || {};
    var contains = this.contains(ll.lng, ll.lat, options.inclusive),
        worldBounds = options.worldBounds;
    if (worldBounds && !contains) {
        var worldWidth = worldBounds.getWidth();
        var worldCenterX = (worldBounds._sw.lng + worldBounds._ne.lng) / 2;
        var worldsAway = Math.round((ll.lng - worldCenterX) / worldWidth);
        contains = this.containsLonLat({
            lng: ll.lng - worldsAway * worldWidth,
            lat: ll.lat
        }, {inclusive: options.inclusive});
    }
    return contains;
};

mapboxgl.LngLatBounds.prototype.equals = function(bounds){
	var equals = false;
    if (bounds != null) {
		/*
        equals = ((this.left == bounds.left) && 
                  (this.right == bounds.right) &&
                  (this.top == bounds.top) && 
                  (this.bottom == bounds.bottom));
                  */
        equals = ((this._sw.lng == bounds._sw.lng) && 
                  (this._ne.lng == bounds._ne.lng) &&
                  (this._ne.lat == bounds._ne.lat) && 
                  (this._sw.lat == bounds._sw.lat));
    }
    return equals;
};

mapboxgl.LngLatBounds.prototype.toBBOX = function(decimal, reverseAxisOrder){
	if (decimal== null) {
        decimal = 6; 
    }
    var mult = Math.pow(10, decimal);
    var xmin = Math.round(this._sw.lng * mult) / mult;
    var ymin = Math.round(this._sw.lat * mult) / mult;
    var xmax = Math.round(this._ne.lng * mult) / mult;
    var ymax = Math.round(this._ne.lat * mult) / mult;
    if (reverseAxisOrder === true) {
        return ymin + "," + xmin + "," + ymax + "," + xmax;
    } else {
        return xmin + "," + ymin + "," + xmax + "," + ymax;
    }
};

mapboxgl.LngLatBounds.prototype.toGeometry = function() {
    return new GeoGlobe.Geometry.Polygon([
        new GeoGlobe.Geometry.LinearRing([
            new GeoGlobe.Geometry.Point(this._sw.lng, this._sw.lat),
            new GeoGlobe.Geometry.Point(this._ne.lng, this._sw.lat),
            new GeoGlobe.Geometry.Point(this._ne.lng, this._ne.lat),
            new GeoGlobe.Geometry.Point(this._sw.lng, this._ne.lat)
        ])
    ]);
};

mapboxgl.LngLatBounds.prototype.getCenterLonLat = function() {
	if(!this.centerLonLat) {
        this.centerLonLat = new GeoGlobe.LngLat(
            (this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2
        );
    }
    return this.centerLonLat;
};

mapboxgl.LngLatBounds.prototype.CLASS_NAME = "GeoGlobe.LngLatBounds";



/** 
 * APIFunction: fromString
 * 从以逗号分隔的bbox字符串创建GeoGlobe.LngLatBounds对象实例。
 *
 * (begin code)
 * GeoGlobe.LngLatBounds.fromString("5,42,10,45");
 * // => equivalent to ...
 * new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(5,42), new GeoGlobe.LngLat(10,45));
 * (end)
 *
 * Parameters: 
 * str - {String} Comma-separated bounds string. (e.g. "5,42,10,45")
 * reverseAxisOrder - {Boolean} Does the string use reverse axis order?
 *
 * Returns:
 * {<GeoGlobe.LngLatBounds>} New bounds object built from the 
 *                       passed-in String.
 */
GeoGlobe.LngLatBounds.fromString = function(str, reverseAxisOrder) {
    var bounds = str.split(",");
    return GeoGlobe.LngLatBounds.fromArray(bounds, reverseAxisOrder);
};

/** 
 * APIFunction: fromArray
 * Alternative constructor that builds a new GeoGlobe.LngLatBounds from an array.
 *
 * (begin code)
 * GeoGlobe.LngLatBounds.fromArray( [5, 42, 10, 45] );
 * // => equivalent to ...
 * new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(5,42), new GeoGlobe.LngLat(10,45));
 * (end)
 *
 * Parameters:
 * bbox - {Array(Float)} Array of bounds values (e.g. [5,42,10,45])
 * reverseAxisOrder - {Boolean} Does the array use reverse axis order?
 *
 * Returns:
 * {<GeoGlobe.LngLatBounds>} New bounds object built from the passed-in Array.
 */
GeoGlobe.LngLatBounds.fromArray = function(bbox, reverseAxisOrder) {
    return reverseAxisOrder === true ?
           //new OpenLayers.Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) :
           //new OpenLayers.Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
           new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(bbox[1],bbox[0]), new GeoGlobe.LngLat(bbox[3],bbox[2])) :
           new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(bbox[0],bbox[1]), new GeoGlobe.LngLat(bbox[2],bbox[3]));
};

/** 
 * APIFunction: toGeometryByTwoPixel
 * 根据两个屏幕坐标点，得到bounds几何对象。
 * 
 * Parameters:
 * p0 - {Array(Float)} 点1，屏幕坐标点，用数组表示(e.g. [100, 200])。类型也可是mapboxgl.Point
 * p1 - {Array(Float)} 点2，屏幕坐标点，用数组表示(e.g. [200, 400])。类型也可是mapboxgl.Point
 * map - {<GeoGlobe.Map>} 地图对象
 * 
 * Returns:
 * {<GeoGlobe.Geometry.Polygon>} 返回新的几何面对象。
 */
GeoGlobe.LngLatBounds.toGeometryByTwoPixel = function(p0, p1, map) {
	var box = [mapboxgl.Point.convert(p0), mapboxgl.Point.convert(p1)];
    var glPoints = [
        box[0],
        new mapboxgl.Point(box[1].x, box[0].y),
        box[1],
        new mapboxgl.Point(box[0].x, box[1].y)
    ];
	//屏幕坐标转经纬度坐标
	var pointGeometries = [];
	for(var i =0; i< glPoints.length; i++){
		var lnglat = map.unproject(glPoints[i]);
		var pointGeometry = new GeoGlobe.Geometry.Point(lnglat.lng, lnglat.lat);
		pointGeometries.push(pointGeometry);
	}
	//var boxPixels = [p0, [p1.x, p0.y], [p0.x, p1.y], p1];
	var polygon = new GeoGlobe.Geometry.Polygon([
        new GeoGlobe.Geometry.LinearRing(pointGeometries)
    ]);
	return polygon;
};
/**
* left, bottom, right, top
* getWest() getSouth() getEast() getNorth()
* sw,ne
*/﻿/**
 * Class: GeoGlobe.LngLat
 * 以经度和纬度表示的地理坐标点。
 *
 * Inherits from:
 *  - <GeoGlobe.LngLat>
 */
GeoGlobe.LngLat = GeoGlobe.Class(mapboxgl.LngLat,{

    /**
     * Property: lon
     * {number} 地图上的经度（X轴坐标）。
     */
    lon: null,

    /**
     * Property: lat
     * {String} 地图上的纬度（Y轴坐标）。
     */
    lat: null,

    /**
     * Constructor: GeoGlobe.LngLat
     * GeoGlobe.LngLat构造函数。
     *
     * Parameters:
     * options - {Object} LngLat相关选项设置。
     *
     * Examples:
     * var var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
     *
     */

    initialize: function(lng,lat){
        this.LngLat = new mapboxgl.LngLat(lng,lat);
        return this.LngLat;
    },

    /**
     * Method: convert
     * 将一个数组转换为坐标对象。
     *
     * Parameters:
     * arr - {array} 数组坐标。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 数组转成的坐标对象.
     *
     * Examples:
     * var arr = [-73.9749, 40.7736];
     * var ll = GeoGlobe.LngLat.convert(arr);
     * alert(ll);
     */
    convert:function(arr){
        return this.LngLat.convert(arr);
    },

    /**
     * Method: wrap
     * 返回新经纬度对象,其经度范围（-180,180）。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 新经纬度对象
     *
     * Examples:
     * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
     * var wrapped = ll.wrap();
     * wrapped.lng; // = -73.9749
     *
     */
    wrap:function(){
        return this.LngLat.wrap();
    },

    /**
     * Method: toArray
     * 返回坐标的一个数组。
     *
     * returns:
     * array - {array} 坐标的一个数组
     *
     * Examples:
     * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
     * ll.toArray(); // = [-73.9749, 40.7736]
     *
     */
    toArray:function(){
        return this.LngLat.toArray();
    },

    /**
     * Method: toString
     * 返回坐标为字符串。
     *
     * returns:
     * string - {string} 坐标为字符串
     *
     * Examples:
     * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
     * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
     *
     */
    toString:function(){
        return this.LngLat.toString();
    },

    CLASS_NAME: "GeoGlobe.LngLat"
});/**
 * Class: GeoGlobe.Layer
 * 各图层总类。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer>
 */
GeoGlobe.Layer = GeoGlobe.Class(mapboxgl.FreeCRSMap,{

    /**
     * Property: visibility
     * {Boolean} 图层是否可见。
     */
    visibility: null,

    /**
     * Property: id
     * {string} 图层标志id。
     */
    id: null,

    /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,

    /**
     * Property: alias
     * {string} 图层别名。
     */
    alias: null,

    /**
     * Property: ref
     * {string} 引用另一图层。
     */
    ref: null,

    /**
     * Property: sourceId
     * {string} 规范的数据源id。
     */
    sourceId: null,

    /**
     * Property: sourceLayerId
     * {string} 数据源中图层ID。
     */
    sourceLayerId: null,

    /**
     * Property: metadata
     * {string} 图层的任意属性。
     */
    metadata: null,

    /**
     * Property: filter
     * {Array} 图层指定的过滤条件。
     */
    filter: null,

    /**
     * Property: maxZoom
     * {int} 图层最大层级。
     */
    maxZoom: 20,

    /**
     * Property: minZoom
     * {int} 图层最小层级。
     */
    minZoom: 0,

    /**
     * Constructor: GeoGlobe.Layer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(){
        //var paint = {}
        ////var url = options.url;
        //var layer = {
        //    id:options.id,
        //    layer:{
        //        "id": options.id,
        //        "type": "raster",
        //        "source":options.id,
        //        "paint":paint
        //    },
        //    source:{
        //        "type": "raster",
        //        "tiles": options.url,
        //        "tileSize": 256
        //    }
        //};
        return this;
    },
    CLASS_NAME: "GeoGlobe.Layer"
});
﻿/**
 * Class: GeoGlobe.Layer.WMTS
 * WMTS图层类，WMTS图层类的实例是用来显示OGC网络地图服务上的瓦片数据。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer.WMTS>
 */
GeoGlobe.Layer.WMTS =  GeoGlobe.Class4OL({

    /**
     * Property: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: id
     * {string} 图层标志id。
     */
    layer: null,

    /**
     * Property: format
     * {string} 瓦片格式。
     */
    format: null,

    /**
     * Property: matrixSet
     * {string} WMTS服务矩阵标志。
     */
    matrixSet: null,

    /**
     * Property: style
     * {string} 样式标识。
     */
    style: null,

    /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,



    /**
     * Property: resolutions
     * {string} 图层分辨率。
     */
    resolutions: null,

    /**
     * Property: zoomOffset
     * {bounds} 级别偏移值。
     */
    zoomOffset: null,

    /**
     * Property: matrixIds
     * {int} 矩阵的详细信息。
     */
    matrixIds: null,

    /**
     * Property: tileOrigin
     * {Array} 瓦片原点。
     */
    tileOrigin: null,

    /**
     * Property: tileFullExtent
     * {float} 图层范围。
     */
    tileFullExtent: null,

    /**
     * Constructor: GeoGlobe.Layer.WMTS
     * GeoGlobe.Layer.WMTS构造函数。
     *
     * Parameters:
     * options - {Object} WMTS相关选项设置。
     */
    initialize: function(params){
        return this._getWMTSLayer(params);
    },

    /**
     * Method: _getWMTSLayer
     * 创建WMTS图层对象。
     *
     * returns
     * {url} 图层的url
     */
    _getWMTSLayer:function(options){
        var DEFAULT_PARAMS = {
            service: "WMTS",
            request: "GetTile"
        };
        var params = {};
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.matrixSet) {
            params.TILEMATRIXSET = options.matrixSet;
        }

        if( options.version ) {
            params.VERSION = options.version;
        }
	if( !options.zoomOffset) {
            options.zoomOffset =0;
        }
        if( options.style ) {
            params.STYLE = options.style;
        }
        params.TILEMATRIX = '{z}';

        params.TILEROW ='{y}';

        params.TILECOL = '{x}';
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(options.url,
            this.getParameterString(params || {}));
			 url = GeoGlobe.appendToProxy(url);
        var id = "wmts_" + options.layer + "_" + GeoGlobe.Util.randomStr(8);
        return {
            "id": id,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [url],
 		"zoomOffset": options.zoomOffset,//wmts Capabilities信息中TileMatrix第一个对应的实际多少级
                "tileSize": 256
            }
        }
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Function: urlAppend
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *
     * Parameters:
     * url - {String} The url to append to
     * paramStr - {String} The param string to append
     *
     * Returns:
     * {String} The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },
    /**
     * Method: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.WMTS>} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMTS(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },

    /**
     * Method: getMatrix
     * 获取矩阵。
     */
    getMatrix: function() {
        var matrix;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            matrix = {identifier: this.getIdentifier()};
        } else {
            // get appropriate matrix given the map scale if possible
            if ("scaleDenominator" in this.matrixIds[0]) {
                // scale denominator calculation based on WMTS spec
                var denom =
                    GeoGlobe.METERS_PER_INCH *
                    GeoGlobe.INCHES_PER_UNIT[this.units] *
                    this.getServerResolution() / 0.28E-3;
                var diff = Number.POSITIVE_INFINITY;
                var delta;
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));
                    if (delta < diff) {
                        diff = delta;
                        matrix = this.matrixIds[i];
                    }
                }
            } else {
                // fall back on zoom as index
                matrix = this.matrixIds[this.getIdentifier()];
            }
        }
        return matrix;
    },
    CLASS_NAME: "GeoGlobe.Layer.WMTS"
});﻿/**
 * Class: GeoGlobe.Layer.WMS
 * WMS图层类，WMS图层类的实例是用来显示OGC网络地图服务上的瓦片数据。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer.WMS>
 */
GeoGlobe.Layer.WMS =  GeoGlobe.Class4OL({

    /**
     * Property: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: id
     * {string} 图层标志id。
     */
    layer: null,

    /**
     * Property: format
     * {string} 瓦片格式。
     */
    format: null,

    /**
     * Property: version
     * {string} 服务版本号。
     */
    version: null,

    /**
     * Property: width
     * {string} 瓦片宽。
     */
    width: 256,

    /**
     * Property: height
     * {bounds} 瓦片高。
     */
    height: 256,

    /**
     * Property: SRS
     * {int} 投影类型。
     */
    SRS: null,

    /**
     * Constructor: GeoGlobe.Layer.WMS
     * GeoGlobe.Layer.WMS构造函数。
     *
     * Parameters:
     * options - {Object} WMS相关选项设置。
     */
    initialize: function(params){
        //GeoGlobe.Util.extend(this, params);
        if(params.isTile!=undefined && params.isTile === false){
            this.layerOption = this._getWMSLayer(params);
        }else{
            return this._getWMSTileLayer(params);
        }
    },

    addTo:function(map){
        this.map = map;
        //this.move = GeoGlobe.Function.bind(this.moveend,this);
        this.move = GeoGlobe.Function.bind(GeoGlobe.Util.delayFun(this.moveend, 300),this);
        this.map.on('moveend',this.move);


        this.width = map.getCanvas().width;
        this.height = map.getCanvas().height;
        var bounds = map.getBounds();
        var maxx = bounds._ne.lng;
        var maxy = bounds._ne.lat;
        var minx = bounds._sw.lng;
        var miny = bounds._sw.lat;
        var bbox = minx + "," + miny + "," + maxx + "," + maxy;
        //var url =layer.url ;
        this.layerOption.source.url = this.layerOption.source.url
            .replace('{bbox}', bbox)
            .replace('{width}', this.width)
            .replace('{height}', this.height);
        var coordinates= [
            [minx, maxy],
            [maxx, maxy],
            [maxx, miny],
            [minx, miny]];
        this.layerOption.source.coordinates =coordinates;
    },

    /**
     * Method: _getWMSLayer
     * 创建WMS图层对象。
     *
     * returns
     * {url} 图层的信息
     */
    _getWMSLayer:function(options){
     
        if(options.transparent || options.transparent === false ) {
             this.options.transparent = options.transparent;
        }else{
            options.transparent = true;
        }
        this.options = options;
        this.url = options.url;
        var param = this.getParamString({
            "SERVICE": "WMS",
            "REQUEST": "GetMap",
            "VERSION": options.version,
            "LAYERS": options.layer,
            "styles":options.styles,
            "FORMAT": options.format,
            "TRANSPARENT":options.transparent,
            "BBOX": '{bbox}',
            "WIDTH": '{width}',
            "HEIGHT": '{height}',
            "SRS":options.SRS
        });

        var wms_url ="";
        if(this.url.endsWith("?")){
            wms_url = this.url + param;
        }else{
            wms_url = this.url + "?" + param;
        }
        wms_url = GeoGlobe.appendToProxy(wms_url);
        var randomNum = GeoGlobe.Util.randomStr(10);

        //扩展图层的字段
        var metadata = {
            "name": options.layer,
            "srs": options.SRS,
            "type": "wms",
            "isTile": options.isTile,
            "format":options.formats
        };
        this.id = "layer_" + options.layer + "_" + randomNum;
        var layerOption = {
            "id": this.id,
            "source": {
                "type": "image",
                "url": wms_url,
                "coordinates": [
                ]
            },
            "metadata":metadata,
            "type": "raster"
        };

        return layerOption;
    },

    /**
     * Method: _getWMSTileLayer
     * 创建WMS图层对象。
     *
     * returns
     * {url} 图层的信息
     */
    _getWMSTileLayer:function(options){
        var DEFAULT_PARAMS = {
            service: "WMS",
            request: "GetMap"
            //TRANSPARENT: true
        };
        var params = {};
        if( options.layer ) {
            params.LAYERS = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.transparent || options.transparent === false ) {
            params.TRANSPARENT = options.transparent;
        }else{
            params.TRANSPARENT = true;
        }
        if( options.styles ) {
            params.styles = options.styles;
        }
            if(options.tileSize ) {
            params.HEIGHT = options.tileSize;
             params.WIDTH = options.tileSize;
        }else{
            options.tileSize = 256;
            params.HEIGHT = options.tileSize;
            params.WIDTH = options.tileSize;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.SRS ) {
            params.SRS = options.SRS;
        }
        params.BBOX = '{bbox-epsg-3857}';
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        //扩展图层的字段
        var metadata = {
            "name": options.layer,
            "srs": options.SRS,
            "bbox": options.bbox,
            "format":options.format
        }
        //wms_url = GeoGlobe.appendToProxy(wms_url);
        var id = "wms_" + options.layer + "_" + GeoGlobe.Util.randomStr(8);
        var url =  this.urlAppend(options.url,
                this.getParameterString(params || {}));
        url = GeoGlobe.appendToProxy(url);
        return {
            "id": id,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [url],
                "tileSize": options.tileSize
            },
            "metadata":metadata
        }
    },

    moveend:function(){
        if(this.map.style._layers[this.id] && this.map.style._layers[this.id].layout["visibility"] != "none"){
            var metadata = this.map.style._layers[this.id].metadata;
            var paint = this.map.style._layers[this.id].paint;
            //this.map.removeLayer(this.id);
            //this.map.removeSource(this.id);
            box = this.map.getBounds();
            var maxx = box._ne.lng;
            var maxy = box._ne.lat;
            var minx = box._sw.lng;
            var miny = box._sw.lat;
            var box = minx + "," + miny + "," + maxx + "," + maxy;
			 this.width = this.map.getCanvas().width;
            this.height = this.map.getCanvas().height;
            var param = this.getParameterString({
                "SERVICE": "WMS",
                "REQUEST": "GetMap",
                "VERSION": this.options.version,
                "LAYERS": this.options.layer,
                "styles":this.options.styles,
                "FORMAT": this.options.format,
                "TRANSPARENT":this.options.transparent,
                "BBOX": box,
                "WIDTH": this.width,
                "HEIGHT": this.height,
                "SRS":this.options.SRS
            });
            var wms_url ="";
            if(this.url.endsWith("?")){
                wms_url = this.url + param;
            }else{
                wms_url = this.url + "?" + param;
            }
            wms_url = GeoGlobe.appendToProxy(wms_url);
                   var coordinates= [
                        [minx, maxy],
                        [maxx, maxy],
                        [maxx, miny],
                        [minx, miny]];

            var source = this.map.getSource(this.id);
            source.url = wms_url;
            source.options.url = wms_url;
            source.coordinates = coordinates;
            source.options.coordinates = coordinates;
            source.load();
            //this.map.addLayer(layer);
        }
    },
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Function: urlAppend
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *
     * Parameters:
     * url - {String} The url to append to
     * paramStr - {String} The param string to append
     *
     * Returns:
     * {String} The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },
    /**
     * Method: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.WMS>} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMS(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },
    getParamString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },
    CLASS_NAME: "GeoGlobe.Layer.WMS"
});﻿/**
 * Class: GeoGlobe.Layer.VTS
 * VTS图层类，VTS图层类的实例是用来显示OGC网络地图服务上的矢量瓦片数据。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer.VTS>
 */
GeoGlobe.Layer.VTS =  GeoGlobe.Class4OL({

    /**
     * Property: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: id
     * {string} 图层标志id。
     */
    layer: null,

    /**
     * Property: format
     * {string} 瓦片格式。
     */
    format: null,

    /**
     * Property: matrixSet
     * {string} VTS服务矩阵标志。
     */
    matrixSet: null,

    /**
     * Property: style
     * {string} 样式标识。
     */
    style: null,

    /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,



    /**
     * Property: resolutions
     * {string} 图层分辨率。
     */
    resolutions: null,

    /**
     * Property: zoomOffset
     * {bounds} 级别偏移值。
     */
    zoomOffset: null,

    /**
     * Property: matrixIds
     * {int} 矩阵的详细信息。
     */
    matrixIds: null,

    /**
     * Property: tileOrigin
     * {Array} 瓦片原点。
     */
    tileOrigin: null,

    /**
     * Property: tileFullExtent
     * {float} 图层范围。
     */
    tileFullExtent: null,

    /**
     * Constructor: GeoGlobe.Layer.VTS
     * GeoGlobe.Layer.VTS构造函数。
     *
     * Parameters:
     * options - {Object} VTS相关选项设置。
     */
    initialize: function(params){
        this.source_id = "source_vts_"+GeoGlobe.Util.randomStr(6);
        this.layers = this._getVTSLayer(params);
        this.source = {
            "type":"vector",
            "tiles":[this.url_tmpl]
        };
    },

    /**
     * Method: _getVTSLayer
     * 创建VTS图层对象。
     *
     * returns
     * {url} 图层的url
     */
    _getVTSLayer:function(options){
        var DEFAULT_PARAMS = {
            service: "WMTS",
            request: "GetTile"
        };
        this.url = options.url;
        var params = {};
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.matrixSet) {
            params.TILEMATRIXSET = options.matrixSet;
        }

        if(options.version) {
            params.VERSION = options.version;
        }
        //if(options.tileBBox) {
            //params.tileBBox = options.tileBBox;
        //}
        //if(options.minZoom !== undefined) {
            //params.minZoom = options.minZoom;
        //}
        //if(options.maxZoom !== undefined) {
            //params.maxZoom = options.maxZoom;
        //}
        if(options.tileSize) {
            params.WIDTH = options.tileSize;
            params.HEIGHT = options.tileSize;
        }

        params.TILEMATRIX = '{z}';

        params.TILEROW ='{y}';

        params.TILECOL = '{x}';
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = GeoGlobe.ProxyHost  + this.urlAppend(options.url,
                this.getParameterString(params || {}));
        //var style = this.GetStyle()
        this.url_tmpl = url;
        var source_id = "source_vts_"+GeoGlobe.Util.randomStr(6);
        this.source_id = source_id;
        var Layer_data = [];
        this.GetStyle(options.styleName, function(result){
                if(result.sprite){
                    var sprite = GeoGlobe.ProxyHost+result.sprite;
                }else{
                    var sprite = "";
                }

                if(result.glyphs){
                    var glyphs = GeoGlobe.ProxyHost+result.glyphs;
                }else{
                    var glyphs = "";
                }
                var metadata = {
                    "sprite":sprite,
                    "glyphs":glyphs,
                    "styleName":result.name,
                    "layerIdentifier": params.LAYER,
                    "matrixSet": params.TILEMATRIXSET,
                    "format": params.FORMAT,
                    "bbox": options.tileBBox ? options.tileBBox : "",
                    "minZoom": options.minZoom ? options.minZoom : "",
                    "maxZoom": options.maxZoom ? options.maxZoom : ""
                };
                if(result.styleData){
                    for(var i=0;i<result.styleData.layers.length;i++){
                        result.styleData.layers[i].metadata = metadata;
                        result.styleData.layers[i].source = source_id;
                        /*{
                         "type": "vector",
                         "tiles": [url]
                         };*/
                        Layer_data[i] =  result.styleData.layers[i];
                    }
                }else{
                    for(var i=0;i<result.layers.length;i++){
                        result.layers[i].source = source_id;
                        /*{
                         "type": "vector",
                         "tiles": [url]
                         };*/
                        result.layers[i].metadata = metadata;
                        Layer_data[i] =  result.layers[i];
                    }
                }

            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });

        return Layer_data;
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Function: urlAppend
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *
     * Parameters:
     * url - {String} The url to append to
     * paramStr - {String} The param string to append
     *
     * Returns:
     * {String} The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    /**
     * APIMethod: GetStyle
     * 获取基于MapboxGL样式数据（用json描述）。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    GetStyle: function(styleName,successFn, failFn){
        var url = this.url;
        if(styleName =="" || styleName == undefined){
            alert("请查看样式名称是否存在");
            return ;
        }
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0",
            STYLENAME:styleName
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var style = jformat.read(obj);
                //var style = geojson.style[0];
                successFn(style);
            },
            failure: failFn
        });
    },

    /**
     * Method: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.VTS>} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.VTS(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },

    /**
     * Method: getMatrix
     * 获取矩阵。
     */
    getMatrix: function() {
        var matrix;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            matrix = {identifier: this.getIdentifier()};
        } else {
            // get appropriate matrix given the map scale if possible
            if ("scaleDenominator" in this.matrixIds[0]) {
                // scale denominator calculation based on VTS spec
                var denom =
                    GeoGlobe.METERS_PER_INCH *
                    GeoGlobe.INCHES_PER_UNIT[this.units] *
                    this.getServerResolution() / 0.28E-3;
                var diff = Number.POSITIVE_INFINITY;
                var delta;
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));
                    if (delta < diff) {
                        diff = delta;
                        matrix = this.matrixIds[i];
                    }
                }
            } else {
                // fall back on zoom as index
                matrix = this.matrixIds[this.getIdentifier()];
            }
        }
        return matrix;
    },
    CLASS_NAME: "GeoGlobe.Layer.VTS"
});﻿/**
 * Class: GeoGlobe.Layer.WMS_
 * WMS图层类，WMS图层类的实例是用来显示OGC网络地图服务上的数据。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer.WMS_>
 */
GeoGlobe.Layer.WMS_ = GeoGlobe.Class(GeoGlobe.Layer,{
    /**
     * Property: id
     * {string} 图层标志id。
     */
    id: null,

    /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,

    /**
     * Property: tileSize
     * {int} 瓦片大小。
     */
    tileSize: 256,

    /**
     * APIProperty: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: filter
     * {Array} 图层指定的过滤条件。
     */
    filter: null,

    /**
     * Property: opacity
     * {float} 图层的透明度。
     */
    opacity: 0,

    /**
     * Property: visible
     * {Boolean} 是否可见。
     */
    visible: true,

    /**
     * Property: maxZoom
     * {int} 图层最大层级。
     */
    maxZoom: 20,

    /**
     * Property: minZoom
     * {int} 图层最小层级。
     */
    minZoom: 0,

    /**
     * Constructor: GeoGlobe.Layer.WMS_
     * GeoGlobe.Layer.WMS_构造函数。
     *
     * Parameters:
     * options - {Object} WMS_相关选项设置。
     */
    initialize: function(options){
        var paint = {}
        //var url = options.url;
        var layer = {
            id:options.id,
            layer:{
                "id": options.id,
                "type": "raster",
                "source":options.id
            },
            source:{
                "type": "raster",
                "tiles": options.url,
                "tileSize": 256
            }
        };
        return layer;
    },
    /**
     * Method: getTileUrl
     * 获取服务的URL。
     *
     * returns
     * {url} 图层的url
     */
    getTileUrl:function(){
        var url;
        url = this.url;
        return url;
    },

    /**
     * Method: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.WMS_>} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMS_(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.maxZoom,
                this.minZoom,
                this.name,
                this.url
            );
        }
        return obj;
    },
    CLASS_NAME: "GeoGlobe.Layer.WMS_"
});﻿/**
 * Class: GeoGlobe.Layer.WMTS_
 * WMS图层类，WMTS图层类的实例是用来显示OGC网络地图服务上的瓦片数据。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer.WMTS_>
 */
GeoGlobe.Layer.WMTS_ = GeoGlobe.Class(GeoGlobe.Layer,{
    /**
     * Property: id
     * {string} 图层标志id。
     */
    id: null,

    /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,

    /**
     * Property: matrixSet
     * {string} WMTS服务矩阵标志。
     */
    matrixSet: null,

    /**
     * Property: matrixIds
     * {string} WMTS服务矩阵id。
     */
    matrixIds: null,

    /**
     * Property: tileFullExtent
     * {bounds} 瓦片集的最大范围。
     */
    tileFullExtent: null,

    /**
     * Property: tileSize
     * {int} 瓦片大小。
     */
    tileSize: 256,

    /**
     * Property: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: filter
     * {Array} 图层指定的过滤条件。
     */
    filter: null,

    /**
     * Property: opacity
     * {float} 图层的透明度。
     */
    opacity: 0,

    /**
     * Property: visible
     * {Boolean} 是否可见。
     */
    visible: true,

    /**
     * Constructor: GeoGlobe.Layer.WMTS_
     * GeoGlobe.Layer.WMTS构造函数。
     *
     * Parameters:
     * options - {Object} WMTS相关选项设置。
     */
    initialize: function(options){
        //var url = options.url;
        var paint = {};
        var layer = {
            id:options.id,
            layer:{
                "id": options.id,
                "type": "raster",
                "source":options.id
            },
            source:{
                "type": "raster",
                "tiles": options.url,
                "tileSize": 256
            }
        };
        if (this.matrixIds) {
            var len = this.matrixIds.length;
            if (len && typeof this.matrixIds[0] === "string") {
                var ids = this.matrixIds;
                this.matrixIds = new Array(len);
                for (var i=0; i<len; ++i) {
                    this.matrixIds[i] = {identifier: ids[i]};
                }
            }
        }
        return layer;
    },

    /**
     * Method: getTileUrl
     * 获取服务的URL。
     *
     * returns
     * {url} 图层的url
     */
    getTileUrl:function(){
        var url;
        url = this.url;
        return url;
    },

    /**
     * Method: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.WMTS_>} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMTS_(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },

    /**
     * Method: getMatrix
     * 获取矩阵。
     */
    getMatrix: function() {
        var matrix;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            matrix = {identifier: this.getIdentifier()};
        } else {
            // get appropriate matrix given the map scale if possible
            if ("scaleDenominator" in this.matrixIds[0]) {
                // scale denominator calculation based on WMTS spec
                var denom =
                    OpenLayers.METERS_PER_INCH *
                    OpenLayers.INCHES_PER_UNIT[this.units] *
                    this.getServerResolution() / 0.28E-3;
                var diff = Number.POSITIVE_INFINITY;
                var delta;
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));
                    if (delta < diff) {
                        diff = delta;
                        matrix = this.matrixIds[i];
                    }
                }
            } else {
                // fall back on zoom as index
                matrix = this.matrixIds[this.getIdentifier()];
            }
        }
        return matrix;
    },
    CLASS_NAME: "GeoGlobe.Layer.WMTS_"
});/**
 * Class: GeoGlobe.Layer.GeoTileLayer
 * GeoGlobe瓦片图层类，继承自GeoGlobe.Layer类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer>
 */
GeoGlobe.Layer.GeoTileLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * Property: id
     * {string} 图层标志id。
     */
    id: null,
    
    /**
     * Property: tileSize
     * {int} 瓦片大小。
     */
    tileSize: 256,

    /**
     * Property: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: topLevel
     * {Integer} 图层顶层级别。
     */
    minzoom: null,

    /**
     * Property: bottomLevel
     * {Integer} 图层底层级别。
     */
    maxzoom: null,

    /**
     * Property: serviceName
     * {String} 服务访问名称。
     */
    serviceName : null,

    /**
     * Property: accessUrl
     * {String} 服务访问地址。
     */
    accessUrl : null,

    /**
     * Constructor: GeoGlobe.Layer.GeoTileLayer
     * 创建GeoGlobe瓦片图层对象实例。
     *
     * Parameters:
     * id - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     *
     * 示例:
     * (code)
     * new GeoGlobe.Layer.GeoTileLayer( {
     *      id:"天地图矢量注记",
     *      url:"http://tile0.tianditu.com/services/AB0512_Anno",
     *      type:"raster",
     *      "tileSize":256
     *      minzoom: 2,
     *      maxzoom: 12,
     *      maxExtent: new GeoGlobe.LngLatBounds(-180, -90, 180, 90)
     * })
     * (end)
     */
    initialize : function(options){
        this.url = options.url;
        var gturl =[];
        var extents ;
        this.extent = options.maxextent;
        convertUrl(this.url);
        exttolat(this.extent)
        var layer = {
            "id": options.id,
            "name": options.name,
            "type": options.type,
            "source":{
                "type": options.type,
                "tiles": [gturl[0]+"?T="+gturl[1]+"&X={x}&Y={y}&L={z}"],
                "tileSize": options.tileSize
            },
            "maxzoom": parseInt(options.maxzoom),
            "minzoom": parseInt(options.minzoom),
            "paint": {
            	"raster-opacity": options.opacity == null ? 1 : options.opacity
            },
            "layout": {
            	"visibility": options.visibility == null ? "visible" :  options.visibility
            }
        };
        //var layers ={
        //    layer:layer,
        //    extent:extents
        //}
        return layer;

        function convertUrl(url){
            var tmpUrl = url.split("/services/");
            if (tmpUrl[0] && tmpUrl[1]) {
                gturl.push(tmpUrl[0] + "/DataServer");
                gturl.push(tmpUrl[1]);
            } else {
                alert("解析服务地址错误:" + url);
                return;
            }
        }
        function exttolat(extent){
            extents = extent.split(",");
            for(var e = 0; e < extents.length;e++){
                extents[e] = parseInt(extents[e]);
            }
        }
    },

    /**
     * APIMethod: convertUrl
     * 将服务地址转换成实际瓦片图片访问地址。
     *
     * Paramters:
     * url - {String} 服务地址。
     */
    convertUrl: function(url){
        var tmpUrl = url.split("/services/");
        if (tmpUrl[0] && tmpUrl[1]) {
            this.accessUrl = tmpUrl[0] + "/DataServer";
            this.serviceName = tmpUrl[1];
        } else {
            OpenLayers.Console.error("解析服务地址错误:" + url);
            return;
        }
    },

    /**
     * APIMethod: selectUrl
     * 镜像地址分布方法,行号(x)与镜像地址数量取余数。
     *
     * Parameters:
     * factor - {Integer}
     * urls - {Array(String)}
     *
     * Returns:
     * {String} 选择地址。
     */
    selectUrl:function(factor, urls){
        var len = urls.length;
        var remainder = factor % len;
        return urls[remainder];

    },

    /**
     * APIMethod: getDataExtent
     * 获取获取图层范围。
     *
     * Returns:
     * {<GeoGlobe.LngLatBounds>}图层范围。
     */
    getDataExtent: function () {
        if (this.maxExtent){
            return this.maxExtent.clone();
        }
    },

    /**
     * APIMethod: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.GeoTileLayer>} 被克隆的图层对象。
     */
    clone : function(obj){
        obj = new GeoGlobe.Layer.GeoTileLayer(this.name,
            this.url,
            this.options);
        return obj;
    },

    CLASS_NAME: "GeoGlobe.Layer.GeoTileLayer"
});/**
 * Class: GeoGlobe.Layer.GeoWMTSLayer
 * 吉奥wmts类，继承自GeoGlobe.Layer.WMTS类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer.WMTS>
 */
GeoGlobe.Layer.GeoWMTSLayer = GeoGlobe.Class(GeoGlobe.Layer.WMTS, {
    /**
     * Property: id
     * {string} 图层标志id。
     */
    id: null,

    /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,

    /**
     * Property: matrixSet
     * {string} WMTS服务矩阵标志。
     */
    matrixSet: null,

    /**
     * Property: matrixIds
     * {string} WMTS服务矩阵id。
     */
    matrixIds: null,

    /**
     * Property: tileFullExtent
     * {bounds} 瓦片集的最大范围。
     */
    tileFullExtent: null,

    /**
     * Property: tileSize
     * {int} 瓦片大小。
     */
    tileSize: 256,

    /**
     * Property: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: filter
     * {Array} 图层指定的过滤条件。
     */
    filter: null,

    /**
     * Property: opacity
     * {float} 图层的透明度。
     */
    opacity: 0,

    /**
     * Property: visible
     * {Boolean} 是否可见。
     */
    visible: true,

    /**
     * Property: time
     * {String} 时间版本。
     *  声明：time的值只能通过setVerstionTime方法才能改变。
     */
    time: "9999-01-01 00:00:00",

    /**
     * Property: userecent
     * 为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
     * 否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
     * 返回其中最新的瓦片数据。默认为true。
     */
    userecent: true,

    /**
     * Constructor: GeoGlobe.Layer.GeoWMTSLayer
     * 创建GeoWMTS图层对象实例。
     *
     * Parameters:
     * name - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     *
     * 示例:
     * (code)
     *
     * (end)
     */
    initialize : function(options){
        var layer = {
            "id": options.id,
            "type": options.type,
            "source":{
                "type": options.type,
                "tiles":[options.url],
                "tileSize": options.tileSize
            },
            "maxzoom":parseInt(options.maxzoom),
            "minzoom":parseInt(options.minzoom)
        };
        return layer;
    },

    /**
     * APIMethod: setVerstionTime
     * 设置历史版本,设置版本后会重新绘制本图层。
     *
     * Paramters:
     * verstion - {<String>} 历史版本号,格式为"2010-06-23 18:48:23"。
     */
    setVerstionTime: function(verstion){
        if(verstion){
            this.params.time = verstion;
            this.time = verstion;
            this.redraw();
        }
    },

    /**
     * APIMethod: setParams
     *  设置多时相相关参数。
     *
     * Paramters:
     *  params:
     *   time - {String}时间版本。
     *   userecent - {Boolean}
     *   为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
     *   否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
     *   返回其中最新的瓦片数据。默认为true。
     */
    setParams: function(params) {
        if(params.time) {
            this.params.time = params.time;
            this.time = params.time;
            var userecent = typeof params.userecent == "boolean" ? params.userecent : true;
            this.params.USERECENT = userecent;
            this.userecent = userecent;
            this.redraw();
        }
    },

    /**
     * APIMethod: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.GeoWMTSLayer>} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.GeoWMTSLayer(this.options);
        }
        new GeoGlobe.Layer.GeoWMTSLayer(this.options);
        //obj = GeoGlobe.Layer.WMTS.prototype.clone.apply(this, [obj]);
        return obj;
    },

    CLASS_NAME: "GeoGlobe.Layer.GeoWMTSLayer"
});﻿/**
 * Class: GeoGlobe.Layer.VectorTile
 * WMS图层类，WMS图层类的实例是用来显示OGC网络地图服务上的数据。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer.VectorTile>
 */
GeoGlobe.Layer.VectorTile = GeoGlobe.Class(GeoGlobe.Layer,{
    /**
     * Property: id
     * {string} 图层标志id。
     */
    id: null,

    /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,

    /**
     * Property: url
     * {string} 网络服务地址。
     */
    url: null,

    /**
     * Property: filter
     * {Array} 图层指定的过滤条件。
     */
    filter: null,

    /**
     * Property: opacity
     * {float} 图层的透明度。
     */
    opacity: 0,

    /**
     * Property: visible
     * {Boolean} 是否可见。
     */
    visible: true,

    /**
     * Property: maxZoom
     * {int} 图层最大层级。
     */
    maxZoom: 20,

    /**
     * Property: minZoom
     * {int} 图层最小层级。
     */
    minZoom: 0,

    /**
     * Constructor: GeoGlobe.Layer.VectorTile
     * GeoGlobe.Layer.WMS构造函数。
     *
     * Parameters:
     * options - {Object} 矢量图层相关选项设置。
     */
    initialize: function(options){
/**
        var layer = {
            id:options.id,
            layer:options.style,
            source:{
                "type": options.type,
                "tiles": options.url
            }
        };
*/
        return options;
    },

    /**
     * Method: getTileUrl
     * 获取服务的URL。
     *
     *  Returns:
     * {url}图层的url
     */
    getTileUrl:function(){
        var url;
        url = this.url;
        return url;
    },

    /**
     * Method: clone
     * 复制图层对象。
     *
     * Returns:
     * {<GeoGlobe.Layer.VectorTile>} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.VectorTile(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.maxZoom,
                this.minZoom,
                this.name,
                this.url
            );
        }
        return obj;
    },
    CLASS_NAME: "GeoGlobe.Layer.VectorTile"
});
/**
 * Class: GeoGlobe.Layer.RasterLayer
 * 矢量图层。
 *
 * Inherits from:
 *  - <GeoGlobe.RasterLayer>
 */
GeoGlobe.Layer.RasterLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * Property: opacity
     * {number} 透明度。
     */
    "raster-opacity": null,

    /**
     * Property: raster-hue-rotate
     * {number} 旋转颜色。
     */
    "raster-hue-rotate": null,

    /**
     * Property: raster-brightness-min
     * {number} 最小亮度。
     */
    "raster-brightness-min": null,

    /**
     * Property: raster-brightness-max
     * {number} 最大亮度。
     */
    "raster-brightness-max": null,

    /**
     * Property: raster-saturation
     * {number} 增加或减少图像的饱和度。
     */
    "raster-saturation": null,

    /**
     * Property: raster-contrast
     * {number} 增加或减少图像的对比度。
     */
    "raster-contrast": null,

    /**
     * Property: raster-fade-duration
     * {number} 瓦片褪色的持续时间。
     */
    "raster-fade-duration": null,

    /**
     * Constructor: GeoGlobe.Layer.RasterLayer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.RasterLayer"
});


/**
 * Class: GeoGlobe.Layer.FillLayer
 * 填充图层。
 *
 * Inherits from:
 *  - <GeoGlobe.FillLayer>
 */
GeoGlobe.Layer.FillLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * Property: color
     * {color} 图层颜色。
     */
    "fill-color": null,

    /**
     * Property: pattern
     * {string} 用于绘制图像背景的图像中的图像的名称。
     */
    "fill-pattern": null,

    /**
     * Property: opacity
     * {number} 透明度。
     */
    "fill-opacity": null,

    /**
     * Property: antialias
     * {boolean} 是否有锯齿。
     */
    "fill-antialias": null,

    /**
     * Property: outlineColor
     * {color} 填充的轮廓颜色。
     */
    "fill-outline-color": null,

    /**
     * Property: translate
     * {array} 几何偏移。
     */
    "fill-translate": null,

    /**
     * Property: translateAnchor
     * {enum} 几何偏移固定。
     */
    "fill-translate-anchor": null,

    /**
     * Constructor: GeoGlobe.Layer.FillLayer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.FillLayer"
});


/**
 * Class: GeoGlobe.Layer.CircleLayer
 * 填充图层。
 *
 * Inherits from:
 *  - <GeoGlobe.CircleLayer>
 */
GeoGlobe.Layer.CircleLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * Property: circle-radius
     * {number} 圆的半径。
     */
    "circle-radius": null,

    /**
     * Property: circle-color
     * {color} 图层颜色。
     */
    "circle-color": null,

    /**
     * Property: circle-blur
     * {number} 圆的清晰度的数量。
     */
    "circle-blur": null,

    /**
     * Property: opacity
     * {number} 透明度。
     */
    "circle-opacity": null,

    /**
     * Property: circle-pitch-scale
     * {enum} 当地图倾斜时，控制圆圈的缩放行为。
     */
    "circle-pitch-scale": null,

    /**
     * Property: circle-translate
     * {array} 几何偏移。
     */
    "circle-translate": null,

    /**
     * Property: circle-translate-anchor
     * {enum} 几何偏移固定。
     */
    "circle-translate-anchor": null,

    /**
     * Constructor: GeoGlobe.Layer.CircleLayer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.CircleLayer"
});


/**
 * Class: GeoGlobe.Layer.SymbolLayer
 * 符号图层。
 *
 * Inherits from:
 *  - <GeoGlobe.SymbolLayer>
 */
GeoGlobe.Layer.SymbolLayer = GeoGlobe.Class(GeoGlobe.Layer,{


    /**
     * Property: visibility
     * {Boolean} 图层是否可见。
     */
    visibility: null,

    /**
     * Property: symbol-placement
     * {enum} 标签放置位置。
     */
    "symbol-placement": null,

    /**
     * Property: symbol-spacing
     * {number} 两个符号之间的距离。
     */
    "symbol-spacing": null,

    /**
     * Property: symbol-avoid-edges
     * {Boolean} 符号避免边缘。
     */
    "symbol-avoid-edges": null,

    /**
     * Property: icon-allow-overlap
     * {boolean} 重叠可见。
     */
    "icon-allow-overlap ": null,

    /**
     * Property: icon-ignore-placement
     * {boolean} 符号可见。
     */
    "icon-ignore-placement": null,

    /**
     * Property: icon-optional
     * {boolean} 如果是真的，文本将显示相应的图标时，图标没有与其他符号和文字不碰撞。
     */
    "icon-optional": null,

    /**
     * Property: icon-rotation-alignment
     * {enum} 在与符号放置的组合，确定图标的旋转行为。
     */
    "icon-rotation-alignment": null,

    /**
     * Property: icon-size
     * {number} 图标大小。。
     */
    "icon-size": null,

    /**
     * Property: icon-text-fit
     * {enum} 尺度的图标。
     */
    "icon-text-fit": null,

    /**
     * Property: icon-text-fit-padding
     * {array} 图标文本大小适合。
     */
    "icon-text-fit-padding": null,

    /**
     * Property: icon-image
     * {string} 图标图片。
     */
    "icon-image": null,

    /**
     * Property: icon-rotate
     * {number} 顺时针旋转图标。
     */
    "icon-rotate": null,

    /**
     * Property: icon-padding
     * {number} 用于检测符号冲突的图标边界范围的附加区域的大小。
     */
    "icon-padding": null,

    /**
     * Property: icon-offset
     * {enum} 图标偏移。
     */
    "icon-offset": null,

    /**
     * Property: icon-keep-upright
     * {boolean} 是否翻转。
     */
    "icon-keep-upright": null,

    /**
     * Property: text-pitch-alignment
     * {enum} 文字倾斜方向。
     */
    "text-pitch-alignment": null,

    /**
     * Property: text-rotate-alignment
     * {enum} 文字旋转。
     */
    "text-rotate-alignment": null,

    /**
     * Property: text-field
     * {string} 文本标签的值。
     */
    "text-field": null,

    /**
     * Property: text-font
     * {array} 文本字体。
     */
    "text-font": null,

    /**
     * Property: text-size
     * {number} 文本字体大小
     */
    "text-size": null,

    /**
     * Property: text-max-width
     * {number} 文本最大线宽。
     */
    "text-max-width": null,

    /**
     * Property: text-line-height
     * {number} 文本最大线高。。
     */
    "text-line-height": null,

    /**
     * Property: text-letter-spacing
     * {number} 文本跟踪量。
     */
    "text-letter-spacing": null,

    /**
     * Property: text-justify
     * {enum} 文本对齐。
     */
    "text-justify": null,

    /**
     * Property: text-anchor
     * {enum} 文本偏移。
     */
    "text-anchor": null,

    /**
     * Property: text-max-angle
     * {number} 相邻字符之间的最大角度变化。
     */
    "text-max-angle": null,

    /**
     * Property: text-rotate
     * {number} 顺时针旋转文本。
     */
    "text-rotate": null,

    /**
     * Property: text-padding
     * {number} 附加区域的大小。
     */
    "text-padding": null,

    /**
     * Property: text-keep-upright
     * {boolean} 是否翻转。。
     */
    "text-keep-upright": null,

    /**
     * Property: text-offset
     * {enum} 文本偏移。
     */
    "text-offset": null,

    /**
     * Property: text-transform
     * {enum} 文本变换。
     */
    "text-transform": null,

    /**
     * Property: text-allow-overlap
     * {boolean} 重叠可见。
     */
    "text-allow-overlap ": null,

    /**
     * Property: text-ignore-placement
     * {boolean} 符号可见。
     */
    "text-ignore-placement": null,

    /**
     * Property: text-optional
     * {boolean} 如果是真的，文本将显示相应的图标时，图标没有与其他符号和文字不碰撞。
     */
    "text-optional": null,

    /**
     * Property: icon-color
     * {color} 图层颜色。
     */
    "icon-color": null,

    /**
     * Property: icon-halo-color
     * {color} 图标的光环的颜色。
     */
    "icon-halo-color": null,

    /**
     * Property: icon-opacity
     * {number} 透明度。
     */
    "icon-opacity": null,

    /**
     * Property: icon-halo-width
     * {number} 图标轮廓的距离。
     */
    "icon-halo-width": null,

    /**
     * Property: icon-halo-blur
     * {number} 图标光晕模糊度。
     */
    "icon-halo-blur": null,

    /**
     * Property: icon-translate
     * {array} 几何偏移。
     */
    "icon-translate ": null,

    /**
     * Property: icon-translate-anchor
     * {enum} 几何偏移固定。
     */
    "icon-translate-anchor": null,

    /**
     * Property: text-color
     * {color} 文字颜色。
     */
    "text-color": null,

    /**
     * Property: text-halo-color
     * {color} 文字的光环的颜色。
     */
    "text-halo-color": null,

    /**
     * Property: text-opacity
     * {number} 透明度。
     */
    "text-opacity": null,

    /**
     * Property: text-halo-width
     * {number} 文字轮廓的距离。
     */
    "text-halo-width": null,

    /**
     * Property: text-halo-blur
     * {number} 文字光晕模糊度。
     */
    "text-halo-blur": null,

    /**
     * Property: text-translate
     * {array} 几何偏移。
     */
    "text-translate ": null,

    /**
     * Property: text-translate-anchor
     * {enum} 几何偏移固定。
     */
    "text-translate-anchor": null,

    /**
     * Constructor: GeoGlobe.Layer.SymbolLayer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.SymbolLayer"
});


/**
 * Class: GeoGlobe.Layer.FillExtrusionLayer
 * 填充图层。
 *
 * Inherits from:
 *  - <GeoGlobe.FillExtrusionLayer>
 */
GeoGlobe.Layer.FillExtrusionLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * Property: fill-extrusion-height
     * {number} 高度。
     */
    "fill-extrusion-height": null,

    /**
     * Property: fill-extrusion-pattern
     * {string} 用于绘制图像背景的图像中的图像的名称。
     */
    "fill-extrusion-pattern": null,

    /**
     * Property: fill-extrusion-color
     * {color} 图层颜色。
     */
    "fill-extrusion-color": null,

    /**
     * Property: fill-extrusion-base
     * {number} 图层的基底。
     */
    "fill-extrusion-base": null,

    /**
     * Property: fill-extrusion-opacity
     * {number} 透明度。
     */
    "fill-extrusion-opacity": null,

    /**
     * Property: fill-extrusion-translate
     * {array} 几何偏移。
     */
    "fill-extrusion-translate": null,

    /**
     * Property: fill-extrusion-translate-anchor
     * {enum} 几何偏移固定。
     */
    "fill-extrusion-translate-anchor": null,

    /**
     * Constructor: GeoGlobe.Layer.FillExtrusionLayer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.FillExtrusionLayer"
});


/**
 * Class: GeoGlobe.Layer.LineLayer
 * 线图层。
 *
 * Inherits from:
 *  - <GeoGlobe.LineLayer>
 */
GeoGlobe.Layer.LineLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * Property: color
     * {color} 图层颜色。
     */
    "line-color": null,

    /**
     * Property: pattern
     * {string} 用于绘制图像背景的图像中的图像的名称。
     */
    "line-pattern": null,

    /**
     * Property: opacity
     * {number} 透明度。
     */
    "line-opacity": null,

    /**
     * Property: translate
     * {array} 几何偏移。
     */
    "line-translate": null,

    /**
     * Property: translateAnchor
     * {enum} 几何偏移固定。
     */
    "line-translate-anchor": null,

    /**
     * Property: line-cap
     * {enum} 线尾的显示。
     */
    "line-cap": null,

    /**
     * Property: line-join
     * {enum} 连接时线的显示。
     */
    "line-join": null,

    /**
     * Property: line-miter-limit
     * {number} 用于自动转换人字加入锥连接的尖角。。
     */
    "line-miter-limit": null,

    /**
     * Property: line-round-limit
     * {number} 用于自动转换轮加入人字加入浅角。
     */
    "line-round-limit": null,

    /**
     * Property: width
     * {number} 线宽。
     */
    "line-width": null,

    /**
     * Property: line-gap-width
     * {number} 绘制线条的实际路径以外的线框。
     */
    "line-gap-width": null,

    /**
     * Property: offset
     * {number} 线偏移。
     */
    "line-offset": null,

    /**
     * Property: blur
     * {number} 线的清晰度。
     */
    "line-blur": null,

    /**
     * Property: dasharray
     * {array} 虚线的间隔。
     */
    "line-dasharray": null,

    /**
     * Constructor: GeoGlobe.Layer.LineLayer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.LineLayer"
});


/**
 * Class: GeoGlobe.Layer.BackgroundLayer
 * 背景图层。
 *
 * Inherits from:
 *  - <GeoGlobe.BackgroundLayer>
 */
GeoGlobe.Layer.BackgroundLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * Property: color
     * {color} 图层颜色。
     */
    "background-color": null,

    /**
     * Property: pattern
     * {string} 用于绘制图像背景的图像中的图像的名称。
     */
    "background-pattern": null,

    /**
     * Property: opacity
     * {number} 透明度。
     */
    "background-opacity": null,

    /**
     * Constructor: GeoGlobe.Layer.BackgroundLayer
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.BackgroundLayer"
});

/**
 * Class: GeoGlobe.Layer.ThematicTileLayer
 * 基于专题图服务的专题图图层。
 *
 * Inherits from:
 *  - <GeoGlobe.Layer>
 */
GeoGlobe.Layer.ThematicTileLayer = GeoGlobe.Class4OL(GeoGlobe.Layer, {

    /**
     * Property: map
     * {object} 图层添加的map。
     */
    map: null,

    /**
     * Property: version
     * {String} 服务版本。
     */
    version:"1.0.0",

    /**
     * Property: id
     * {String} 专题图图层专属id。
     */
    id:null,

    /**
     * Property: layerID
     * {String} 图层ID。
     */
    layerID: null,

    /**
     * Property: chartID
     * {String} 专题符号标识。
     */
    chartID: null,

    /**
     * Property: maxExtent
     * {Geo.Bounds} 图层的最大范围。
     */
    maxExtent: null,

    /**
     * Property: format
     * {String} 图片样式。
     */
    format: "png",

    /**
     * Property: colorSchemeID
     * {String} 色卡标识。
     */
    colorSchemeID: null,

    /**
     * Property: hasLegend
     * {Boolean} 是否显示图例，默认值为false。
     */
    hasLegend: false,

    legendType: 0,

    /**
     * Property: legendPosition
     * {String} 图例显示方位，默认为右下角。左上角：tl、左下角：bl、右上角：tr、右下角：br。
     */
    legendPosition:"br",

    /**
     * Property: hasEdge
     * {Boolean} 是否绘制专题图符号的边线，默认值为false。
     */
    hasEdge: false,

    /**
     * Property: hasLabel
     * {Boolean} 是否绘制专题图符号的标注，默认值为false。
     */
    hasLabel: false,

    hasBaseMap: false,

    hasBaseMapLegend: false,

    baseMapExampleColumnNums: 2,

    /**
     * Constructor: GeoGlobe.Layer.ThematicTileLayer
     * 创建一个专题图图层。
     *
     * Parameters:
     * id - {String} 图层名称。
     * url - {String} 专题图服务地址。
     * layerID -  {String} 图层ID。
     * params -{opject} 专题图请求参数
     * hasLegend - {Boolean} 是否显示图例，放params中。
     * hasEdge - {Boolean} 是否绘制专题图符号的边线，放params中。
     * hasLabel - {Boolean} 是否绘制专题图符号的标注，放params中。
     * chartID - {String} 专题符号标识。
     *
     * Examples:
     * (code)
     * 	//添加专题图图层
     *		var thmatic = new GeoGlobe.Layer.ThematicTileLayer({
     *	        id:"thematic"
 	 *			layerID: Cfg.map2DThematicLayerID_JS,
	 *			params:{
	 *		      "hasLegend": true,
     *            "legendType": 0,
     *            "hasEdge": true,
     *            "hasLabel": false,
     *            "hasBaseMap": true,
     *            "hasBaseMapLegend": true,
     *            "baseMapExampleColumnNums": 2
	 *		}
	 *			chartID:Cfg.map2DThematicchartID_JS,
	 *		});
     * (end)
     */
    initialize: function(map,options) {
        var box = options.box;
        var maxx = box._ne.lng;
        var maxy = box._ne.lat;
        var minx = box._sw.lng;
        var miny = box._sw.lat;
        var val = options.params;
        this.map = map;
        this.options = options;
        GeoGlobe.Function.bind(this.seturl, this);
        var setQueryConfig = this.seturl(val);
        var url =this.options.url +"/map"+ "/"+this.options.layerID+"/"+this.options.chartID+"/"+ minx + "/" + miny + "/" + maxx + "/" + maxy +"/"+this.options.width+"/"+this.options.height+".png?"+setQueryConfig;
        this.layer = {
            "id": this.options.id,
            "source": {
                "type": "image",
                "url": url,
                "coordinates": [
                    [minx,maxy],
                    [maxx,maxy],
                    [maxx,miny],
                    [minx,miny]
                ]
            },
            "type": "raster"
        };
        this.zoome = $.proxy(this.zoomend,this);
        this.drage = $.proxy(this.dragend,this);
        this.map.on('zoomend',this.zoome);

        this.map.on('dragend',this.drage);
        GeoGlobe.Function.bind(this.remove, this);
        return this;
    },
    zoomend:function(){

        if(this.map.style._layers[this.options.id] && this.map.style._layers[this.options.id].layout["visibility"] != "none"){
            var metadata = this.map.style._layers[this.options.id].metadata;
            var paint = this.map.style._layers[this.options.id].paint;
            var layout = this.map.style._layers[this.options.id].layout;
            this.map.removeLayer(this.options.id);
            this.map.removeSource(this.options.id);
            box = this.map.getBounds();
            var val = this.options.params;
            maxx = box._ne.lng;
            maxy = box._ne.lat;
            minx = box._sw.lng;
            miny = box._sw.lat;
            var setQueryConfig = this.seturl(val);
			  this.options.width = this.map.getCanvas().width;
            this.options.height = this.map.getCanvas().height;
            url =this.options.url +"/map"+ "/"+this.options.layerID+"/"+this.options.chartID+"/"+ minx + "/" + miny + "/" + maxx + "/" + maxy +"/"+this.options.width+"/"+this.options.height+".png?"+setQueryConfig;
            layer = {
                "id": this.options.id,
                "name": this.options.name,
                "source": {
                    "type": "image",
                    "url": url,
                    "coordinates": [
                        [minx, maxy],
                        [maxx, maxy],
                        [maxx, miny],
                        [minx, miny]
                    ]
                },
                "type": "raster"
            };
            layer.paint = paint;
            layer.layout = layout;
            layer.metadata = metadata;
            this.map.addLayer(layer);
        }
    },
    dragend:function(){
        if(this.map.style._layers[this.options.id] && this.map.style._layers[this.options.id].layout["visibility"] != "none"){
            var metadata = this.map.style._layers[this.options.id].metadata;
            var paint = this.map.style._layers[this.options.id].paint;
            var layout = this.map.style._layers[this.options.id].layout;
            this.map.removeLayer(this.options.id);
            this.map.removeSource(this.options.id);
            box = this.map.getBounds();
            var val = this.options.params;
            maxx = box._ne.lng;
            maxy = box._ne.lat;
            minx = box._sw.lng;
            miny = box._sw.lat;
            var setQueryConfig = this.seturl(val);
			  this.options.width = this.map.getCanvas().width;
            this.options.height = this.map.getCanvas().height;
            url =this.options.url +"/map"+ "/"+this.options.layerID+"/"+this.options.chartID+"/"+ minx + "/" + miny + "/" + maxx + "/" + maxy +"/"+this.options.width+"/"+this.options.height+".png?"+setQueryConfig;
            layer = {
                "id": this.options.id,
                "name": this.options.name,
                "source": {
                    "type": "image",
                    "url": url,
                    "coordinates": [
                        [minx,maxy],
                        [maxx,maxy],
                        [maxx,miny],
                        [minx,miny]
                    ]
                },
                "type": "raster"
            };
            layer.paint = paint;
            layer.layout = layout;
            layer.metadata = metadata;
            this.map.addLayer(layer);
        }

    },


    seturl: function(val){
    var _str = "";
    for(var o in val){
        if(val[o] != -1){
            _str += o + "=" + val[o] + "&";
        }
    }
    var _str = _str.substring(0, _str.length-1);
    return _str;
},

    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(url,successFn, failFn){
        var params = {
            // REQUEST: "GetCapabilities",
            // SERVICE: "TMS",
            f: "json"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("专题图服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        var datas;
        $.ajax({
            url: url,
            dataType:"json",
            cache:false,
            async:false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    /**
     * Method: remove
     * 移除图层。
     *
     */
    remove: function(id) {
  
        this.map.off('zoomend',this.zoome);

        this.map.off('dragend',this.drage);
        this.map.removeLayer(id);
        this.map.removeSource(id);

    },

    /**
     * Method: showLegend
     * 显示图例。
     *
     * TODO:属性中需要增加图例的显示方位，显示大小。
     */
    showLegend: function() {
        var path = this.getLegend({
            layerID:this.layerID,
            chartID:this.chartID,
            colorSchemeID:this.colorSchemeID,
            drawLegend:"ThematicMap",
            legendType:this.legendType
        });
        //var lnglat = []
        //(id, px, sz, imgURL, position, border,opacity, delayDisplay)
        if(!this.imageLegend) {
            var  marker = new GeoGlobe.Marker(path)
                .setLngLat([lnglat.lng,lnglat.lat])
                .addTo(this.map);
        }
    },

    /**
     * Method: getLegend
     * 得到图例。
     *
     * options {Object} 可选项。
     */
    getLegend: function(options) {
        var location = this.url.indexOf("/",this.url.length - 1);
        if(location != -1) {
            this.url = this.url.substr(0,this.url.length - 1);
        }
        var path =  "${url}/legend/${layerID}/${chartID}.${format}?drawLegend=${drawLegend}&legendType=${legendType}";
        path = Geo.String.format(path, {
            'url': this.url,
            'layerID': options.layerID,
            'chartID': options.chartID,
            'format': options.format || "png",
            'drawLegend':options.drawLegend,
            'legendType':options.legendType
        });
        if(typeof options.colorSchemeID === "string") {
            path += ("&ColorSchemeID=" + options.colorSchemeID);
        }
        return path;
    },

    /**
     * Method: setLegendLocation
     * 设置图例位置
     * TODO:属性中需要增加图例的显示方位，显示大小。
     * imageLegend  {DOM}
     */
    setLegendLocation: function(imageLegend) {
        var size = this.map.getSize();
        switch(this.legendPosition) {
            case "br":
                var x = size.w - this.legendSize.w;
                var y = size.h - this.legendSize.h;
                imageLegend.style.left = x+"px";
                imageLegend.style.top = y+"px";
                break;
            case "bl":
                var y = size.h - this.legendSize.h;
                imageLegend.style.left = 0+"px";
                imageLegend.style.top = y+"px";
                break;
            case "tl":
                imageLegend.style.left = 0+"px";
                imageLegend.style.top = 0+"px";
                break;
            case "tr":
                var x = size.w - this.legendSize.w;
                imageLegend.style.left = x+"px";
                imageLegend.style.top = 0+"px";
                break;
        }
    },

    /**
     * Method: showBaseMapLegend
     * 显示底图图例。
     *
     * TODO:属性中需要增加底图图例的显示方位，显示大小。
     */
    showBaseMapLegend: function() {
        var path = this.getBaseMapLegend({
            layerID:this.layerID,
            chartID:this.chartID,
            drawLegend:"BaseMap",
            baseMapExampleColumnNums: this.baseMapExampleColumnNums
        });
        //(id, px, sz, imgURL, position, border,opacity, delayDisplay)
        if(!this.imageBaseMapLegend) {
            var  marker = new GeoGlobe.Marker(path)
                .setLngLat([lnglat.lng,lnglat.lat])
                .addTo(this.map);
        }
    },

    /**
     * Method: getBaseMapLegend
     * 得到底图图例。
     *
     * options {Object} 可选项。
     */
    getBaseMapLegend: function(options) {
        var location = this.url.indexOf("/",this.url.length - 1);
        if(location != -1) {
            this.url = this.url.substr(0,this.url.length - 1);
        }
        var path =  "${url}/legend/${layerID}/${chartID}.${format}?drawLegend=${drawLegend}&baseMapExampleColumnNums=${baseMapExampleColumnNums}";
        path = Geo.String.format(path, {
            'url': this.url,
            'layerID': options.layerID,
            'chartID': options.chartID,
            'format': options.format || "png",
            'drawLegend':options.drawLegend,
            'baseMapExampleColumnNums': options.baseMapExampleColumnNums
        });
        return path;
    },

    /**
     * Method: setBaseMapLegendLocation
     * 设置底图图例位置
     * TODO:属性中需要增加底图图例的显示方位，显示大小。
     * imageBaseMapLegend  {DOM}
     */
    setBaseMapLegendLocation: function(imageBaseMapLegend) {
        var size = this.map.getSize();
        switch(this.baseMapLegendPosition) {
            case "br":
                var x = size.w - this.baseMapLegendSize.w;
                var y = size.h - this.baseMapLegendSize.h;
                imageBaseMapLegend.style.left = x+"px";
                imageBaseMapLegend.style.top = y+"px";
                break;
            case "bl":
                var y = size.h - this.baseMapLegendSize.h;
                imageBaseMapLegend.style.left = 0+"px";
                imageBaseMapLegend.style.top = y+"px";
                break;
            case "tl":
                imageBaseMapLegend.style.left = 50+"px";
                imageBaseMapLegend.style.top = 0+"px";
                break;
            case "tr":
                var x = size.w - this.baseMapLegendSize.w;
                imageBaseMapLegend.style.left = x+"px";
                imageBaseMapLegend.style.top = 0+"px";
                break;
        }
    },

    /**
     * Method: updateHotArea
     * 更新热区。
     * obj  {Geo.Events}
     */
    updateHotArea: function(obj) {
        if(obj.zoomChanged) {
            this.vectorLayer.removeAllFeatures();
        }else {
            this.vectorLayer.redraw();
        }


    },

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<GeoGlobe.Layer.ThematicTileLayer>} An exact clone of this layer
     */
    clone: function (obj) {

        if (obj == null) {
            obj = new GeoGlobe.Layer.ThematicTileLayer(this.id,
                this.url,
                this.params,
                this.getOptions());
        }

        //get all additions from superclasses

        // copy/set any non-init, non-simple values here

        return obj;
    },

    /**
     * Method: getURL
     * Return a GetMap query string for this layer
     *
     * Parameters:
     * bounds - {<GeoGlobe.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also the
     *          passed-in bounds and appropriate tile size specified as
     *          parameters.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var imageSize = this.getImageSize();
//		this.getTileFeature(bounds,imageSize);
        var newParams = {};
        //http://192.168.42.76:7021/ThematicMapService/tms/map/0/020101/
        //87.6061172485352/20.0317935943604/126.643341064453/45.7414932250977/1024/1024.png?
        //ColorSchemeID=3&hasLegend=true&hasEdge=true&hasLabel=true
        //var requestString = this.getFullRequestString(newParams);
        var url = "${url}/map/${layerID}/${chartID}/${left}/${bottom}/${right}/${top}/${width}/${height}.${format}?"+
            "hasLegend=${hasLegend}&legendType=${legendType}&hasEdge=${hasEdge}&hasLabel=${hasLabel}&"+
            "hasBaseMap=${hasBaseMap}&hasBaseMapLegend=${hasBaseMapLegend}&baseMapExampleColumnNums=${baseMapExampleColumnNums}";
        url = GeoGlobe.String.format(url, {
            'url': this.url,
            'layerID': this.layerID,
            'chartID': this.chartID,
            'left': bounds.left,
            'bottom': bounds.bottom,
            'right':bounds.right,
            'top': bounds.top,
            'width': imageSize.w,
            'height': imageSize.h,
            'format': this.format,
            'hasLegend':this.hasLegend,
            'legendType':this.legendType,
            'hasEdge': this.hasEdge,
            'hasLabel': this.hasLabel,
            'hasBaseMap': this.hasBaseMap,
            'hasBaseMapLegend': this.hasBaseMapLegend,
            'baseMapExampleColumnNums': this.baseMapExampleColumnNums
        });
        if(typeof this.colorSchemeID === "string") {
            url += ("&ColorSchemeID=" + this.colorSchemeID);
        }
        //&ColorSchemaID=${ColorSchemaID}
        return url;
    },
    CLASS_NAME: "GeoGlobe.Layer.ThematicTileLayer"
});/**
 * Class: GeoGlobe.CanvasLayer
 * canvasLayer类。主要用于绘制各种canvas效果。
 */
GeoGlobe.CanvasLayer = GeoGlobe.Class4OL({

    /**
     * Property: map
     * {String} 添加的地图容器。
     */
    map: null,
	
    /**
     * APIProperty: context
     * {String} canvas上下文对象。
     */
    context: null,
	
    /**
     * Constructor: GeoGlobe.CanvasLayer
     * GeoGlobe.CanvasLayer构造函数。
     *
     * Parameters:
     * options - {Object} 参数对象
     */
    initialize: function(options){
		this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
        this.options = options;
    },

    /**
     * APIMethod: drawOnMove
     * 地图移动时执行的方法。
     */
	drawOnMove: null,
	
    /**
     * Method: _drawLayer
     */
	_drawLayer: function(){
		this.clear();
		var args = this._prepareDrawParams();
        if (!args) {
            return;
        }
        this.draw.apply(this, args);
	},
	
    /**
     * Method: _prepareDrawParams
     */
	_prepareDrawParams: function (context){
		var params = [];
		if(!this._drawContext){
	        this._drawContext = this.prepareToDraw.apply(this, [this.context].concat(params));
		}
		
		var args = [this.context];
        args.push.apply(args, this._drawContext);
		return args;
    },
	
    /**
     * APIMethod: prepareToDraw
     */
	prepareToDraw: function (context){
    },
	
    /**
     * APIMethod: draw
     *
     */
    draw: function (context){
    },
	
    /**
     * Method: addTo
     * 与地图对象关联
     * 
     * Parameters:
     * map - {Object} map对象
     */
    addTo: function (map){
		this.map = map;
        var mapContainer = map.getCanvasContainer();
		//设置canvas的宽高
		this.canvas = document.createElement('canvas');
		this.canvas.id = this.id;
		this.canvas.style.width = map.getCanvas().style.width;
		this.canvas.style.height = map.getCanvas().style.height;
		this.canvas.style.position = "absolute";
		this.canvas.style.display = "none";
		this.canvas.width = map.getCanvas().width;
		this.canvas.height = map.getCanvas().height;
		mapContainer.appendChild(this.canvas);
		
		this.context = this.canvas.getContext("2d");
		
		//绑定事件
		this._bindEvent();
		
		var coordinates = this._boundsToCoordinates(map.getBounds());
		var source = {
			type: 'canvas',
			canvas: this.canvas.id,//'mycanvas',
			contextType: "2d",
			animate: true,
			/*coordinates: [
			    [110.177, 28.281],
			    [120.52, 28.281],
			    [120.52, 25.17],
			    [110.177, 25.17]
			],
			coordinates: [
			    [32, 57],
			    [150, 57],
			    [150, 0],
			    [32, 0]
			]*/
			coordinates: coordinates
		};
		var layer = {
			"id": this.id + "_layer",
            "source": this.id,
            "type": "raster",
            "paint": {
				"raster-opacity": 1
			}
		};
		map.addSource(this.id, source);
		map.addLayer(layer);
		
		this.source = map.getSource(this.id);
		this.layer = map.getLayer(this.id+ "_layer");
		mapContainer.removeChild(this.canvas);
		this._drawLayer();
    },
	
    /**
     * Method: _bindEvent
     * 事件绑定。
     */
	_bindEvent: function(){
		
		var map = this.map;
		//this._zoomStart = GeoGlobe.Function.bind(function(e){}, this);
		//this._zoom = GeoGlobe.Function.bind(function(e){}, this);
		//this._zoomend = GeoGlobe.Function.bind(function(e){console.log("zoomend:" + e);}, this);
		this._move = GeoGlobe.Function.bind(function(e){
			//this.source.pause();
			if (typeof this.drawOnMove === "function") {
				this.drawOnMove(e);
			}
		}, this);
		//this._rotate = GeoGlobe.Function.bind(function(e){}, this);
		//this._movestart = GeoGlobe.Function.bind(function(e){}, this);
		this._moveend = GeoGlobe.Function.bind(function(e){
			//console.log("moveend:" + e);
			var coordinates = this._boundsToCoordinates(e.target.getBounds());
			this.source.setCoordinates(coordinates);
			//this.source.play();
			//this.source.prepare();
			this._drawLayer();
		}, this);
		
		//map.on('zoomstart', this._zoomStart);
        //map.on('zoom', this._zoom);
		//map.on("zoomend", this._zoomend);
        //map.on('rotate', this._rotate);
        //map.on('movestart', this._movestart);
        map.on('move', this._move);
        map.on('moveend', this._moveend);
		
	},
	
    /**
     * APIMethod: pause
     * 暂停
     */
    pause: function(){
		this.source.pause();
    },
	
    /**
     * APIMethod: play
     * 播放
     */
    play: function(){
		this.source.play();
    },
	
    /**
     * APIMethod: setOpacity
     * 设置透明度
     */
    setOpacity: function(opacity){
		this.map.setPaintProperty(this.layer.id, 'raster-opacity', parseFloat(opacity));
    },

    /**
     * APIMethod: clear
     * 清除
     *
     */
    clear:function(){
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },

    /**
     * APIMethod: remove
     * 移除并销毁。
     */
    remove: function(){
        this.clear();
		
		var map = this.map;
		//map.off('zoomstart', this._zoomStart);
        //map.off('zoom', this._zoom);
		//map.off("zoomend", this._zoomend);
        //map.off('rotate', this._rotate);
        //map.off('movestart', this._movestart);
        map.off('move', this._move);
        map.off('moveend', this._moveend);
		
		map.removeSource(this.source.id);
		map.removeLayer(this.layer.id);
		this.canvas = null;
		this.map = null;
    },
	
	_boundsToCoordinates: function(bounds){
		var barr = bounds.toArray();
		var minx = barr[0][0];
		var miny = barr[0][1];
		var maxx = barr[1][0];
		var maxy = barr[1][1];
		var coordinates = [
		    [minx, maxy],
		    [maxx, maxy],
		    [maxx, miny],
		    [minx, miny]
		];
		return coordinates;
	},
	
    CLASS_NAME: "GeoGlobe.CanvasLayer"
});﻿/**
 * Class: GeoGlobe.TDTLayer
 * GeoGlobe.TDTLayer天地图图层类。
 */
GeoGlobe.TDTLayer = GeoGlobe.Class4OL({

    /**
     * Constructor: GeoGlobe.TDTLayer
     * 创建天地图图层对象。
     *
     * Parameters:
     * name - {String} 天地图图层名称。值有四种选择："vec_w","cva_w","vec_c"或"cva_c"。
     * 					分别表示墨卡托底图，墨卡托注记层，经纬度底图，经纬度注记层。
     *
     * 示例:
     * (code)
     *  var layer = new GeoGlobe.TDTLayer("vec_w");
     *  map.addLayer(layer);
     * (end)
     */
    initialize: function(name){
		return this._getLayer(name);
    },
	
	_getLayer: function(name){
		var id = "tdt_" + name + "_" + GeoGlobe.Util.randomStr(8);
		var url = GeoGlobe.ProxyHost + this._getUrlTemplateByName(name);
		return {
            "id": id,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [url],
                "tileSize": 256
            }
        };
	},
	
	/**
     * Method: _getUrlTemplateByName
	 * 获取天地图url模板
	 * 
     * Parameters:
     * name - {String} 天地图图层名称。
     * 
     * Returns:
     * {String} 天地图url模板
	 */
	_getUrlTemplateByName: function(name){
		//"http://t0.tianditu.com/vec_w/wmts"
		var urlTemplate = "http://t0.tianditu.com/"+name+"/wmts?" + this._getParameterString(this.tdtParams[name]);
		return urlTemplate;
	},
	
	tdtParams: {
		"vec_w": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "vec",
	        TILEMATRIXSET: "w",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
		"cva_w": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "cva",
	        TILEMATRIXSET: "w",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
		"vec_c": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "vec",
	        TILEMATRIXSET: "c",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
		"cva_c": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "cva",
	        TILEMATRIXSET: "c",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
        "img_w": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "img",
            TILEMATRIXSET: "w",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        },
        "cia_w": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cia",
            TILEMATRIXSET: "w",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        },
        "img_c": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "img",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        },
        "cia_c": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cia",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        }
	},
	
	/**
     * Method: _getParameterString
	 * 获取以&分割的参数字符串
	 * 
     * Parameters:
     * params - {Object} 参数选项。
     * 
     * Returns:
     * {String} 参数字符串。
	 */
	_getParameterString: function(params) {
		var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key.toUpperCase() + "=" + value);
            }
        }
	    return paramsArray.join("&");
	},

    CLASS_NAME: "GeoGlobe.TDTLayer"
});/**
 * Class: GeoGlobe.Layer.HotArea
 * 热区图层类。
 */
GeoGlobe.Layer.HotArea = GeoGlobe.Class4OL({
	
	url: null,
	
    layer: null,
	
    format: null,
	
    matrixSet: null,
	
    style: null,
	
	version: "1.0.0",
	
	 /**
     * Property: name
     * {string} 图层名称。
     */
    name: null,
	
	layerid: null,
	
	hotareaLayers: null,
	
	hotareaHighlightedLayers: null,
	
	tileUrls: null,

    /**
     * Constructor: GeoGlobe.Layer.HotArea
     * GeoGlobe.Layer.HotArea构造函数。
     *
     * Parameters:
     * options - {Object} GeoGlobe.Layer.HotArea相关选项设置。
     */
    initialize: function(options){
		//GeoGlobe.Util.extend(this, options);
		this.name = options.name ? options.name: null;
		this.url = options.url;
		this.layer = options.layer;
		this.format = options.format;
		this.matrixSet = options.matrixSet;
		this.style = options.style;
		
		this.layerid = "geoglobe_layer_hotarea_" + GeoGlobe.Util.randomStr(8);
		this.layerOption = {
            "id": this.layerid,
            "type": "raster",
            "source": {
                "type": "raster",
				"rasterType": "hotarea",
				"tiles": [GeoGlobe.appendToProxy(options.url + "?SERVICE=WMTS&REQUEST=GetTile&LAYER="+this.layer+"&TILEMATRIXSET="+this.matrixSet+"&FORMAT="+this.format+"&VERSION="+this.version+"&STYLE="+this.style+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}")],
                //"tiles": [GeoGlobe.appendToProxy(options.url + "?SERVICE=WMTS&REQUEST=GetTile&LAYER=cvgb_hotarea&TILEMATRIXSET=Matrix_cvgb_hotarea_0&FORMAT=text/json&VERSION=1.0.0&STYLE=cvgb_hotarea&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}")],
                "tileSize": 256
            },
            "paint": {
                "raster-opacity": 1
            },
			"metadata": {
				"type": "hotarea"
			}
        };
		
		this.hotareaLayers = [];
		this.hotareaHighlightedLayers = [];
		this.tileUrls = [];
		
		this.onclick = (typeof options.onclick === 'function') ? options.onclick: this.onclick;
        //return this._getHotAreaLayer(params);
    },
	
	addTo: function(map){
		this.map = map;
		map.addLayer(this.layerOption);
		this._bindEvent();
	},
	
	_bindEvent: function(){
		var map = this.map;
		GeoGlobe.Layer.HotArea["callback_tileJSON_"+this.layerid] = GeoGlobe.Function.bind(this.callback_tile, this);
		
		//高亮方法
		var highlightFn = GeoGlobe.Function.bind(function(e){
	        // set bbox as 2px reactangle area around clicked point
	        var bbox = [[e.point.x - 2, e.point.y - 2], [e.point.x + 2, e.point.y + 2]];
			var layers = [];
			for(var i =0; i < this.hotareaLayers.length; i++){
				layers.push(this.hotareaLayers[i].id);
			}
	        var features = map.queryRenderedFeatures(bbox, {layers: layers});
			
			//每次只选取一个
			if(features.length > 0){
				features = [features[0]];
				this.map.getCanvas().style.cursor = 'pointer';
			}else{
				this.map.getCanvas().style.cursor = '';
			}
	        var filter = features.reduce(function(memo, feature) {
	            memo.push(feature.properties.displayname);
	            return memo;
	        }, ['==', 'displayname']);
			filter = (filter.length === 2) ? ['==', 'displayname', ""] : filter;
			
			for(var i =0; i < this.hotareaHighlightedLayers.length; i++){
		        map.setFilter(this.hotareaHighlightedLayers[i].id, filter);
			}
			if(e.type === "click"){
				e.features = features;
				this.onclick(e);
			}
	    },this);
		map.on('click', highlightFn);
		map.on('mousemove', highlightFn);
		
		//缩放时，清空热区数据
		var _zoomstart = GeoGlobe.Function.bind(function(e){
			for (var i = 0; i < this.hotareaHighlightedLayers.length; i++) {
				map.removeLayer(this.hotareaHighlightedLayers[i].id);
			};
			this.hotareaHighlightedLayers = [];
			for (var i = 0; i < this.hotareaLayers.length; i++) {
				map.removeLayer(this.hotareaLayers[i].id);
        		map.removeSource(this.hotareaLayers[i].id);
			};
			this.hotareaLayers = [];
			this.tileUrls = [];
		},this);
		map.on('zoomstart', _zoomstart);
	},
	
    /**
     * Method: callback_tile
     * 热区tile数据的回调方法。
	 * 
     * Parameters:
     * op - {Object} 热区数据。
     */
	callback_tile: function(op){
		var tileUrl = op.tileUrl;
		
		var isExist = false;
        for (var i = 0; i < this.tileUrls.length; i++) {
            if (this.tileUrls[i] === tileUrl) {
                isExist = true;
            }
        }
		
		if (!isExist) {
			this.tileUrls.push(tileUrl);
			var data = op.data;
			var features = data.features;
			for (var i = 0; i < features.length; i++) {
				var picsymid = features[i].properties.picsymid;
				features[i].properties.overPicUrl = this.getPicURL(picsymid, true);
				features[i].properties.outPicUrl = this.getPicURL(picsymid, false);
			}
			
			var map = op.map;
			var layerid = op.layerid;
			//map.addSource("hotarea_source_id_", {
			//	 type: "geojson",
			//	 data: data
			//});
			
			var randomStr = GeoGlobe.Util.randomStr(8);
			//默认透明样式
			var hotareaLayer = {
				"id": "hotarea_id_" + randomStr,
				"type": "fill",
				"source": {
					"type": "geojson",
					"data": data
				},
				"paint": {
					'fill-color': '#088',
					'fill-opacity': 0
				}
			};
			map.addLayer(hotareaLayer);
			this.hotareaLayers.push(hotareaLayer);
			
			//高亮样式
			var hotareaHighlightedLayer = {
				"id": "hotarea_highlighted_id_" + randomStr,
				"type": "fill",
				"source": hotareaLayer.id,
				//"source-layer": "original",
				"paint": {
					"fill-outline-color": "#484896",
					"fill-color": "#6e599f",
					"fill-opacity": 0
				},
				"filter": ["==", "displayname", ""]
			};
			map.addLayer(hotareaHighlightedLayer);
			this.hotareaHighlightedLayers.push(hotareaHighlightedLayer);
		}
	},
	
	/**
     * Method: getPicURL
     * 
     * Parameters:
     * picid - {<Number>}
     * isanti - {<Blooean>}
     * 
     * Returns:
     * {String} A URL for the pic.
     */
    getPicURL: function(picid, isanti){
        // assemble all required parameters
        var params = {
            SERVICE: "WMTS",
            REQUEST: "GetIcon",
            VERSION: this.version,
            LAYER: this.layer,
            //STYLE: this.style,
            //TILEMATRIXSET: this.matrixSet,
            //TILEMATRIX: this.matrix.identifier,
            PICID: picid, //0
            ISANTI: isanti // 默认false
        };
        var url = this.url + "?" + this._getParameterString(params);
        return url;
    },
	
	/**
     * Method: _getParameterString
	 * 获取以&分割的参数字符串
	 * 
     * Parameters:
     * params - {Object} 参数选项。
     * 
     * Returns:
     * {String} 参数字符串。
	 */
	_getParameterString: function(params) {
		var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key.toUpperCase() + "=" + value);
            }
        }
	    return paramsArray.join("&");
	},
	
	/**
     * Method: onclick
	 * 点击热区的回调函数
	 * 
     * Parameters:
     * e - {Object} 事件对象。
	 */
	onclick: function(e){
	},
	
    CLASS_NAME: "GeoGlobe.Layer.HotArea"
});
/**
 * Class: GeoGlobe.Source
 * 数据源。
 *
 * Inherits from:
 *  - <GeoGlobe.Source>
 */
GeoGlobe.Source = GeoGlobe.Class(mapboxgl.FreeCRSMap,{

    /**
     * Property: SourceId
     * {string} 数据源id。
     */
    SourceId: null,

    /**
     * Constructor: GeoGlobe.Source
     * GeoGlobe.Source构造函数。
     *
     * Parameters:
     * options - {Object} 源相关选项设置。
     */

    initialize: function(){
        return this;
    },
    CLASS_NAME: "GeoGlobe.Source"
});

/**
 * Class: GeoGlobe.Source.GeoJSONSource
 * GeoJSON数据源。
 *
 * Inherits from:
 *  - <GeoGlobe.Source.GeoJSONSource>
 */
GeoGlobe.Source.GeoJSONSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{


    /**
     * Property: minzoom
     * {number} 最小层级。
     */
    minzoom: null,

    /**
     * Property: maxzoom
     * {number} 最大层级。
     */
    maxzoom: null,

    /**
     * Property: data
     * {array} GeoJSON文件或内联GeoJSON。
     */
    data: null,

    /**
     * Property: buffer
     * {number} 每边的瓷砖缓冲区大小。
     */
    buffer: null,

    /**
     * Property: tolerance
     * {number} 容差。
     */
    tolerance: null,

    /**
     * Property: cluster
     * {boolean} 集合。
     */
    cluster: null,

    /**
     * Property: clusterRadius
     * {number} 集合半径。
     */
    clusterRadius: null,

    /**
     * Property: clusterMaxZoom
     * {number} 集合级别。
     */
    clusterMaxZoom: null,

    /**
     * Constructor: GeoGlobe.Source.GeoJSONSource
     * GeoGlobe.Layer构造函数。
     *
     * Parameters:
     * options - {Object} 源相关选项设置。
     */

    initialize: function(id,options){
        var sour = {};
        sour.id = id;
        sour.source = options;
        return sour;
    },
    CLASS_NAME: "GeoGlobe.Source.GeoJSONSource"
});

/**
 * Class: GeoGlobe.Source.RasterSource
 * 栅格数据源。
 *
 * Inherits from:
 *  - <GeoGlobe.Source.RasterSource>
 */
GeoGlobe.Source.RasterSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{


    /**
     * Property: minzoom
     * {number} 最小层级。
     */
    minzoom: null,

    /**
     * Property: maxzoom
     * {number} 最大层级。
     */
    maxzoom: null,

    /**
     * Property: tilesUrl
     * {array} 瓦片数据源URL。
     */
    tilesUrl: null,

    /**
     * Property: url
     * {string} 网络地图服务的url。
     */
    url: null,

    /**
     * Property: tileSize
     * {number} 瓦片大小。
     */
    tileSize: null,

    /**
     * Constructor: GeoGlobe.Source.RasterSource
     * GeoGlobe.Source.RasterSource构造函数。
     *
     * Parameters:
     * options - {Object} 源相关选项设置。
     */

    initialize: function(options){
        var source = {
            "id":options.id,
            "type": "raster",
            "tiles": options.url,
            "tileSize": 256
        };
        return source;
    },
    CLASS_NAME: "GeoGlobe.Source.RasterSource"
});

/**
 * Class: GeoGlobe.Source.ImageSource
 * 图片数据源。
 *
 * Inherits from:
 *  - <GeoGlobe.Source.ImageSource>
 */
GeoGlobe.Source.ImageSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{

    /**
     * Property: coordinates
     * {array} 图片指定的坐标。
     */
    coordinates: null,

    /**
     * Property: url
     * {string} 图片的url。
     */
    url: null,

    /**
     * Constructor: GeoGlobe.Source.ImageSource
     * GeoGlobe.Source.ImageSource构造函数。
     *
     * Parameters:
     * options - {Object} 源相关选项设置。
     */

    initialize: function(id,source){
        //options.id = null;
        //var source = {
        //    "type": options.type,
        //    "url": options.url,
        //    "coordinates": options.coordinates
        //};
        var sour = {};
        sour.id = id;
        sour.source = source;
        return sour;
    },
    CLASS_NAME: "GeoGlobe.Source.ImageSource"
});

/**
 * Class: GeoGlobe.Source.VectorSource
 * 矢量数据源。
 *
 * Inherits from:
 *  - <GeoGlobe.Source.VectorSource>
 */
GeoGlobe.Source.VectorSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{


    /**
     * Property: minzoom
     * {number} 最小层级。
     */
    minzoom: null,

    /**
     * Property: maxzoom
     * {number} 最大层级。
     */
    maxzoom: null,

    /**
     * Property: tilesUrl
     * {array} 瓦片数据源URL。
     */
    tilesUrl: null,

    /**
     * Property: url
     * {string} 网络地图服务的url。
     */
    url: null,

    /**
     * Constructor: GeoGlobe.Source.VectorSource
     * GeoGlobe.Source.VectorSource构造函数。
     *
     * Parameters:
     * options - {Object} 源相关选项设置。
     */

    initialize: function(options){
        var source ={
            "id": options.id,
            "type": options.type,
            "tiles": options.url
        };
        return source;
    },
    CLASS_NAME: "GeoGlobe.Source.VectorSource"
});

/**
 * Class: GeoGlobe.Source.VideoSource
 * 图片数据源。
 *
 * Inherits from:
 *  - <GeoGlobe.Source.VideoSource>
 */
GeoGlobe.Source.VideoSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{

    /**
     * Property: coordinates
     * {array} 视频指定的坐标。
     */
    coordinates: null,

    /**
     * Property: url
     * {string} 视频的url。
     */
    url: null,

    /**
     * Constructor: GeoGlobe.Source.VideoSource
     * GeoGlobe.Source.VideoSource构造函数。
     *
     * Parameters:
     * options - {Object} 源相关选项设置。
     */

    initialize: function(id,video){
        //options.id = null;
        //var source = {
        //    "type": options.type,
        //    "url": options.url,
        //    "coordinates": options.coordinates
        //};
        var vid = {};
        vid.id = id;
        vid.video = video;
        return vid;
    },
    CLASS_NAME: "GeoGlobe.Source.VideoSource"
});

/**
 * Class: GeoGlobe.Marker
 * 标记组件类，Marker类实例化一个标记组件，通常被添加到地图容器中。
 *
 * Inherits from:
 *  - <GeoGlobe.Marker>
 */
GeoGlobe.Marker = GeoGlobe.Class(mapboxgl.Marker,{

    /**
     * Property: offset
     * {object} 指定标记的偏移位置。
     */
    offset  : null,

    /**
     * Constructor: GeoGlobe.Marker
     * GeoGlobe.Marker。
     *
     * Parameters:
     * element - {HTMLElement=} DOM element to use as a marker (creates a div element by default)
     * options - {Object} Marker相关选项设置。
     *
     * Examples:
     * var marker = new mapboxgl.Marker()
     * .setLngLat([30.5, 50.5])
     * .addTo(map);
     */
    initialize: function(element, options){
        this.Marker = new mapboxgl.Marker(element, options);
        return this.Marker;
    },

    /**
     * Method: addTo
     * 添加标记。
     *
     * Parameters:
     * map - {GeoGlobe.Map} 地图对象。
     */
    addTo:function(map){
        this.Marker.addTo(map);
    },

    /**
     * Method: remove
     * 移除标记。
     *
     * Examples:
     * var marker = new mapboxgl.Marker().addTo(map);
     * marker.remove();
     */
    remove :function(){
        this.Marker.remove ();
    },

    /**
     * Method: getLngLat
     * 获取标记的坐标。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 标记所在的位置坐标.
     */
    getLngLat:function(){
        return this.Marker.getLngLat();
    },

    /**
     * Method: setLngLat
     * 设置标记的坐标。
     *
     * Parameters:
     * LngLat - {GeoGlobe.LngLat} 设置标记的位置坐标。
     */
    setLngLat:function(LngLat){
        this.Marker.setLngLat(LngLat);
    },

    /**
     * Method: setPopup
     * 设置弹框弹出的文本内容。
     *
     *  Parameters:
     * popup - {[popup]} 绑定标记弹框。
     */
    setPopup :function(popup ){
        this.Marker.setPopup ([popup]);
    },

    /**
     * Method: getPopup
     * 获取绑定到标记的弹出框。
     */
    getPopup :function(){
        this.Marker.getPopup ();
    },

    /**
     * Method: togglePopup
     * 根据当前状态，判断打开或者关闭弹框。
     *
     */
    togglePopup  :function(){
        this.Marker.togglePopup();
    },

    CLASS_NAME: "GeoGlobe.Marker"
});/**
 * Class: GeoGlobe.Popup
 * 弹出式组件类，Popup类实例化一个弹出窗口，通常被添加到地图容器中。
 *
 * Inherits from:
 *  - <GeoGlobe.Popup>
 */
GeoGlobe.Popup = GeoGlobe.Class(mapboxgl.Popup,{

    /**
     * Property: closeButton
     * {Boolaen} 是否显示关闭按钮。
     */
    closeButton : true,

    /**
     * Property: closeOnClick
     * {Boolaen} 点击地图时是否关闭弹出框。
     */
    closeOnClick  : true,

    /**
     * Property: anchor
     * {String} 设置弹出位置。
     */
    anchor  : null,

    /**
     * Property: offset
     * {object} 指定弹框的偏移位置。
     */
    offset  : null,
    
    /**
     * Property: showArrow
     * {boolean} 是否显示箭头。默认为true
     */
    showArrow  : true,
    

    /**
     * Constructor: GeoGlobe.Popup
     * GeoGlobe.Popup构造函数。
     *
     * Parameters:
     * options - {Object} Popup相关选项设置。
     */
    initialize: function(options){
        this.Popup = new mapboxgl.Popup(options);
        return this.Popup;
    },

    /**
     * Method: addTo
     * 添加弹出框。
     *
     * Parameters:
     * map - {GeoGlobe.Map} 地图对象。
     */
    addTo:function(map){
        this.Popup.addTo(map);
    },

    /**
     * Method: isOpen
     * 弹框是否打开。
     *
     * returns:
     * true - {boolean} true弹框打开，false弹框关闭.
     */
    isOpen:function(){
        return this.Popup.isOpen();
    },

    /**
     * Method: remove
     * 移除弹出框。
     *
     * Examples:
     * var popup = new GeoGlobe.Popup().addTo(map);
     * popup.remove();
     */
    remove :function(){
        this.Popup.remove ();
    },

    /**
     * Method: getLngLat
     * 获取弹框的坐标。
     *
     * returns:
     * LngLat - {GeoGlobe.LngLat} 返回弹框所在的位置坐标.
     */
    getLngLat:function(){
       return this.Popup.getLngLat();
    },

    /**
     * Method: setLngLat
     * 设置弹框的坐标。
     *
     * Parameters:
     * LngLat - {GeoGlobe.LngLat} 设置弹框的位置坐标。
     */
    setLngLat:function(LngLat){
        this.Popup.setLngLat(LngLat);
    },

    /**
     * Method: setText
     * 设置弹框弹出的文本内容。
     *
     *  Parameters:
     * text - {string} 弹框弹出的文本内容。
     *
     * Examples:
     * var popup = new mapboxgl.Popup()
     * .setLngLat(e.lngLat)
     * .setText('Hello, world!')
     * .addTo(map);
     */
    setText :function(text ){
        this.Popup.setText (text);
    },

    /**
     * Method: setHTML
     * 移除控件。
     *
     * Parameters:
     * html - {string} 弹框弹出的html内容。
     *
     * Examples：
     * var popup = new mapboxgl.Popup()
     *.setLngLat(e.lngLat)
     *.setHTML("<h1>Hello World!</h1>")
     *.addTo(map);
     */
    setHTML :function(html){
        this.Popup.setHTML (html);
    },

    /**
     * Method: setDOMContent
     * 移除控件。
     *
     * Parameters:
     * htmlNode  - {Node} 弹框弹出的html内容。
     *
     * Examples:
     * //创建弹出框元素内容
     * var div = window.document.createElement('div');
     * div.innerHTML = 'Hello, world!';
     *  var popup = new mapboxgl.Popup()
     * .setLngLat(e.lngLat)
     * .setDOMContent(div)
     * .addTo(map);
     */
    setDOMContent :function(htmlNode ){
        this.Popup.setDOMContent (htmlNode );
    },

    CLASS_NAME: "GeoGlobe.Popup"
});/**
 * Class: GeoGlobe.Control
 * 控件类，通过监听并响应用户操作来改变地图状态、操作图层数据或完成某一动作。
 *
 * Inherits from:
 *  - <GeoGlobe.Control>
 */
GeoGlobe.Control = GeoGlobe.Class(mapboxgl.Control,{

    /**
     * Property: position
     * {String} 控件位置。
     */
    position: null,

    /**
     * Constructor: GeoGlobe.Control
     * GeoGlobe.Control构造函数。
     *
     * Parameters:
     * options - {Object} WMS相关选项设置。
     */
    initialize: function(options){
        var position = options.position;
        this.control = new mapboxgl.Control(options);
        return this.control;
    },

    /**
     * Method: addTo
     * 添加控件。
     *
     * Parameters:
     * map - {GeoGlobe.Map} 地图对象。
     */
    addTo:function(map){
        this.control.addTo(map);
    },

    /**
     * Method: remove
     * 移除控件。
     */
    remove:function(){
        this.control.remove();
    },
    CLASS_NAME: "GeoGlobe.Control"
});/**
 * Class: GeoGlobe.Control.Navigation
 * 导航控件类，为二维地图提供导航件组合控件功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Control>
 */
GeoGlobe.Control.Navigation = GeoGlobe.Class(GeoGlobe.Control,{

    /**
     * Property: position
     * {String} 控件位置。
     */
    position: null,

    /**
     * Constructor: GeoGlobe.Control.Navigation
     * GeoGlobe.Control构造函数。
     *
     * Parameters:
     * options - {Object} Navigation相关选项设置。
     */
    initialize: function(){
        this.control = new mapboxgl.NavigationControl();
        return this.control;
    },
    CLASS_NAME: "GeoGlobe.Control.Navigation"
});
/**
 * Class: GeoGlobe.Control.Attribution
 * 属性控件类，为二维地图提供当前图层属性信息功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Control>
 */
GeoGlobe.Control.Attribution = GeoGlobe.Class(GeoGlobe.Control,{

    /**
     * Property: position
     * {String} 控件位置。
     */
    position: null,

    /**
     * Constructor: GeoGlobe.Control.Attribution
     * GeoGlobe.Control构造函数。
     *
     * Parameters:
     * options - {Object} Attribution相关选项设置。
     */
    initialize: function(options){
        this.control = new mapboxgl.AttributionControl({
            position: options.position,
            map_attr:options.map_attr
        });

        return this.control;
    },
    CLASS_NAME: "GeoGlobe.Control.Attribution"
});

/**
 * Class: GeoGlobe.Control.Scale
 * 比例尺控件类，为二维地图提供比例尺功能，实例是显示当前地图的比例尺。
 */
GeoGlobe.Control.Scale = GeoGlobe.Class4OL({

    /**
     * Constructor: GeoGlobe.Control.Scale
     * GeoGlobe.Control构造函数。
     *
     * Parameters:
     * options - {Object} Scale相关选项设置。属性可为:
	 * 		position - {String} (可选) 默认为"bottom-left"，表示左下。
	 * 		maxWidth - {Integer} (可选) 比例尺宽度。
	 * 		unit - {String} (可选) 比例尺单位。"metric"或"imperial"
     */
    initialize: function(options){
		this.options = options;
        mapboxgl.util.bindAll([
            '_onMove'
        ], this);
    },
	
	getDefaultPosition: function(){
        return 'bottom-left';
    },
	
	_onMove: function(){
        this._updateScale(this._map, this._container, this.options);
    },
	
	onAdd: function(map){
        this._map = map;
        this._container = GeoGlobe.DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-scale', map.getContainer());

        this._map.on('move', this._onMove);
        this._onMove();

        return this._container;
    },

    onRemove: function(){
        this._container.parentNode.removeChild(this._container);
        this._map.off('move', this._onMove);
        this._map = undefined;
    },
	
	
	
	
	_updateScale: function(map, container, options){
		// A horizontal scale is imagined to be present at center of the map
	    // container with maximum length (Default) as 100px.
	    // Using spherical law of cosines approximation, the real distance is
	    // found between the two coordinates.
	    var maxWidth = options && options.maxWidth || 100;
	
	    var y = map._container.clientHeight / 2;
	    var maxMeters = this._getDistance(map.unproject([0, y]), map.unproject([maxWidth, y]));
	    // The real distance corresponding to 100px scale length is rounded off to
	    // near pretty number and the scale length for the same is found out.
	    // Default unit of the scale is based on User's locale.
	    if (options && options.unit === 'imperial') {
	        var maxFeet = 3.2808 * maxMeters;
	        if (maxFeet > 5280) {
	            var maxMiles = maxFeet / 5280;
	            this._setScale(container, maxWidth, maxMiles, 'mi');
	        } else {
	            this._setScale(container, maxWidth, maxFeet, 'ft');
	        }
	    } else {
	        this._setScale(container, maxWidth, maxMeters, 'm');
	    }
	},
	
	_setScale: function(container, maxWidth, maxDistance, unit){
		//取整数，第一位不变，其他位全为0。比如1000000
		var distance = this._getRoundNum(maxDistance);
	    var ratio = distance / maxDistance;
	
	    if (unit === 'm' && distance >= 1000) {
	        distance = distance / 1000;
	        unit = 'km';
	    }
	    container.style.width = (maxWidth * ratio) + "px";
	    container.innerHTML = distance + unit;
	},
	
	_getDistance: function(latlng1, latlng2){
		var maxMeters = null;
		//单位的"m"的情况
		if(this._map.units === "m"){
			maxMeters = latlng2.lng - latlng1.lng;
		}else{
			//默认单位是度"degrees"的情况
			// Uses spherical law of cosines approximation.
		    var R = 6371000;
		
		    var rad = Math.PI / 180,
		        lat1 = latlng1.lat * rad,
		        lat2 = latlng2.lat * rad,
		        a = Math.sin(lat1) * Math.sin(lat2) +
		          Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);
		
		    maxMeters = R * Math.acos(Math.min(a, 1));
		}
		
	    return maxMeters;
	},
	
	_getRoundNum: function(num){
		var pow10 = Math.pow(10, (("" + (Math.floor(num)))).length - 1);
	    var d = num / pow10;
	
	    d = d >= 10 ? 10 :
	        d >= 5 ? 5 :
	        d >= 3 ? 3 :
	        d >= 2 ? 2 : 1;
	
	    return pow10 * d;
	},
	
    CLASS_NAME: "GeoGlobe.Control.Scale"
});

/**
 * Class: GeoGlobe.Control.Geolocate
 * 定位控件类，为二维地图提供地理定位功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Control>
 */
GeoGlobe.Control.Geolocate = GeoGlobe.Class(GeoGlobe.Control,{

    /**
     * Property: position
     * {String} 控件位置。
     */
    position: null,

    /**
     * Constructor: GeoGlobe.Control.Geolocate
     * GeoGlobe.Control构造函数。
     *
     * Parameters:
     * options - {Object} Geolocate相关选项设置。
     */
    initialize: function(options){
        this.control = new mapboxgl.GeolocateControl ({
            position: options.position,
            point:options.point
        });
        return this.control;
    },
    CLASS_NAME: "GeoGlobe.Control.Geolocate"
});


/**
 * Class: GeoGlobe.Control.MapContextMenu
 * 地图右键菜单控件类。
 *
 */
GeoGlobe.Control.MapContextMenu = GeoGlobe.Class4OL({

    /** 
     * APIProperty: menuDiv
     * {DOMElement} 地图右键菜单div。
     */
    menuDiv: null,
	
	/** 
     * APIProperty: className
     * {String} 地图右键菜单menuDiv的样式名。
     */
	className: null,
    
    /** 
     * APIProperty: contentHTML
     * {String} 鼠标右键地图菜单的内容。
     */
    contentHTML: null,
	
    /** 
     * APIProperty: lngLat
     * {<GeoGlobe.LngLat>} 右键点击的地图坐标信息。
     */
    lngLat: null,
	
    /** 
     * APIProperty: point
     * {<GeoGlobe.Point>} 右键点击的地图屏幕坐标信息。
     */
    point: null,
    
    /**
     * Constructor: GeoGlobe.Control.MapContextMenu
     * 鼠标右键地图菜单控件的构造函数。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
		GeoGlobe.Util.extend(this, options);
    },
	
	getDefaultPosition: function(map){
        return 'top-left';
    },
	
    onAdd: function(map){
		this._map = map;
		
		//绑定右键菜单事件
		//var mapdiv = this._map.getCanvasContainer();
		//this._onContextMenu = GeoGlobe.Function.bind(this._showContextMenu, this);
		//mapdiv.addEventListener('contextmenu', this._onContextMenu);//原生
		this._onContextMenu = GeoGlobe.Function.bind(this._showContextMenu, this);
		this._map.on("contextmenu", this._onContextMenu);
		this._onMouseDown = GeoGlobe.Function.bind(this.hide, this);
		this._map.on("mousedown", this._onMouseDown);
		
		//创建地图右键菜单div
		this._container = this._createContainer();
		return this._container;
	},
	
	/**
     * Method: _createContainer
     * 
     * Returns:
     * {DOMElement}
     */
    _createContainer: function(){
		var menu = window.document.createElement('div');
		menu.className = "mapboxgl-ctrl";
		if (this.className) {
			menu.classList.add(this.className);
		}
		
        menu.style.position = "absolute";
        menu.style.background = "white";
        menu.style.border = "1px solid #adbfe4";
        menu.style.zIndex = 2;
        menu.innerHTML = this.contentHTML ? this.contentHTML : "";
        this.menuDiv = menu;
		this.menuDiv.onmousedown = GeoGlobe.Function.bind(function(){
			//火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        	var evt = arguments[0] || event;
			evt.preventDefault();
			if(event.stopPropagation){
	        	event.stopPropagation();
	        }
        }, this);
        this.hide();
        return menu;
    },
	
    /**
     * Method: showContextMenu
     * 点击右键在地图上显示菜单。
     */
	_showContextMenu: function(evt){
		this.lngLat = evt.lngLat;
		this.point = evt.point;
		this.menuDiv.style.left = evt.point.x + "px";
        this.menuDiv.style.top = evt.point.y + "px";
        this.show();
	},
	/*
    _showContextMenu: function(evt){//原生
		var mapdiv = this._map.getCanvasContainer();
		this.point = this.mousePos(mapdiv, evt);
		this.lngLat = this._map.unproject(this.point);
        this.menuDiv.style.left = evt.layerX + "px";
        this.menuDiv.style.top = evt.layerY + "px";
        this.show();
    },*/
	
	onRemove: function(){
		this._container.parentNode.removeChild(this._container);
		//var mapdiv = this._map.getCanvasContainer();
		//mapdiv.removeEventListener('contextmenu', this._onContextMenu);//原生
		
		this._map.off('contextmenu', this._onContextMenu);
		this._map.off('mousedown', this._onMouseDown);
		
		this.menuDiv = null;
		this._container = null;
		this.contentHTML = null;
		this._map = undefined;
	},
	
	/**
     * Method: show
     * 显示右键菜单。
     */
    show: function(){
        if (this.menuDiv && this.menuDiv.style.display == "none") {
            this.menuDiv.style.display = "";
        }
    },
    
    /**
     * Method: hide
     * 隐藏右键菜单。
     */
    hide: function(){
        if (this.menuDiv && this.menuDiv.style.display != "none") {
            this.menuDiv.style.display = "none";
        }
    },
    
    /**
     * APIMethod: setContentHTML
     * 设置右键菜单的内容。
     *
     * Parameters:
     * contentHTML - {String} 右键菜单的HTML字符串。
     */
    setContentHTML: function(contentHTML){
        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
        if ((this.menuDiv != null) && (this.contentHTML != null) &&
        (this.contentHTML != this.menuDiv.innerHTML)) {
            this.menuDiv.innerHTML = this.contentHTML;
        }
    },
	
    /**
     * APIMethod: addItem
     * 添加菜单选项。
     * 
     * Parameters:
     * menuItem - {<Geo.View2D.MenuItem>} 鼠标右键地图菜单选项。
     */
    addItem: function(menuItem){
        var itemDiv = document.createElement("div");
		itemDiv.id = menuItem.id;
        itemDiv.style.cssText = "padding-bottom: 2px; line-height: 17px; margin: 0px 2px; padding-left: 6px; width:" + menuItem.width + "px; padding-right: 6px; color: #000; font-size: 12px; cursor: pointer; padding-top: 2px;";
		itemDiv.innerHTML = "<span>" + menuItem.text + "</span>";
		itemDiv.onclick = GeoGlobe.Function.bind(function(){
			var evtObj = {
				target: menuItem,
				control: this,
				map: this._map,
				lngLat: this.lngLat,
				point: this.point
			};
			menuItem.callback(evtObj);
			this.hide();
        }, this);
		itemDiv.onmouseover = function(){
			itemDiv.style.color = "#6688cc";
		}
		itemDiv.onmouseout = function(){
			itemDiv.style.color = "#000";
		}
        this.menuDiv.appendChild(itemDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
    },
	
    /**
     * APIMethod: addSeparator
     * 添加菜单的分割线。
     */
	addSeparator: function(){
		var separatorDiv = document.createElement("div");
        separatorDiv.style.cssText = "border-bottom:#adbfe4 1px solid;margin:0px 6px;font-size:0px;padding:1px";
		this.menuDiv.appendChild(separatorDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
	},
	
    /**
     * 鼠标事件对象转地图屏幕点。
     *
     * Parameters:
     * el - {DOMElement} mapdiv。
     * e - {Object} 鼠标事件。
     */
	mousePos: function(el, e){
	    var rect = el.getBoundingClientRect();
	    return new GeoGlobe.Point(
	        e.clientX - rect.left - el.clientLeft,
	        e.clientY - rect.top - el.clientTop
	    );
	},
    
    CLASS_NAME: "GeoGlobe.View2D.Control.MapContextMenu"
});

/**
 * Class: GeoGlobe.MenuItem
 * 地图右键菜单选项类。
 */
GeoGlobe.MenuItem = GeoGlobe.Class4OL({
	
    /**
     * Property: id
     * {String} 唯一标识。
     */
	id: null,
	
    /**
     * APIProperty: text
     * {String} 菜单项显示的文本。
     */
    text: null,

    /**
     * APIProperty: callback
     * {Function} 回调函数。
     */
    callback: null,

    /**
     * APIProperty: width
     * {String} 菜单项长度。默认值为100px。
     */
	width: 100,
	
    /**
     * Constructor: GeoGlobe.MenuItem
     * 鼠标右键地图菜单选项的构造函数。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
		this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
		GeoGlobe.Util.extend(this, options);
    },
	
	
    /**
     * APIMethod: setText
     * 设置菜单项显示的文本。
     *
     * Parameters:
     * text - {String} 菜单项显示的文本。
     */
	setText: function(text){
		this.text = text;
	},
	
    CLASS_NAME: "GeoGlobe.MenuItem"
});
/**
 * Class: GeoGlobe.event
 * 事件管理类。
 *
 * Inherits from:
 *  - <GeoGlobe.Event>
 */
GeoGlobe.Event = GeoGlobe.Class(mapboxgl.Evented,{
    /**
     * Constructor: GeoGlobe.Event
     * GeoGlobe.Event构造函数。
     *
     * Parameters:
     * options - {Object} Event相关选项设置。
     */
    initialize: function(){
        this.Event = mapboxgl.Evented;
        return this.Event;
    },
    CLASS_NAME: "GeoGlobe.Event"
});/**
 * Class: GeoGlobe.event.mapMouseEvent
 * 鼠标事件类，为二维地图提供地图鼠标事件。
 *
 * Inherits from:
 *  - <GeoGlobe.Event>
 */
GeoGlobe.Event.MapMouseEvent = GeoGlobe.Class(GeoGlobe.Event,{

    /**
     * Property: target
     * {string} 事件目标。
     */
    target: null,

    /**
     * Constructor: GeoGlobe.Event.MapMouseEvent
     * GeoGlobe.MapMouseEvent构造函数。
     *
     * Parameters:
     * options - {Object} MapMouseEvent相关选项设置。
     */
    initialize: function(map){
        this.el = map.getCanvasContainer();
        var contextMenuEvent = null;
        this.map = map;
        var startPos = null;
        var tapped = null;
        var popup = new GeoGlobe.Popup({
            closeButton: false,
            closeOnClick: false
        });
        var handlers = {
            scrollZoom: map.scrollZoom,
            boxZoom:map.boxZoom,
            dragRotate: map.scrollZoom,
            dragPan:map.dragRotate,
            doubleClickZoom:map.doubleClickZoom
        };
        //给鼠标事件添加监听
        this.el.addEventListener('mouseout', this.onMouseOut, false);
        this.el.addEventListener('mousedown', this.onMouseDown, false);
        this.el.addEventListener('mouseup', this.onMouseUp, false);
        this.el.addEventListener('mousemove', this.onMouseMove, false);
        this.el.addEventListener('click', this.sigleClick, false);
        this.el.addEventListener('dblclick', this.doubleClick, false);
        this.el.addEventListener('contextmenu', this.onContextMenu, false);

        this.onMouseOut = function() {
            map.on('mouseout',function(e){
                alert("out");
                //fireMouseEvent('mouseout', e);
            })
        };


        this.onMouseDown = function() {
            map.stop();

            map.on('mousedown',function(e){
                alert("down");
                //startPos = GeoGlobe.DOM.mousePos(this.el, e);
                //fireMouseEvent('mousedown', e);
            })
        };


        this.onMouseUp = function() {

            var rotating = map.dragRotate && map.dragRotate.isActive();
            map.on('mouseup',function(e){
                alert("up");
            })

        };
        this.onMouseMove = function() {
            if (map.dragPan && map.dragPan.isActive()) return;
            if (map.dragRotate && map.dragRotate.isActive()) return;
            var info;
            map.on('mousemove',function(e){
                //fireMouseEvent('mousemove', e);
                var info =
                    JSON.stringify(e.point) + '<br />' +
                    JSON.stringify(e.lngLat);
                popup.setLngLat([e.lngLat.lng,e.lngLat.lat])
//                    .setHTML(JSON.stringify(e), e.lngLat)
                    .setHTML(info)
                    .addTo(map);
            });
            return info;
        };

        this.sigleClick = function(){
            map.on('click',function(e){
                alert("sigle");

            });
        };

        this.doubleClick  = function() {
            map.on('dblclick',function(e){
                alert("double");
            })
        };

        this.onContextMenu = function(e) {
            contextMenuEvent = e;
            e.preventDefault();
        };

        this.remove = function(rem){
            switch (rem){
                case 'mouseout':
                    this.el.removeEventListener('mouseout', this.onMouseMove);
                    this.map._listeners['mouseout'].splice(0, 1);

                    break;
                case 'mousemove':
                    this.el.removeEventListener('mousemove', this.onMouseMove);
                    popup.remove();
                    this.map._listeners['mousemove'].splice(0, 1);

                    break;
                case 'mousedown':
                    this.el.removeEventListener('mousedown', this.onMouseDown);
                    this.map._listeners['mousedown'].splice(0, 1);

                    break;
                case 'mouseup':
                    this.el.removeEventListener('mouseup', this.onMouseUp);
                    this.map._listeners['mouseup'].splice(0, 1);

                    break;
                case 'dblclick':
                    this.el.removeEventListener('dblclick', this.doubleClick);
                    this.map._listeners['dblclick'].splice(0, 1);

                    break;
                case 'click':
                    this.el.removeEventListener('click', this.sigleClick);
                    this.map._listeners['click'].splice(0, 1);
                    break;
                default :
                    break;

            }
        };

        function fireMouseEvent(type, e) {
            var pos = GeoGlobe.DOM.mousePos(el, e);

            return map.fire(type, {
                lngLat: map.unproject(pos),
                point: pos,
                originalEvent: e
            });
        }
        return this;
    },

    /**
     * Method: onMouseOut
     * 鼠标移出事件。
     *
     * Parameters:
     * ev - {string}mouseout。
     */
    onMouseOut:function(){
    },

    /**
     * Method: onMouseDown
     * 鼠标按下事件。
     *
     * Parameters:
     * ev - {string}mousedown。
     */
    onMouseDown:function() {
    },

    /**
     * Method: onMouseUp
     * 鼠标弹起事件。
     *
     * Parameters:
     * ev - {string}mouseup。
     */
    onMouseUp:function() {
    },

    /**
     * Method: onMouseMove
     * 鼠标移动事件。
     *
     * Parameters:
     * ev - {string}mousemove。
     */
    onMouseMove:function() {
    },

    /**
     * Method: sigleClick
     * 鼠标单击事件。
     *
     * Parameters:
     * ev - {string}click。
     */
    sigleClick : function(){
    },

    /**
     * Method: doubleClick
     * 鼠标双击事件。
     *
     * Parameters:
     * ev - {string}dblclick。
     */
    doubleClick  : function() {
        map.on('dblclick',function(e){
            alert("double");
        })
    },

    onContextMenu : function(e) {
        contextMenuEvent = e;
        e.preventDefault();
    },

    /**
     * Method: remove
     * 鼠标事件移除。
     *
     * Parameters:
     * mouseout：{string}鼠标移出
     * mousemove：{string}鼠标移动
     * mousedown：{string}鼠标按下
     * mouseup：{string}鼠标弹起
     * dblclick：{string}鼠标双击
     * click：{string}鼠标单击
     */
    remove : function(rem){
        switch (rem){
            case 'mouseout':
                this.el.removeEventListener('mouseout', this.onMouseMove);
                this.map._listeners['mouseout'].splice(0, 1);

                break;
            case 'mousemove':
                this.el.removeEventListener('mousemove', this.onMouseMove);
                popup.remove();
                this.map._listeners['mousemove'].splice(0, 1);

                break;
            case 'mousedown':
                this.el.removeEventListener('mousedown', this.onMouseDown);
                this.map._listeners['mousedown'].splice(0, 1);

                break;
            case 'mouseup':
                this.el.removeEventListener('mouseup', this.onMouseUp);
                this.map._listeners['mouseup'].splice(0, 1);

                break;
            case 'dblclick':
                this.el.removeEventListener('dblclick', this.doubleClick);
                this.map._listeners['dblclick'].splice(0, 1);

                break;
            case 'click':
                this.el.removeEventListener('click', this.sigleClick);
                this.map._listeners['click'].splice(0, 1);
                break;
            default :
                break;

        }
    },
    CLASS_NAME: "GeoGlobe.Event.MapMouseEvent"
});

//initialize: function(map){
//    var el = map.getCanvasContainer();
//    var contextMenuEvent = null;
//    var startPos = null;
//    var tapped = null;
//    this.el = el;
//    this.map = map;
//    this.startPos = startPos;
//    this.contextMenuEvent = contextMenuEvent
//    var handlers = {
//        scrollZoom: map.scrollZoom,
//        boxZoom:map.boxZoom,
//        dragRotate: map.scrollZoom,
//        dragPan:map.dragRotate,
//        doubleClickZoom:map.doubleClickZoom
//    };
//
//    //el.addEventListener('contextmenu', this.onContextMenu, false);
//
//    return this;
//},
//
//onMouseOut: function(e){
//    this.el.addEventListener('mouseout', this.onMouseOut, false);
//
//    alert("555");
//    this.fireMouseEvent('mouseout', e);
//},
//
//onMouseDown: function(e){
//    this.el.addEventListener('mousedown', this.onMouseDown, false);
//
//    this.map.stop();
//    this.startPos = GeoGlobe.DOM.mousePos(this.el, e);
//    this.fireMouseEvent('mousedown', e);
//},
//
//onMouseUp: function(e){
//    this.el.addEventListener('mouseup', this.onMouseUp, false);
//
//    alert("444");
//    var rotating = this.map.dragRotate && this.map.dragRotate.isActive();
//
//    if ( this.contextMenuEvent && !rotating) {
//        this.fireMouseEvent('contextmenu',  this.contextMenuEvent);
//    }
//
//    this.contextMenuEvent = null;
//    this.fireMouseEvent('mouseup', e);
//},
//
//onMouseMove: function(e){
//    this.el.addEventListener('mousemove', this.onMouseMove, false);
//
//    //var map = this.map;
//    alert("333");
//    if (this.map.dragPan && this.map.dragPan.isActive()) return;
//    if (map.dragRotate && map.dragRotate.isActive()) return;
//
//    var target = e.toElement || e.target;
//    while (target && target !== el) target = target.parentNode;
//    if (target !== el) return;
//
//    this.fireMouseEvent('mousemove', e);
//},
//
//OnClick: function(e){
//    this.el.addEventListener('click', this.OnClick, false);
//
//    alert('111');
//    var pos = GeoGlobe.DOM.mousePos(this.el, e);
//
//    if (pos.equals(this.startPos)) {
//        this.fireMouseEvent('click', e);
//    }
//},
//
//OnDblClick: function(e){
//    this.el.addEventListener('dblclick', this.OnDblClick, false);
//
//    alert("222");
//    this.fireMouseEvent('dblclick', e);
//    e.preventDefault();
//},
//
//fireMouseEvent: function(type, e){
//    var pos = GeoGlobe.DOM.mousePos(this.el, e);
//
//    return map.fire(type, {
//        lngLat: map.unproject(pos),
//        point: pos,
//        originalEvent: e
//    });
//},
//
//onContextMenu: function(e){
//    this.contextMenuEvent = e;
//    e.preventDefault();
//}
// ,
/**
 * Class: GeoGlobe.event.mapMouseEvent
 * 触摸事件类，为二维地图提供地图触摸事件。
 *
 * Inherits from:
 *  - <GeoGlobe.Event>
 */
GeoGlobe.Event.MapTouchEvent = GeoGlobe.Class(GeoGlobe.Event,{

    /**
     * Property: target
     * {string} 事件目标。
     */
    target: null,

    /**
     * Constructor: GeoGlobe.Event.MapTouchEvent
     * GeoGlobe.MapTouchEvent构造函数。
     *
     * Parameters:
     * options - {Object} MapTouchEvent相关选项设置。
     */
    initialize: function(map){
        this.el = map.getCanvasContainer();
        this.map = map;
        var startPos = null;
        var tapped = null;
        var handlers = {
            scrollZoom: map.scrollZoom,
            boxZoom:map.boxZoom,
            dragRotate: map.scrollZoom,
            dragPan:map.dragRotate,
            touchZoomRotate: map.touchZoomRotate,
            doubleClickZoom:map.doubleClickZoom
        };

        //给鼠标事件添加监听
        this.el.addEventListener('touchstart', this.onTouchStart, false);
        this.el.addEventListener('touchend', this.onTouchEnd, false);
        this.el.addEventListener('touchmove', this.onTouchMove, false);
        this.el.addEventListener('touchcancel', this.onTouchCancel, false);
        this.el.addEventListener('dblclick', this.doubleClick, false);

        this.onTouchStart = function(e) {
            map.stop();
            alert("xxfds");
            //fireTouchEvent('touchstart', e);
            map.on('touchstart',function(e){
                alert("double1");
                if (!e.touches || e.touches.length > 1) return;
            });

            if (!tapped) {
                tapped = setTimeout(this.onTouchTimeout, 300);

            } else {
                clearTimeout(tapped);
                tapped = null;
                //fireMouseEvent('dblclick', e);
                map.on('dblclick',function(e){
                    alert("double2");
                });
            }
        };

        this.onTouchMove = function(e) {
            //fireTouchEvent('touchmove', e);
            alert("xcsx");
            map.on('touchmove',function(e){
                alert("double3");
            });
        };

        this.onTouchEnd = function(e) {
            //fireTouchEvent('touchend', e);
            alert("xfx");
            map.on('touchend',function(e){
                alert("double4");
            });
        };

        this.onTouchCancel = function(e) {
            //fireTouchEvent('touchcancel', e);
            alert("xx");
            map.on('touchcancel',function(e){
                alert("double5");
            });
        };

        this.onTouchTimeout = function() {
            tapped = null;
        };
        this.doubleClick  = function(ev) {
            map.on(ev,function(e){
                alert("double");
            })
        };

        this.remove = function(rem){
            switch (rem){
                case 'touchstart':
                    this.el.removeEventListener('touchstart', this.onMouseMove);
                    this.map._listeners['touchstart'].splice(0, 1);

                    break;
                case 'touchmove':
                    this.el.removeEventListener('touchmove', this.onMouseMove);
                    popup.remove();
                    this.map._listeners['touchmove'].splice(0, 1);

                    break;
                case 'touchend':
                    this.el.removeEventListener('touchend', this.onMouseDown);
                    this.map._listeners['touchend'].splice(0, 1);

                    break;
                case 'touchcancel':
                    this.el.removeEventListener('touchcancel', this.onMouseUp);
                    this.map._listeners['touchcancel'].splice(0, 1);

                    break;
                case 'dblclick':
                    //map.off('click')
                    this.el.removeEventListener('dblclick', this.touchcancel);
                    this.map._listeners['dblclick'].splice(0, 1);
                    break;
                default :
                    break;

            }
        };
        return this;
    },

    /**
     * Method: onTouchStart
     * 触摸开始事件。
     *
     * Parameters:
     * ev - {string}touchstart。
     */
    onTouchStart : function() {
        map.stop();
        alert("xxfds");
        //fireTouchEvent('touchstart', e);
        map.on('touchstart',function(e){
            alert("double1");
            if (!e.touches || e.touches.length > 1) return;
        });

        if (!tapped) {
            tapped = setTimeout(this.onTouchTimeout, 300);

        } else {
            clearTimeout(tapped);
            tapped = null;
            //fireMouseEvent('dblclick', e);
            map.on('dblclick',function(e){
                alert("double2");
            });
        }
    },

    /**
     * Method: onTouchMove
     * 触摸移动事件。
     *
     * Parameters:
     * ev - {string}touchmove。
     */
    onTouchMove : function() {
        //fireTouchEvent('touchmove', e);
        alert("xcsx");
        map.on('touchmove',function(e){
            alert("double3");
        });
    },
    /**
     * Method: onTouchEnd
     * 触摸结束事件。
     *
     * Parameters:
     * ev - {string}touchend。
     */
    onTouchEnd : function() {
        //fireTouchEvent('touchend', e);
        alert("xfx");
        map.on('touchend',function(e){
            alert("double4");
        });
    },

    /**
     * Method: onTouchCancel
     * 触摸取消事件。
     *
     * Parameters:
     * ev - {string}touchcancel。
     */
    onTouchCancel : function() {
        //fireTouchEvent('touchcancel', e);
        alert("xx");
        map.on('touchcancel',function(e){
            alert("double5");
        });
    },

    /**
     * Method: onTouchTimeout
     * 触摸延时。
     *
     */
    onTouchTimeout : function() {
        tapped = null;
    },
    /**
     * Method: remove
     * 触摸事件移除。
     *
     * Parameters:
     * touchstart：触摸开始
     * touchmove：触摸移动
     * touchend：触摸结束
     * touchcancel：触摸取消
     * dblclick：鼠标双击
     */
    remove : function(rem){
        switch (rem){
            case 'touchstart':
                this.el.removeEventListener('touchstart', this.onMouseMove);
                this.map._listeners['touchstart'].splice(0, 1);

                break;
            case 'touchmove':
                this.el.removeEventListener('touchmove', this.onMouseMove);
                popup.remove();
                this.map._listeners['touchmove'].splice(0, 1);

                break;
            case 'touchend':
                this.el.removeEventListener('touchend', this.onMouseDown);
                this.map._listeners['touchend'].splice(0, 1);

                break;
            case 'touchcancel':
                this.el.removeEventListener('touchcancel', this.onMouseUp);
                this.map._listeners['touchcancel'].splice(0, 1);

                break;
            case 'dblclick':
                //map.off('click')
                this.el.removeEventListener('dblclick', this.touchcancel);
                this.map._listeners['dblclick'].splice(0, 1);
                break;
            default :
                break;

        }
    },
    CLASS_NAME: "GeoGlobe.Event.MapTouchEvent"
});

/**
 * Class: GeoGlobe.event.mapDataEvent
 * 鼠标事件类，为二维地图提供地图鼠标事件。
 *
 * Inherits from:
 *  - <GeoGlobe.Event.mapDataEvent>
 */
GeoGlobe.Event.mapDataEvent = GeoGlobe.Class(GeoGlobe.Event,{

    /**
     * Property: type
     * {string} 事件类型。
     */
    type: null,

    /**
     * Property: datatype
     * {string} 数据类型。
     */
    datatype: null,

    /**
     * Constructor: GeoGlobe.Event.mapDataEvent
     * GeoGlobe.MapMouseEvent构造函数。
     *
     * Parameters:
     * options - {Object} mapDataEvent相关选项设置。
     */
    initialize: function(map){
        return this;
    },
    CLASS_NAME: "GeoGlobe.Event.mapDataEvent"
});
/**
 * Class: GeoGlobe.event.mapBoxZoomEvent
 * 鼠标事件类，为二维地图提供地图鼠标事件。
 *
 * Inherits from:
 *  - <GeoGlobe.Event>
 */
GeoGlobe.Event.mapBoxZoomEvent = GeoGlobe.Class(GeoGlobe.Event,{

    /**
     * Property: target
     * {string} 事件目标。
     */
    target: null,

    /**
     * Property: boxZoomBounds
     * {LngLatbounds} 范围。
     */
    boxZoomBounds : null,

    /**
     * Constructor: GeoGlobe.Event.mapBoxZoomEvent
     * GeoGlobe.MapMouseEvent构造函数。
     *
     * Parameters:
     * options - {Object} mapBoxZoomEvent相关选项设置。
     */
    initialize: function(map){
        this.el = map.getCanvasContainer();
        var contextMenuEvent = null;
        this.map = map;
        var startPos = null;
        var tapped = null;
        var popup = new GeoGlobe.Popup({
            closeButton: false,
            closeOnClick: false
        });
        var handlers = {
            scrollZoom: map.scrollZoom,
            boxZoom:map.boxZoom,
            dragRotate: map.scrollZoom,
            dragPan:map.dragRotate,
            doubleClickZoom:map.doubleClickZoom
        };
        //给鼠标事件添加监听
        this.el.addEventListener('keydown', this.onKeyDown, false);
        this.el.addEventListener('mousedown', this.onMouseDown, false);
        this.el.addEventListener('mouseup', this.onMouseUp, false);
        this.el.addEventListener('mousemove', this.onMouseMove, false);
        //this.el.addEventListener('contextmenu', this.onContextMenu, false);

        this.onKeyDown = function() {
            map.on('keydown',function(e){
                alert("keydown");
                //fireMouseEvent('mouseout', e);
            })
        };

        this.onMouseDown = function() {
            map.stop();

            map.on('mousedown',function(e){
                alert("down");
                startPos = GeoGlobe.DOM.mousePos(this.el, e);
                //fireMouseEvent('mousedown', e);
            })
        };


        this.onMouseUp = function() {
            var rotating = map.dragRotate && map.dragRotate.isActive();
            map.on('mouseup',function(e){
                alert("up");
            })

        };
        this.onMouseMove = function() {
            if (map.dragPan && map.dragPan.isActive()) return;
            if (map.dragRotate && map.dragRotate.isActive()) return;
            var info;
            map.on('mousemove',function(e){
                //fireMouseEvent('mousemove', e);
                var info =
                    JSON.stringify(e.point) + '<br />' +
                    JSON.stringify(e.lngLat);
                popup.setLngLat([e.lngLat.lng,e.lngLat.lat])
                    .setHTML(info)
                    .addTo(map);
            });
            return info;
        };

        this.remove = function(rem){
            switch (rem){
                case 'mouseout':
                    this.el.removeEventListener('mouseout', this.onMouseMove);
                    this.map._listeners['mouseout'].splice(0, 1);

                    break;
                case 'mousemove':
                    this.el.removeEventListener('mousemove', this.onMouseMove);
                    popup.remove();
                    this.map._listeners['mousemove'].splice(0, 1);

                    break;
                case 'mousedown':
                    this.el.removeEventListener('mousedown', this.onMouseDown);
                    this.map._listeners['mousedown'].splice(0, 1);

                    break;
                case 'mouseup':
                    this.el.removeEventListener('mouseup', this.onMouseUp);
                    this.map._listeners['mouseup'].splice(0, 1);

                    break;
                case 'dblclick':
                    this.el.removeEventListener('dblclick', this.doubleClick);
                    this.map._listeners['dblclick'].splice(0, 1);

                    break;
                case 'click':
                    this.el.removeEventListener('click', this.sigleClick);
                    this.map._listeners['click'].splice(0, 1);
                    break;
                default :
                    break;

            }
        };

        function fireMouseEvent(type, e) {
            var pos = GeoGlobe.DOM.mousePos(el, e);

            return map.fire(type, {
                lngLat: map.unproject(pos),
                point: pos,
                originalEvent: e
            });
        }
        return this;
    },

    /**
     * Method: onKeyDown
     * 键盘按下事件。
     *
     */
    onKeyDown:function(){
        map.on('keydown',function(e){
            alert("keydown");
            //fireMouseEvent('mouseout', e);
        })
    },

    /**
     * Method: onMouseDown
     * 鼠标按下事件。
     *
     */
    onMouseDown:function() {
        map.stop();

        map.on('mousedown',function(e){
            alert("down");
            startPos = GeoGlobe.DOM.mousePos(this.el, e);
            //fireMouseEvent('mousedown', e);
        })
    },

    /**
     * Method: onMouseUp
     * 鼠标弹起事件。
     *
     */
    onMouseUp:function() {

        var rotating = map.dragRotate && map.dragRotate.isActive();
        map.on('mouseup',function(e){
            alert("up");
        })

    },

    /**
     * Method: onMouseMove
     * 鼠标移动事件。
     *
     * Parameters:
     * ev - {string}mousemove。
     */
    onMouseMove:function() {
        if (map.dragPan && map.dragPan.isActive()) return;
        if (map.dragRotate && map.dragRotate.isActive()) return;
        var info;
        map.on('mousemove',function(e){
            //fireMouseEvent('mousemove', e);
            var info =
                JSON.stringify(e.point) + '<br />' +
                JSON.stringify(e.lngLat);
            popup.setLngLat([e.lngLat.lng,e.lngLat.lat])
                .setHTML(info)
                .addTo(map);
        });
        return info;
    },

    /**
     * Method: remove
     * 事件移除。
     *
     * Parameters:
     * keydown：{string}键盘按下
     * mousemove：{string}鼠标移动
     * mousedown：{string}鼠标按下
     * mouseup：{string}鼠标弹起
     */
    remove : function(rem){
        switch (rem){
            case 'keydown':
                this.el.removeEventListener('keydown', this.onKeyDown);
                this.map._listeners['keydown'].splice(0, 1);
                break;
            case 'mousemove':
                this.el.removeEventListener('mousemove', this.onMouseMove);
                popup.remove();
                this.map._listeners['mousemove'].splice(0, 1);
                break;
            case 'mousedown':
                this.el.removeEventListener('mousedown', this.onMouseDown);
                this.map._listeners['mousedown'].splice(0, 1);
                break;
            case 'mouseup':
                this.el.removeEventListener('mouseup', this.onMouseUp);
                this.map._listeners['mouseup'].splice(0, 1);
                break;
            default :
                break;
        }
    },
    CLASS_NAME: "GeoGlobe.Event.mapBoxZoomEvent"
});


/**
 * Class: GeoGlobe.Handler
 * 监听器类。
 *
 * Inherits from:
 *  - <GeoGlobe.Handler>
 */
GeoGlobe.Handler = GeoGlobe.Class({

    /**
     * Constructor: GeoGlobe.Handler
     * GeoGlobe.Handler。
     *
     * Parameters:
     * options - {Object} Handeler相关选项设置。
     */
    initialize: function(options){
        return this;
    },

    CLASS_NAME: "GeoGlobe.Handler"
});
/**
 * Class: GeoGlobe.Handler.BoxZoomHandler
 * 范围缩放监听，为二维地图提供范围缩放监听功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Control>
 */
GeoGlobe.Handler.BoxZoomHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * Property: map
     * {GeoGlobe.Map} 地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.Handler.BoxZoomHandler
     * GeoGlobe.Handler构造函数。
     *
     * Parameters:
     * options - {Object} Handler.BoxZoomHandler相关选项设置。
     */
    initialize: function(options){
        //this.handler = new mapboxgl.BoxZoomHandler(options);
        this.handler = options['boxZoom' ];
        return this.handler;
    },

    /**
     * Method: isActivate
     * 添加控件。
     *
     * returns:
     * active - {Boolean} 是否激活。
     */
    isActivate:function(){
        return this.handler.isActive();
    },

    /**
     * Method: isEnabled
     * 是否交互。
     *
     * returns:
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**
     * Method: enable
     * 能交互。
     *
     */
    enable:function(){
        this.handler.enable();
    },

    /**
     * Method: diable
     * 不能交互。
     *
     */
    disable:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.BoxZoomHandler"
});


/**
 * Class: GeoGlobe.Handler.DoubleClickZoomHandler
 * 双击缩放监听，为二维地图提供双击缩放监听功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Handler>
 */
GeoGlobe.Handler.DoubleClickZoomHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * Property: map
     * {GeoGlobe.Map} 地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.Handler.DoubleClickZoomHandler
     * GeoGlobe.Handler构造函数。
     *
     * Parameters:
     * options - {Object} Handler.DoubleClickZoomHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['doubleClickZoom'];

        return this.handler;
    },

    /**
     * Method: isEnabled
     * 是否交互。
     *
     * returns:
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**
     * Method: enable
     * 能交互。
     *
     */
    enable:function(){
        this.handler.enable();
    },

    /**
     * Method: diable
     * 不能交互。
     *
     */
    disable:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.DoubleClickZoomHandler"
});
/**
 * Class: GeoGlobe.Handler.DragPanHandler
 * 平移拖拽，为二维地图提供平移拖拽功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Handler>
 */
GeoGlobe.Handler.DragPanHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * Property: map
     * {GeoGlobe.Map} 地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.Handler.DragPanHandler
     * GeoGlobe.Handler构造函数。
     *
     * Parameters:
     * options - {Object} Handler.DragPanHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['dragPan'];
        return this.handler;
    },

    /**
     * Method: isActivate
     * 添加控件。
     *
     * returns:
     * active - {Boolean} 是否激活。
     */
    isActivate:function(){
        return this.handler.isActive();
    },

    /**
     * Method: isEnabled
     * 是否交互。
     *
     * returns:
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**
     * Method: enable
     * 能交互。
     *
     */
    enable:function(){
        this.handler.enable();
    },

    /**
     * Method: diable
     * 不能交互。
     *
     */
    disable:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.DragPanHandler"
});



/**
 * Class: GeoGlobe.Handler.DragRotateHandler
 * 旋转拖拽监听，为二维地图提供旋转拖拽监听功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Handler>
 */
GeoGlobe.Handler.DragRotateHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * Property: map
     * {GeoGlobe.Map} 地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.Handler.DragRotateHandler
     * GeoGlobe.Handler构造函数。
     *
     * Parameters:
     * options - {Object} Handler.DragRotateHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['dragRotate'];

        return this.handler;
    },

    /**
     * Method: isActivate
     * 添加控件。
     *
     * returns:
     * active - {Boolean} 是否激活。
     */
    isActivate:function(){
        return this.handler.isActive();
    },

    /**
     * Method: isEnabled
     * 是否交互。
     *
     * returns:
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**
     * Method: enable
     * 能交互。
     *
     */
    enable:function(){
        this.handler.enable();
    },

    /**
     * Method: diable
     * 不能交互。
     *
     */
    disable:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.DragRotateHandler"
});




/**
 * Class: GeoGlobe.Handler.KeyboardHandler
 * 键盘操作监听，为二维地图提供键盘操作监听功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Handler>
 */
GeoGlobe.Handler.KeyboardHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * Property: map
     * {GeoGlobe.Map} 地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.Handler.KeyboardHandler
     * GeoGlobe.Handler构造函数。
     *
     * Parameters:
     * options - {Object} Handler.KeyboardHandler相关选项设置。
     */
    initialize: function(options){
        this.handler =options['keyboard'];

        return this.handler;
    },

    /**
     * Method: isEnabled
     * 是否交互。
     *
     * returns:
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**
     * Method: enable
     * 能交互。
     *
     */
    enable:function(){
        this.handler.enable();
    },

    /**
     * Method: diable
     * 不能交互。
     *
     */
    disable:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.KeyboardHandler"
});




/**
 * Class: GeoGlobe.Handler.ScrollZoomHandler
 * 滚动缩放，为二维地图提供滚动缩放功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Handler>
 */
GeoGlobe.Handler.ScrollZoomHandler = GeoGlobe.Class(GeoGlobe.Handler,{


    /**
     * Property: map
     * {GeoGlobe.Map} 地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.Handler.ScrollZoomHandler
     * GeoGlobe.Handler构造函数。
     *
     * Parameters:
     * options - {Object} Handler.ScrollZoomHandler相关选项设置。
     */
    initialize: function(options){
        this.handler =options['scrollZoom'];


        return this.handler;
    },

    /**
     * Method: isEnabled
     * 是否交互。
     *
     * returns:
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**
     * Method: enable
     * 能交互。
     *
     */
    enable:function(){
        this.handler.enable();
    },

    /**
     * Method: diable
     * 不能交互。
     *
     */
    disable:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.ScrollZoomHandler"
});


/**
 * Class: GeoGlobe.Handler.TouchZoomRotateHandler
 * 触摸旋转缩放监听，为二维地图提供触摸旋转缩放监听功能。
 *
 * Inherits from:
 *  - <GeoGlobe.Handler>
 */
GeoGlobe.Handler.TouchZoomRotateHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * Property: map
     * {GeoGlobe.Map} 地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.Handler.TouchZoomRotateHandler
     * GeoGlobe.Handler构造函数。
     *
     * Parameters:
     * options - {Object} Handler.TouchZoomRotateHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['touchZoomRotate'];

        return this.handler;
    },
    /**
     * Method: isEnabled
     * 是否交互。
     *
     * returns:
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**
     * Method: enable
     * 能交互。
     *
     */
    enable:function(){
        this.handler.enable();
    },

    /**
     * Method: diable
     * 不能交互。
     *
     */
    disable:function(){
        this.handler.disable();
    },

    /**
     * Method: disableRotation
     * 禁用“捏”的相互作用，留下“捏放大缩小”的互动功能。
     *
     */
    disableRotation:function(){
        this.handler.disable();
    },

    /**
     * Method: enableRotation
     * 允许“捏”的相互作用
     *
     */
    enableRotation:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.TouchZoomRotateHandler"
});




/**
 * Class: GeoGlobe.DynamicTrace
 * 动态轨迹运动类，通过该类可实现动态的轨迹运动。
 *
 * Inherits from:
 *  - <GeoGlobe.DynamicTrace>
 */
GeoGlobe.DynamicTrace = GeoGlobe.Class({

    /**
     * Property: frame_num
     * {String} 轨迹运动帧数，默认为1000，值越小运动越快。
     */
    frame_num: 0,

    /**
     * Property: origons
     * {<GeoGlobe.LonLat>} 线轨迹的起点坐标数组。
     */
    origons: [0,0],

    /**
     * Property: destinations
     * {<GeoGlobe.LonLat>} 线轨迹的终点坐标数组。
     */
    destinations: [0,0],

    /**
     * Property: map
     * {<GeoGlobe.map>} 线轨迹的终点坐标数组。
     */
    map: null,

    /**
     * Property: id
     * {string} 轨迹运动的唯一id。
     */
    id: null,

    /**
     * Constructor: GeoGlobe.DynamicTrace
     * GeoGlobe.DynamicTrace构造函数。
     *
     * Parameters:
     * options - {Object} DynamicTrace相关选项设置。
     */
    initialize: function(options){
        this.options = options;
        frame_num = options.frame_num;
        map = options.map;
        id = options.id;
        origins = options.origons;
        destinations = options.destinations;
        num = destinations.length;
        pointid = id+'point';
        routeid1 = id+'route1';
        routeid2 = id+'route2';
        point = {};
        route = {};
        route1 ={};
        route2 ={};
        counter =0;
        request = null;

        //this.DynamicTrace = new GeoGlobe.Control();
        //return this;
    },
    /**
     * Method: autotrace
     * 添加运动轨迹。
     *
     * Parameters:
     * fram - {number} 可选，运动的帧数
     * style - {object} 可选，运动点样式
     *
     */
    autotrace:function(fram,style){
        //var x = this.options;
        if( !frame_num){
            frame_num = 1000;
        }
        if(fram){
            frame_num = fram;
        }
        // 起点到终点形成的一条线
        route = {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[0],
                        destinations[0]
                    ]
                }
            }]
        };
        for(var i=1;i<num;i++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[i],
                        destinations[i]
                    ]
                }
            };
            route.features.push(g);
        }
        //沿着轨迹行走的点
        point = {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": origins[0]
                }
            }]
        };
        for(var i=1;i<num;i++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": origins[i]
                }
            }
            point.features.push(g);
        }
        // 计算两点之间的距离
        var lineDistance = [];
        lineDistance.push(turf.lineDistance(route.features[0], 'kilometers'));

        for(var i=1;i<num;i++) {
            lineDistance.push(turf.lineDistance(route.features[i], 'kilometers'));
        }
        //将线路分成1000段
        for(var j=0;j<num;j++) {
            var arc = [];

            for (var i = 0; i < lineDistance[j]; i++) {
                var segment = turf.along(route.features[j], i / frame_num * lineDistance[j], 'kilometers');
                arc.push(segment.geometry.coordinates);
            }
            // Update the route with calculated arc coordinates
            route.features[j].geometry.coordinates = arc;
        }
        route1 = {
            "type": "FeatureCollection",
            "features": []
        };
        for(var j=0;j<num;j++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[j],
                        origins[j]
                    ]
                }
            };
            route1.features.push(g);
        }

        route2 = {
            "type": "FeatureCollection",
            "features": []
        };
        for(var j=0;j<num;j++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[j],
                        origins[j]
                    ]
                }
            };
            route2.features.push(g);
        }
        // Used to increment the value of the point measurement against the route.
        counter = 0;
        map.addSource(routeid1, {
            "type": "geojson",
            "data": route1
        });

        map.addSource(routeid2, {
            "type": "geojson",
            "data": route2
        });

        map.addSource(pointid, {
            "type": "geojson",
            "data": point
        });

        if(style){
            map.addLayer({
                "id": routeid1,
                "source": routeid1,//"route",
                "type": style.line.type,
                "paint": style.line.paint
            });

            map.addLayer({
                "id":routeid2,
                "source": routeid2,//"route",
                "type": style.line.type,
                "paint": style.line.paint
            });
            map.addLayer({
                "id": pointid,
                "source": pointid,
                "type": style.point.type,
                "paint": style.point.paint
            });
        }else{
            map.addLayer({
                "id": routeid1,
                "source": routeid1,//"route",
                "type": "line",
                "paint": {
                    "line-width": {
                        'base': 2,
                        'stops': [[12, 2], [22, 180]]
                    },
                    "line-color": "red"
                }
            });

            map.addLayer({
                "id":routeid2,
                "source": routeid2,//"route",
                "type": "line",
                "paint": {
                    "line-width": {
                        'base': 2,
                        'stops': [[12, 2], [22, 180]]
                    },
                    "line-color": "red"
                }
            });
            map.addLayer({
                "id": pointid,
                "source": pointid,
                "type": "circle",
                "paint": {
                    'circle-radius': {
                        'base': 2,
                        'stops': [[12, 2], [22, 180]]
                    },
                    "circle-color": "yellow",
                    "circle-opacity": 1
                }
            });
        }
    },

    /**
     * Method: run
     * 运行。
     */
    run:function(){
        for(var i = 0;i<num;i++) {
            point.features[i].geometry.coordinates = route.features[i].geometry.coordinates[counter];
            route1.features[i].geometry.coordinates.push(route.features[i].geometry.coordinates[counter]);
            route2.features[i].geometry.coordinates.push(route.features[i].geometry.coordinates[counter]);
            if(route1.features[i].geometry.coordinates.length > 11) {
                route1.features[i].geometry.coordinates.shift();
            }
        }
        // Update the source with this new data.
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        if(counter % 10 == 0) {
            map.getSource(routeid2).setData(route2);
        }
        if (point.features[0].geometry.coordinates[0] !== destinations[0][0]) {
            request = requestAnimationFrame(run);
        }
        counter = counter + 1;
    },

    /**
     * Method: reset
     * 重置。
     */
    reset:function(){
        for(var i = 0;i<num;i++) {
            point.features[i].geometry.coordinates = origins[i];
            route1.features[i].geometry.coordinates = [];
            route2.features[i].geometry.coordinates = [];
            route1.features[i].geometry.coordinates.push(origins[i]);
            route2.features[i].geometry.coordinates.push(origins[i]);
        }
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        map.getSource(routeid2).setData(route2);
        // 重置counter
        counter = 0;
        cancelAnimationFrame(request);
    },
    /**
     * Method: replay
     * 重绘。
     */
    replay:function(){
        for(var i = 0;i<num;i++) {
            point.features[i].geometry.coordinates = origins[i];
            route1.features[i].geometry.coordinates = [];
            route2.features[i].geometry.coordinates = [];
            route1.features[i].geometry.coordinates.push(origins[i]);
            route2.features[i].geometry.coordinates.push(origins[i]);
        }
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        map.getSource(routeid2).setData(route2);
        // 重置counter
        // 重启运动
        counter = 0;
        run(counter);
    },

    /**
     * Method: pause
     * 暂停。
     */
    pause:function(){
        cancelAnimationFrame(request);
    },

    /**
     * Method: remove
     * 删除运动轨迹。
     */
    removetrace:function(){
        map.removeLayer(pointid);
        map.removeLayer(routeid1);
        map.removeLayer(routeid2);
        map.removeSource(pointid);
        map.removeSource(routeid1);
        map.removeSource(routeid2);
        //var x = 3000;
        //var style = {
        //    "type":"circle",
        //    "paint":{
        //        "circle-radius": 3,
        //        "circle-color": "green",
        //        "circle-opacity": 1
        //    }
        //};
        //this.autotrace(x,style);
        //run();

    },
    CLASS_NAME: "GeoGlobe.DynamicTrace"
});/**
 * Class: GeoGlobe.DynamicFeature
 * 动态点运动类，通过该类可实现点的动态效果。
 *
 * Inherits from:
 *  - <GeoGlobe.DynamicFeature>
 */
GeoGlobe.DynamicFeature = GeoGlobe.Class({

    /**
     * Property: data
     * {GeoJSON} 数据。
     */
    data: null,

    /**
     * Property: map
     * {<GeoGlobe.map>} 动态点添加的地图。
     */
    map: null,

    /**
     * Property: style
     * {object} 动态要素添加的样式，包括颜色和透明度。
     */
    style: null,

    /**
     * Property: isdraw
     * {boolean} 是否立即绘制判断，true表示立即绘制，false表示通过添加函数立即绘制。
     */
    isdraw: null,

    /**
     * Property: id
     * {string} 动态要素的唯一标识。
     */

    id: null,

    /**
     * Property: property
     * {string} 数据中动态样式改变的属性名称。
     */
    property: null,

    /**
     * Constructor: GeoGlobe.DynamicFeature
     * GeoGlobe.DynamicFeature构造函数。
     *
     * Parameters:
     * options - {Object} DynamicFeature相关选项设置。
     */
    initialize: function(options){
        this.options = options;
        map = options.map;
        feat_data = options.data;
        speed = 500;
        i =0;
        sourceid =null;
        style = options.style;
        property = style.property;
        val_property = feat_data.features[0].properties[property];
        sourceid = options.id;
        isdraw = options.isdraw;
        color_num =[];
        size_num =[];
        if(isdraw){
            this.setdata();
            this.setstyle();
        }
    },

    /**
     * Method: setdata
     * 添加动态要素的数据。
     *
     */
    setdata:function(datas,start,end){
        if(datas){
            map.removeSource(sourceid);
            map.addSource(sourceid, {
                type: "geojson",
                data: datas
            });

        }else{
            map.addSource(sourceid, {
                type: "geojson",
                data: feat_data
            });
        }

    },
    /**
     * Method: setstyle
     * 添加添加动态要素图层。
     *
     */
    setstyle:function(){
        var start_num = 0;
        if(style.color) {
            color = style.color;
            var color_set =color[val_property];
            for(var c =0;c<color_set.length;c++){
                color_num.push([c,color_set[c]]);
            }
            opacity = style.opacity;
            if(style.size){
                size = style.size;
                var size_set =size[val_property];
                for(var s =0;s<size_set.length;s++){
                    size_num.push([s,size_set[s]]);
                }
            }else{
                size_num =[
                    [0, 7],
                    [1,5],
                    [2, 3]
                ]
            }

        }else{
            opacity = 0.3;
            color_num = [
                [0, 'red'],
                [1, '#FFC0CB'],
                [2, '#FFB6C1']
            ];
            size_num =[
                [0, 7],
                [1,5],
                [2, 3]
            ]
        }
        if(style.type === 'point'){
            //指定时间调用函数
            setInterval(function(){
                if(i % speed === 0){
                    map.addLayer({
                        "id": sourceid,
                        "type": "circle",
                        "source": sourceid,
                        "paint": {
                            "circle-color": {
                                "stops": [color_num[start_num]]
                            },
                            'circle-opacity': opacity,
                            "circle-radius": {
                                'stops':[size_num[start_num]]
                            }
                        }
                    });
                    start_num++;
                    if(start_num > 2) start_num = 0;
                }
                i+=5;
            }, 1);
        }else if(style.type === 'line'){
            setInterval(function(){
                if(i % speed === 0){
                    map.addLayer({
                        "id": sourceid,
                        "type": "line",
                        "source": sourceid,
                        "paint": {
                            "line-color": {
                                "stops": [color_num[start_num]]
                            },
                            'line-opacity': opacity,
                            'line-width':{
                                'stops':[size_num[start_num]]
                            }
                        }
                    });
                    start_num++;
                    if(start_num > 2) start_num = 0;
                }
                i+=5;
            }, 1);
        }else if(style.type === 'fill'){
            setInterval(function(){
                if(i % speed === 0){
                    map.addLayer({
                        "id": sourceid,
                        "type": "fill",
                        "source": sourceid,
                        "paint": {
                            "fill-color": {
                                "stops": [color_num[start_num]]
                            },
                            'fill-opacity': 0.3,
                            'fill-outline-color':{
                                "stops": [color_num[start_num]]
                            }
                        }
                    });
                    start_num++;
                    if(start_num > 2) start_num = 0;
                }
                i+=5;
            }, 1);
        }else{
            alert("请确定显示的要素的类型");
        }
    },
    CLASS_NAME: "GeoGlobe.DynamicFeature"
});/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
 
/**
 * @requires View2D/tool/Class.js
 */

/**
 * Class: GeoGlobe.Geometry
 * A Geometry is a description of a geographic object.  Create an instance of
 * this class with the <GeoGlobe.Geometry> constructor.  This is a base class,
 * typical geometry types are described by subclasses of this class.
 * 几何对象基类。
 *
 * Note that if you use the <GeoGlobe.Geometry.fromWKT> method, you must
 * explicitly include the GeoGlobe.Format.WKT in your build.
 */
GeoGlobe.Geometry = GeoGlobe.Class4OL({

    /**
     * Property: id
     * {String} A unique identifier for this geometry.
     */
    id: null,

    /**
     * Property: parent
     * {<GeoGlobe.Geometry>}This is set when a Geometry is added as component
     * of another geometry
     */
    parent: null,

    /**
     * Property: bounds 
     * {<GeoGlobe.LngLatBounds>} The bounds of this geometry
     */
    bounds: null,

    /**
     * Constructor: GeoGlobe.Geometry
     * Creates a geometry object.  
     */
    initialize: function() {
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
    },
    
    /**
     * Method: destroy
     * Destroy this geometry.
     */
    destroy: function() {
        this.id = null;
        this.bounds = null;
    },
    
    /**
     * APIMethod: clone
     * Create a clone of this geometry.  Does not set any non-standard
     *     properties of the cloned geometry.
     * 
     * Returns:
     * {<GeoGlobe.Geometry>} An exact clone of this geometry.
     */
    clone: function() {
        return new GeoGlobe.Geometry();
    },
    
    /**
     * Method: setBounds
     * Set the bounds for this Geometry.
     * 
     * Parameters:
     * bounds - {<GeoGlobe.LngLatBounds>} 
     */
    setBounds: function(bounds) {
        if (bounds) {
            this.bounds = bounds.clone();
        }
    },
    
    /**
     * Method: clearBounds
     * Nullify this components bounds and that of its parent as well.
     */
    clearBounds: function() {
        this.bounds = null;
        if (this.parent) {
            this.parent.clearBounds();
        }    
    },
    
    /**
     * Method: extendBounds
     * Extend the existing bounds to include the new bounds. 
     * If geometry's bounds is not yet set, then set a new Bounds.
     * 
     * Parameters:
     * newBounds - {<GeoGlobe.LngLatBounds>} 
     */
    extendBounds: function(newBounds){
        var bounds = this.getBounds();
        if (!bounds) {
            this.setBounds(newBounds);
        } else {
            this.bounds.extend(newBounds);
        }
    },
    
    /**
     * APIMethod: getBounds
     * Get the bounds for this Geometry. If bounds is not set, it 
     * is calculated again, this makes queries faster.
     * 
     * Returns:
     * {<GeoGlobe.LngLatBounds>}
     */
    getBounds: function() {
        if (this.bounds == null) {
            this.calculateBounds();
        }
        return this.bounds;
    },
    
    /** 
     * APIMethod: calculateBounds
     * Recalculate the bounds for the geometry. 
     */
    calculateBounds: function() {
        //
        // This should be overridden by subclasses.
        //
    },
    
    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options depend on the specific geometry type.
     * 
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
    },
    
    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
    },

    /**
     * Method: atPoint
     * Note - This is only an approximation based on the bounds of the 
     * geometry.
     * 
     * Parameters:
     * lnglat - {<GeoGlobe.LngLat>|Object} GeoGlobe.LngLat or an
     *     object with a 'lng' and 'lat' properties.
     * toleranceLon - {float} Optional tolerance in Geometric Coords
     * toleranceLat - {float} Optional tolerance in Geographic Coords
     * 
     * Returns:
     * {Boolean} Whether or not the geometry is at the specified location
     */
    atPoint: function(lnglat, toleranceLon, toleranceLat) {
        var atPoint = false;
        var bounds = this.getBounds();
        if ((bounds != null) && (lnglat != null)) {

            var dX = (toleranceLon != null) ? toleranceLon : 0;
            var dY = (toleranceLat != null) ? toleranceLat : 0;
    		
			var _sw = new GeoGlobe.LngLat(this.bounds._sw.lng - dX, this.bounds._sw.lat - dY);
			var _ne = new GeoGlobe.LngLat(this.bounds._ne.lng + dX, this.bounds._ne.lat + dY);
            var toleranceBounds = new GeoGlobe.LngLatBounds(_sw, _ne);
			/*
                new OpenLayers.Bounds(this.bounds.left - dX,
                                      this.bounds.bottom - dY,
                                      this.bounds.right + dX,
                                      this.bounds.top + dY);
            */

            atPoint = toleranceBounds.containsLonLat(lnglat);
        }
        return atPoint;
    },
    
    /**
     * Method: getLength
     * Calculate the length of this geometry. This method is defined in
     * subclasses.
     * 
     * Returns:
     * {Float} The length of the collection by summing its parts
     */
    getLength: function() {
        //to be overridden by geometries that actually have a length
        //
        return 0.0;
    },

    /**
     * Method: getArea
     * Calculate the area of this geometry. This method is defined in subclasses.
     * 
     * Returns:
     * {Float} The area of the collection by summing its parts
     */
    getArea: function() {
        //to be overridden by geometries that actually have an area
        //
        return 0.0;
    },
    
    /**
     * APIMethod: getCentroid
     * Calculate the centroid of this geometry. This method is defined in subclasses.
     *
     * Returns:
     * {<GeoGlobe.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function() {
        return null;
    },

    /**
     * Method: toString
     * Returns a text representation of the geometry.  If the WKT format is
     *     included in a build, this will be the Well-Known Text 
     *     representation.
     *
     * Returns:
     * {String} String representation of this geometry.
     */
    toString: function() {
        var string;
        if (GeoGlobe.Format && GeoGlobe.Format.WKT) {
            string = GeoGlobe.Format.WKT.prototype.write(
                new GeoGlobe.Feature(this)
            );
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },

    CLASS_NAME: "GeoGlobe.Geometry"
});

/**
 * Function: GeoGlobe.Geometry.fromWKT
 * Generate a geometry given a Well-Known Text string.  For this method to
 *     work, you must include the GeoGlobe.Format.WKT in your build 
 *     explicitly.
 *
 * Parameters:
 * wkt - {String} A string representing the geometry in Well-Known Text.
 *
 * Returns:
 * {<GeoGlobe.Geometry>} A geometry of the appropriate class.
 */
GeoGlobe.Geometry.fromWKT = function(wkt) {
    var geom;
    if (GeoGlobe.Format && GeoGlobe.Format.WKT) {
        var format = GeoGlobe.Geometry.fromWKT.format;
        if (!format) {
            format = new GeoGlobe.Format.WKT();
            GeoGlobe.Geometry.fromWKT.format = format;
        }
        var result = format.read(wkt);
        if (result instanceof GeoGlobe.Feature) {
            geom = result.geometry;
        } else if (GeoGlobe.Util.isArray(result)) {
            var len = result.length;
            var components = new Array(len);
            for (var i=0; i<len; ++i) {
                components[i] = result[i].geometry;
            }
            geom = new GeoGlobe.Geometry.Collection(components);
        }
    }
    return geom;
};
    
/**
 * Method: GeoGlobe.Geometry.segmentsIntersect
 * Determine whether two line segments intersect.  Optionally calculates
 *     and returns the intersection point.  This function is optimized for
 *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those
 *     obvious cases where there is no intersection, the function should
 *     not be called.
 *
 * Parameters:
 * seg1 - {Object} Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 * seg2 - {Object} Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 * options - {Object} Optional properties for calculating the intersection.
 *
 * Valid options:
 * point - {Boolean} Return the intersection point.  If false, the actual
 *     intersection point will not be calculated.  If true and the segments
 *     intersect, the intersection point will be returned.  If true and
 *     the segments do not intersect, false will be returned.  If true and
 *     the segments are coincident, true will be returned.
 * tolerance - {Number} If a non-null value is provided, if the segments are
 *     within the tolerance distance, this will be considered an intersection.
 *     In addition, if the point option is true and the calculated intersection
 *     is within the tolerance distance of an end point, the endpoint will be
 *     returned instead of the calculated intersection.  Further, if the
 *     intersection is within the tolerance of endpoints on both segments, or
 *     if two segment endpoints are within the tolerance distance of eachother
 *     (but no intersection is otherwise calculated), an endpoint on the
 *     first segment provided will be returned.
 *
 * Returns:
 * {Boolean | <GeoGlobe.Geometry.Point>}  The two segments intersect.
 *     If the point argument is true, the return will be the intersection
 *     point or false if none exists.  If point is true and the segments
 *     are coincident, return will be true (and the instersection is equal
 *     to the shorter segment).
 */
GeoGlobe.Geometry.segmentsIntersect = function(seg1, seg2, options) {
    var point = options && options.point;
    var tolerance = options && options.tolerance;
    var intersection = false;
    var x11_21 = seg1.x1 - seg2.x1;
    var y11_21 = seg1.y1 - seg2.y1;
    var x12_11 = seg1.x2 - seg1.x1;
    var y12_11 = seg1.y2 - seg1.y1;
    var y22_21 = seg2.y2 - seg2.y1;
    var x22_21 = seg2.x2 - seg2.x1;
    var d = (y22_21 * x12_11) - (x22_21 * y12_11);
    var n1 = (x22_21 * y11_21) - (y22_21 * x11_21);
    var n2 = (x12_11 * y11_21) - (y12_11 * x11_21);
    if(d == 0) {
        // parallel
        if(n1 == 0 && n2 == 0) {
            // coincident
            intersection = true;
        }
    } else {
        var along1 = n1 / d;
        var along2 = n2 / d;
        if(along1 >= 0 && along1 <= 1 && along2 >=0 && along2 <= 1) {
            // intersect
            if(!point) {
                intersection = true;
            } else {
                // calculate the intersection point
                var x = seg1.x1 + (along1 * x12_11);
                var y = seg1.y1 + (along1 * y12_11);
                intersection = new GeoGlobe.Geometry.Point(x, y);
            }
        }
    }
    if(tolerance) {
        var dist;
        if(intersection) {
            if(point) {
                var segs = [seg1, seg2];
                var seg, x, y;
                // check segment endpoints for proximity to intersection
                // set intersection to first endpoint within the tolerance
                outer: for(var i=0; i<2; ++i) {
                    seg = segs[i];
                    for(var j=1; j<3; ++j) {
                        x = seg["x" + j];
                        y = seg["y" + j];
                        dist = Math.sqrt(
                            Math.pow(x - intersection.x, 2) +
                            Math.pow(y - intersection.y, 2)
                        );
                        if(dist < tolerance) {
                            intersection.x = x;
                            intersection.y = y;
                            break outer;
                        }
                    }
                }
                
            }
        } else {
            // no calculated intersection, but segments could be within
            // the tolerance of one another
            var segs = [seg1, seg2];
            var source, target, x, y, p, result;
            // check segment endpoints for proximity to intersection
            // set intersection to first endpoint within the tolerance
            outer: for(var i=0; i<2; ++i) {
                source = segs[i];
                target = segs[(i+1)%2];
                for(var j=1; j<3; ++j) {
                    p = {x: source["x"+j], y: source["y"+j]};
                    result = GeoGlobe.Geometry.distanceToSegment(p, target);
                    if(result.distance < tolerance) {
                        if(point) {
                            intersection = new GeoGlobe.Geometry.Point(p.x, p.y);
                        } else {
                            intersection = true;
                        }
                        break outer;
                    }
                }
            }
        }
    }
    return intersection;
};

/**
 * Function: GeoGlobe.Geometry.distanceToSegment
 *
 * Parameters:
 * point - {Object} An object with x and y properties representing the
 *     point coordinates.
 * segment - {Object} An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * Returns:
 * {Object} An object with distance, along, x, and y properties.  The distance
 *     will be the shortest distance between the input point and segment.
 *     The x and y properties represent the coordinates along the segment
 *     where the shortest distance meets the segment. The along attribute
 *     describes how far between the two segment points the given point is.
 */
GeoGlobe.Geometry.distanceToSegment = function(point, segment) {
    var result = GeoGlobe.Geometry.distanceSquaredToSegment(point, segment);
    result.distance = Math.sqrt(result.distance);
    return result;
};

/**
 * Function: GeoGlobe.Geometry.distanceSquaredToSegment
 *
 * Usually the distanceToSegment function should be used. This variant however
 * can be used for comparisons where the exact distance is not important.
 *
 * Parameters:
 * point - {Object} An object with x and y properties representing the
 *     point coordinates.
 * segment - {Object} An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * Returns:
 * {Object} An object with squared distance, along, x, and y properties.
 *     The distance will be the shortest distance between the input point and
 *     segment. The x and y properties represent the coordinates along the
 *     segment where the shortest distance meets the segment. The along
 *     attribute describes how far between the two segment points the given
 *     point is.
 */
GeoGlobe.Geometry.distanceSquaredToSegment = function(point, segment) {
    var x0 = point.x;
    var y0 = point.y;
    var x1 = segment.x1;
    var y1 = segment.y1;
    var x2 = segment.x2;
    var y2 = segment.y2;
    var dx = x2 - x1;
    var dy = y2 - y1;
    //var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
    //            (Math.pow(dx, 2) + Math.pow(dy, 2));
	var along = (dx == 0 && dy == 0) ? 0 : ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
                (Math.pow(dx, 2) + Math.pow(dy, 2));
    var x, y;
    if(along <= 0.0) {
        x = x1;
        y = y1;
    } else if(along >= 1.0) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return {
        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),
        x: x, y: y,
        along: along
    };
};

/**
 * Function: GeoGlobe.Geometry.fromGeoJson
 * 根据geojson对象，获得GeoGlobe.Geometry对象
 */
GeoGlobe.Geometry.fromGeoJson = function(geojson) {
    var geom;
    if (GeoGlobe.Format && GeoGlobe.Format.GeoJSON) {
        format = new GeoGlobe.Format.GeoJSON();
		var result = null;
		try {
	    	//result = format.read(geojson, "Geometry");
            result = format.parseGeometry(geojson);
        } catch(err) {
            console.log(err);
        }
		geom = result;
    }
    return geom;
};/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/Geometry.js
 */

/**
 * Class: GeoGlobe.Geometry.Collection
 * A Collection is exactly what it sounds like: A collection of different 
 * Geometries. These are stored in the local parameter <components> (which
 * can be passed as a parameter to the constructor). 
 * 
 * As new geometries are added to the collection, they are NOT cloned. 
 * When removing geometries, they need to be specified by reference (ie you 
 * have to pass in the *exact* geometry to be removed).
 * 
 * The <getArea> and <getLength> functions here merely iterate through
 * the components, summing their respective areas and lengths.
 *
 * Create a new instance with the <GeoGlobe.Geometry.Collection> constructor.
 * 几何对象集合类。
 *
 * Inherits from:
 *  - <GeoGlobe.Geometry> 
 */
GeoGlobe.Geometry.Collection = GeoGlobe.Class4OL(GeoGlobe.Geometry, {

    /**
     * APIProperty: components
     * {Array(<GeoGlobe.Geometry>)} The component parts of this geometry
     */
    components: null,
    
    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: null,

    /**
     * Constructor: GeoGlobe.Geometry.Collection
     * Creates a Geometry Collection -- a list of geoms.
     *
     * Parameters: 
     * components - {Array(<GeoGlobe.Geometry>)} Optional array of geometries
     *
     */
    initialize: function (components) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        this.components = [];
        if (components != null) {
            this.addComponents(components);
        }
    },

    /**
     * APIMethod: destroy
     * Destroy this geometry.
     */
    destroy: function () {
        this.components.length = 0;
        this.components = null;
        GeoGlobe.Geometry.prototype.destroy.apply(this, arguments);
    },

    /**
     * APIMethod: clone
     * Clone this geometry.
     *
     * Returns:
     * {<GeoGlobe.Geometry.Collection>} An exact clone of this collection
     */
    clone: function() {
        var geometry = eval("new " + this.CLASS_NAME + "()");
        for(var i=0, len=this.components.length; i<len; i++) {
            geometry.addComponent(this.components[i].clone());
        }
        
        // catch any randomly tagged-on properties
        GeoGlobe.Util.applyDefaults(geometry, this);
        
        return geometry;
    },

    /**
     * Method: getComponentsString
     * Get a string representing the components for this collection
     * 
     * Returns:
     * {String} A string representation of the components of this geometry
     */
    getComponentsString: function(){
        var strings = [];
        for(var i=0, len=this.components.length; i<len; i++) {
            strings.push(this.components[i].toShortString()); 
        }
        return strings.join(",");
    },

    /**
     * APIMethod: calculateBounds
     * Recalculate the bounds by iterating through the components and 
     * calling calling extendBounds() on each item.
     */
    calculateBounds: function() {
        this.bounds = null;
        //var bounds = new OpenLayers.Bounds();
		//var sw = new GeoGlobe.LngLat(this.x, this.y);
		//var ne = new GeoGlobe.LngLat(this.x, this.y);
		//换成mapboxgl的bounds对象
        var bounds = new GeoGlobe.LngLatBounds();
        var components = this.components;
        if (components) {
            for (var i=0, len=components.length; i<len; i++) {
                bounds.extend(components[i].getBounds());
            }
        }
        // to preserve old behavior, we only set bounds if non-null
        // in the future, we could add bounds.isEmpty()
        //if (bounds.left != null && bounds.bottom != null && 
        //    bounds.right != null && bounds.top != null) {
        //    this.setBounds(bounds);
        //}
		
		if(bounds._sw != null && bounds._sw != null && 
			bounds._ne != null && bounds._ne != null){
			if(bounds._sw.lng != null && bounds._sw.lat != null && 
				bounds._ne.lng != null && bounds._ne.lat != null){
				this.setBounds(bounds);
			}
		}
    },

    /**
     * APIMethod: addComponents
     * Add components to this geometry.
     *
     * Parameters:
     * components - {Array(<GeoGlobe.Geometry>)} An array of geometries to add
     */
    addComponents: function(components){
        if(!(GeoGlobe.Util.isArray(components))) {
            components = [components];
        }
        for(var i=0, len=components.length; i<len; i++) {
            this.addComponent(components[i]);
        }
    },

    /**
     * Method: addComponent
     * Add a new component (geometry) to the collection.  If this.componentTypes
     * is set, then the component class name must be in the componentTypes array.
     *
     * The bounds cache is reset.
     * 
     * Parameters:
     * component - {<GeoGlobe.Geometry>} A geometry to add
     * index - {int} Optional index into the array to insert the component
     *
     * Returns:
     * {Boolean} The component geometry was successfully added
     */    
    addComponent: function(component, index) {
        var added = false;
        if(component) {
            if(this.componentTypes == null ||
               (GeoGlobe.Util.indexOf(this.componentTypes,
                                        component.CLASS_NAME) > -1)) {

                if(index != null && (index < this.components.length)) {
                    var components1 = this.components.slice(0, index);
                    var components2 = this.components.slice(index, 
                                                           this.components.length);
                    components1.push(component);
                    this.components = components1.concat(components2);
                } else {
                    this.components.push(component);
                }
                component.parent = this;
                this.clearBounds();
                added = true;
            }
        }
        return added;
    },
    
    /**
     * APIMethod: removeComponents
     * Remove components from this geometry.
     *
     * Parameters:
     * components - {Array(<GeoGlobe.Geometry>)} The components to be removed
     *
     * Returns: 
     * {Boolean} A component was removed.
     */
    removeComponents: function(components) {
        var removed = false;

        if(!(GeoGlobe.Util.isArray(components))) {
            components = [components];
        }
        for(var i=components.length-1; i>=0; --i) {
            removed = this.removeComponent(components[i]) || removed;
        }
        return removed;
    },
    
    /**
     * Method: removeComponent
     * Remove a component from this geometry.
     *
     * Parameters:
     * component - {<GeoGlobe.Geometry>} 
     *
     * Returns: 
     * {Boolean} The component was removed.
     */
    removeComponent: function(component) {
        
        GeoGlobe.Util.removeItem(this.components, component);
        
        // clearBounds() so that it gets recalculated on the next call
        // to this.getBounds();
        this.clearBounds();
        return true;
    },

    /**
     * APIMethod: getLength
     * Calculate the length of this geometry
     *
     * Returns:
     * {Float} The length of the geometry
     */
    getLength: function() {
        var length = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getLength();
        }
        return length;
    },
    
    /**
     * APIMethod: getArea
     * Calculate the area of this geometry. Note how this function is overridden
     * in <GeoGlobe.Geometry.Polygon>.
     *
     * Returns:
     * {Float} The area of the collection by summing its parts
     */
    getArea: function() {
        var area = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getArea();
        }
        return area;
    },

    /** 
     * APIMethod: getGeodesicArea
     * Calculate the approximate area of the polygon were it projected onto
     *     the earth.
     *
     * Parameters:
     * projection - {<GeoGlobe.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * Returns:
     * {float} The approximate geodesic area of the geometry in square meters.
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getGeodesicArea(projection);
        }
        return area;
    },
    
    /**
     * APIMethod: getCentroid
     *
     * Compute the centroid for this geometry collection.
     *
     * Parameters:
     * weighted - {Boolean} Perform the getCentroid computation recursively,
     * returning an area weighted average of all geometries in this collection.
     *
     * Returns:
     * {<GeoGlobe.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function(weighted) {
        if (!weighted) {
            return this.components.length && this.components[0].getCentroid();
        }
        var len = this.components.length;
        if (!len) {
            return false;
        }
        
        var areas = [];
        var centroids = [];
        var areaSum = 0;
        var minArea = Number.MAX_VALUE;
        var component;
        for (var i=0; i<len; ++i) {
            component = this.components[i];
            var area = component.getArea();
            var centroid = component.getCentroid(true);
            if (isNaN(area) || isNaN(centroid.x) || isNaN(centroid.y)) {
                continue;
            }
            areas.push(area);
            areaSum += area;
            minArea = (area < minArea && area > 0) ? area : minArea;
            centroids.push(centroid);
        }
        len = areas.length;
        if (areaSum === 0) {
            // all the components in this collection have 0 area
            // probably a collection of points -- weight all the points the same
            for (var i=0; i<len; ++i) {
                areas[i] = 1;
            }
            areaSum = areas.length;
        } else {
            // normalize all the areas where the smallest area will get
            // a value of 1
            for (var i=0; i<len; ++i) {
                areas[i] /= minArea;
            }
            areaSum /= minArea;
        }
        
        var xSum = 0, ySum = 0, centroid, area;
        for (var i=0; i<len; ++i) {
            centroid = centroids[i];
            area = areas[i];
            xSum += centroid.x * area;
            ySum += centroid.y * area;
        }
        
        return new GeoGlobe.Geometry.Point(xSum/areaSum, ySum/areaSum);
    },

    /**
     * APIMethod: getGeodesicLength
     * Calculate the approximate length of the geometry were it projected onto
     *     the earth.
     *
     * projection - {<GeoGlobe.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Returns:
     * {Float} The appoximate geodesic length of the geometry in meters.
     */
    getGeodesicLength: function(projection) {
        var length = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getGeodesicLength(projection);
        }
        return length;
    },

    /**
     * APIMethod: move
     * Moves a geometry by the given displacement along positive x and y axes.
     *     This modifies the position of the geometry and clears the cached
     *     bounds.
     *
     * Parameters:
     * x - {Float} Distance to move geometry in positive x direction. 
     * y - {Float} Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        for(var i=0, len=this.components.length; i<len; i++) {
            this.components[i].move(x, y);
        }
    },

    /**
     * APIMethod: rotate
     * Rotate a geometry around some origin
     *
     * Parameters:
     * angle - {Float} Rotation angle in degrees (measured counterclockwise
     *                 from the positive x-axis)
     * origin - {<GeoGlobe.Geometry.Point>} Center point for the rotation
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**
     * APIMethod: resize
     * Resize a geometry relative to some origin.  Use this method to apply
     *     a uniform scaling to a geometry.
     *
     * Parameters:
     * scale - {Float} Factor by which to scale the geometry.  A scale of 2
     *                 doubles the size of the geometry in each dimension
     *                 (lines, for example, will be twice as long, and polygons
     *                 will have four times the area).
     * origin - {<GeoGlobe.Geometry.Point>} Point of origin for resizing
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
     * 
     * Returns:
     * {<GeoGlobe.Geometry>} - The current geometry. 
     */
    resize: function(scale, origin, ratio) {
        for(var i=0; i<this.components.length; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best, distance;
        var min = Number.POSITIVE_INFINITY;
        for(var i=0, len=this.components.length; i<len; ++i) {
            result = this.components[i].distanceTo(geometry, options);
            distance = details ? result.distance : result;
            if(distance < min) {
                min = distance;
                best = result;
                if(min == 0) {
                    break;
                }
            }
        }
        return best;
    },

    /** 
     * APIMethod: equals
     * Determine whether another geometry is equivalent to this one.  Geometries
     *     are considered equivalent if all components have the same coordinates.
     * 
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The geometry to test. 
     *
     * Returns:
     * {Boolean} The supplied geometry is equivalent to this geometry.
     */
    equals: function(geometry) {
        var equivalent = true;
        if(!geometry || !geometry.CLASS_NAME ||
           (this.CLASS_NAME != geometry.CLASS_NAME)) {
            equivalent = false;
        } else if(!(GeoGlobe.Util.isArray(geometry.components)) ||
                  (geometry.components.length != this.components.length)) {
            equivalent = false;
        } else {
            for(var i=0, len=this.components.length; i<len; ++i) {
                if(!this.components[i].equals(geometry.components[i])) {
                    equivalent = false;
                    break;
                }
            }
        }
        return equivalent;
    },

    /**
     * APIMethod: transform
     * Reproject the components geometry from source to dest.
     * 
     * Parameters:
     * source - {<GeoGlobe.Projection>} 
     * dest - {<GeoGlobe.Projection>}
     * 
     * Returns:
     * {<GeoGlobe.Geometry>} 
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len; i++) {  
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },

    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        for(var i=0, len=this.components.length; i<len; ++ i) {
            intersect = geometry.intersects(this.components[i]);
            if(intersect) {
                break;
            }
        }
        return intersect;
    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        var vertices = [];
        for(var i=0, len=this.components.length; i<len; ++i) {
            Array.prototype.push.apply(
                vertices, this.components[i].getVertices(nodes)
            );
        }
        return vertices;
    },


    CLASS_NAME: "GeoGlobe.Geometry.Collection"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/Geometry.js
 */

/**
 * Class: GeoGlobe.Geometry.Point
 * Point geometry class. 
 * 几何点类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry> 
 */
GeoGlobe.Geometry.Point = GeoGlobe.Class4OL(GeoGlobe.Geometry, {

    /** 
     * APIProperty: x 
     * {float} 
     */
    x: null,

    /** 
     * APIProperty: y 
     * {float} 
     */
    y: null,

    /**
     * Constructor: GeoGlobe.Geometry.Point
     * Construct a point geometry.
     *
     * Parameters:
     * x - {float} 
     * y - {float}
     * 
     */
    initialize: function(x, y) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        
        this.x = parseFloat(x);
        this.y = parseFloat(y);
    },

    /**
     * APIMethod: clone
     * 
     * Returns:
     * {<GeoGlobe.Geometry.Point>} An exact clone of this GeoGlobe.Geometry.Point
     */
    clone: function(obj) {
        if (obj == null) {
            obj = new GeoGlobe.Geometry.Point(this.x, this.y);
        }

        // catch any randomly tagged-on properties
        GeoGlobe.Util.applyDefaults(obj, this);

        return obj;
    },

    /** 
     * Method: calculateBounds
     * Create a new Bounds based on the lon/lat
     */
    calculateBounds: function () {
        //this.bounds = new OpenLayers.Bounds(this.x, this.y, this.x, this.y);
		var sw = new GeoGlobe.LngLat(this.x, this.y);
		var ne = new GeoGlobe.LngLat(this.x, this.y);
        this.bounds = new GeoGlobe.LngLatBounds(sw, ne);
											
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var distance, x0, y0, x1, y1, result;
        if(geometry instanceof GeoGlobe.Geometry.Point) {
            x0 = this.x;
            y0 = this.y;
            x1 = geometry.x;
            y1 = geometry.y;
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
            result = !details ?
                distance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: distance};
        } else {
            result = geometry.distanceTo(this, options);
            if(details) {
                // switch coord order since this geom is target
                result = {
                    x0: result.x1, y0: result.y1,
                    x1: result.x0, y1: result.y0,
                    distance: result.distance
                };
            }
        }
        return result;
    },
    
    /** 
     * APIMethod: equals
     * Determine whether another geometry is equivalent to this one.  Geometries
     *     are considered equivalent if all components have the same coordinates.
     * 
     * Parameters:
     * geom - {<GeoGlobe.Geometry.Point>} The geometry to test. 
     *
     * Returns:
     * {Boolean} The supplied geometry is equivalent to this geometry.
     */
    equals: function(geom) {
        var equals = false;
        if (geom != null) {
            equals = ((this.x == geom.x && this.y == geom.y) ||
                      (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));
        }
        return equals;
    },
    
    /**
     * Method: toShortString
     *
     * Returns:
     * {String} Shortened String representation of Point object. 
     *         (ex. <i>"5, 42"</i>)
     */
    toShortString: function() {
        return (this.x + ", " + this.y);
    },
    
    /**
     * APIMethod: move
     * Moves a geometry by the given displacement along positive x and y axes.
     *     This modifies the position of the geometry and clears the cached
     *     bounds.
     *
     * Parameters:
     * x - {Float} Distance to move geometry in positive x direction. 
     * y - {Float} Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        this.x = this.x + x;
        this.y = this.y + y;
        this.clearBounds();
    },

    /**
     * APIMethod: rotate
     * Rotate a point around another.
     *
     * Parameters:
     * angle - {Float} Rotation angle in degrees (measured counterclockwise
     *                 from the positive x-axis)
     * origin - {<GeoGlobe.Geometry.Point>} Center point for the rotation
     */
    rotate: function(angle, origin) {
        angle *= Math.PI / 180;
        var radius = this.distanceTo(origin);
        var theta = angle + Math.atan2(this.y - origin.y, this.x - origin.x);
        this.x = origin.x + (radius * Math.cos(theta));
        this.y = origin.y + (radius * Math.sin(theta));
        this.clearBounds();
    },
    
    /**
     * APIMethod: getCentroid
     *
     * Returns:
     * {<GeoGlobe.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function() {
        return new GeoGlobe.Geometry.Point(this.x, this.y);
    },

    /**
     * APIMethod: resize
     * Resize a point relative to some origin.  For points, this has the effect
     *     of scaling a vector (from the origin to the point).  This method is
     *     more useful on geometry collection subclasses.
     *
     * Parameters:
     * scale - {Float} Ratio of the new distance from the origin to the old
     *                 distance from the origin.  A scale of 2 doubles the
     *                 distance between the point and origin.
     * origin - {<GeoGlobe.Geometry.Point>} Point of origin for resizing
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
     * 
     * Returns:
     * {<GeoGlobe.Geometry>} - The current geometry. 
     */
    resize: function(scale, origin, ratio) {
        ratio = (ratio == undefined) ? 1 : ratio;
        this.x = origin.x + (scale * ratio * (this.x - origin.x));
        this.y = origin.y + (scale * (this.y - origin.y));
        this.clearBounds();
        return this;
    },
    
    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.equals(geometry);
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**
     * APIMethod: transform
     * Translate the x,y properties of the point from source to dest.
     * 
     * Parameters:
     * source - {<GeoGlobe.SpatialReference>} 
     * dest - {<GeoGlobe.SpatialReference>}
     * 
     * Returns:
     * {<GeoGlobe.Geometry>} 
     */
    transform: function(source, dest) {
        if ((source && dest)) {
            GeoGlobe.SpatialReference.transform(
                this, source, dest); 
            this.bounds = null;
        }       
        return this;
    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        return [this];
    },

    CLASS_NAME: "GeoGlobe.Geometry.Point"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/Collection.js
 * @requires View2D/Geometry/Point.js
 */

/**
 * Class: GeoGlobe.Geometry.MultiPoint
 * MultiPoint is a collection of Points.  Create a new instance with the
 * <GeoGlobe.Geometry.MultiPoint> constructor.
 * 点集合几何对象类。
 *
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection>
 *  - <GeoGlobe.Geometry>
 */
GeoGlobe.Geometry.MultiPoint = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**
     * Constructor: GeoGlobe.Geometry.MultiPoint
     * Create a new MultiPoint Geometry
     *
     * Parameters:
     * components - {Array(<GeoGlobe.Geometry.Point>)} 
     *
     * Returns:
     * {<GeoGlobe.Geometry.MultiPoint>}
     */

    /**
     * APIMethod: addPoint
     * Wrapper for <GeoGlobe.Geometry.Collection.addComponent>
     *
     * Parameters:
     * point - {<GeoGlobe.Geometry.Point>} Point to be added
     * index - {Integer} Optional index
     */
    addPoint: function(point, index) {
        this.addComponent(point, index);
    },
    
    /**
     * APIMethod: removePoint
     * Wrapper for <GeoGlobe.Geometry.Collection.removeComponent>
     *
     * Parameters:
     * point - {<GeoGlobe.Geometry.Point>} Point to be removed
     */
    removePoint: function(point){
        this.removeComponent(point);
    },

    CLASS_NAME: "GeoGlobe.Geometry.MultiPoint"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/MultiPoint.js
 */

/**
 * Class: GeoGlobe.Geometry.Curve
 * A Curve is a MultiPoint, whose points are assumed to be connected. To 
 * this end, we provide a "getLength()" function, which iterates through 
 * the points, summing the distances between them. 
 * 曲线几何对象类，由多个几何点组成。
 * 
 * Inherits: 
 *  - <GeoGlobe.Geometry.MultiPoint>
 */
GeoGlobe.Geometry.Curve = GeoGlobe.Class4OL(GeoGlobe.Geometry.MultiPoint, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of 
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**
     * Constructor: GeoGlobe.Geometry.Curve
     * 
     * Parameters:
     * point - {Array(<GeoGlobe.Geometry.Point>)}
     */
    
    /**
     * APIMethod: getLength
     * 
     * Returns:
     * {Float} The length of the curve
     */
    getLength: function() {
        var length = 0.0;
        if ( this.components && (this.components.length > 1)) {
            for(var i=1, len=this.components.length; i<len; i++) {
                length += this.components[i-1].distanceTo(this.components[i]);
            }
        }
        return length;
    },

    /**
     * APIMethod: getGeodesicLength
     * Calculate the approximate length of the geometry were it projected onto
     *     the earth.
     *
     * projection - {<GeoGlobe.SpatialReference>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Returns:
     * {Float} The appoximate geodesic length of the geometry in meters.
     */
    getGeodesicLength: function(projection) {
        var geom = this;  // so we can work with a clone if needed
        if(projection) {
            var gg = new GeoGlobe.SpatialReference("EPSG:4326");
            //var gg = new OpenLayers.Projection("EPSG:4326");
            if(!gg.equals(projection)) {
                geom = this.clone().transform(projection, gg);
            }
        }
        var length = 0.0;
        if(geom.components && (geom.components.length > 1)) {
            var p1, p2;
            for(var i=1, len=geom.components.length; i<len; i++) {
                p1 = geom.components[i-1];
                p2 = geom.components[i];
                // this returns km and requires lon/lat properties
                length += GeoGlobe.Util.distVincenty(
                    {lng: p1.x, lat: p1.y}, {lng: p2.x, lat: p2.y}
                );
            }
        }
        // convert to m
        return length * 1000;
    },

    CLASS_NAME: "GeoGlobe.Geometry.Curve"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/Curve.js
 */

/**
 * Class: GeoGlobe.Geometry.LineString
 * A LineString is a Curve which, once two points have been added to it, can 
 * never be less than two points long.
 * 非闭合线几何对象类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Curve>
 */
GeoGlobe.Geometry.LineString = GeoGlobe.Class4OL(GeoGlobe.Geometry.Curve, {

    /**
     * Constructor: GeoGlobe.Geometry.LineString
     * Create a new LineString geometry
     *
     * Parameters:
     * points - {Array(<GeoGlobe.Geometry.Point>)} An array of points used to
     *          generate the linestring
     *
     */

    /**
     * APIMethod: removeComponent
     * Only allows removal of a point if there are three or more points in 
     * the linestring. (otherwise the result would be just a single point)
     *
     * Parameters: 
     * point - {<GeoGlobe.Geometry.Point>} The point to be removed
     *
     * Returns: 
     * {Boolean} The component was removed.
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 2);
        if (removed) {
            GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                  arguments);
        }
        return removed;
    },
    
    /**
     * APIMethod: intersects
     * Test for instersection between two geometries.  This is a cheapo
     *     implementation of the Bently-Ottmann algorigithm.  It doesn't
     *     really keep track of a sweep line data structure.  It is closer
     *     to the brute force method, except that segments are sorted and
     *     potential intersections are only calculated when bounding boxes
     *     intersect.
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>}
     *
     * Returns:
     * {Boolean} The input geometry intersects this geometry.
     */
    intersects: function(geometry) {
        var intersect = false;
        var type = geometry.CLASS_NAME;
        if(type == "GeoGlobe.Geometry.LineString" ||
           type == "GeoGlobe.Geometry.LinearRing" ||
           type == "GeoGlobe.Geometry.Point") {
            var segs1 = this.getSortedSegments();
            var segs2;
            if(type == "GeoGlobe.Geometry.Point") {
                segs2 = [{
                    x1: geometry.x, y1: geometry.y,
                    x2: geometry.x, y2: geometry.y
                }];
            } else {
                segs2 = geometry.getSortedSegments();
            }
            var seg1, seg1x1, seg1x2, seg1y1, seg1y2,
                seg2, seg2y1, seg2y2;
            // sweep right
            outer: for(var i=0, len=segs1.length; i<len; ++i) {
                seg1 = segs1[i];
                seg1x1 = seg1.x1;
                seg1x2 = seg1.x2;
                seg1y1 = seg1.y1;
                seg1y2 = seg1.y2;
                inner: for(var j=0, jlen=segs2.length; j<jlen; ++j) {
                    seg2 = segs2[j];
                    if(seg2.x1 > seg1x2) {
                        // seg1 still left of seg2
                        break;
                    }
                    if(seg2.x2 < seg1x1) {
                        // seg2 still left of seg1
                        continue;
                    }
                    seg2y1 = seg2.y1;
                    seg2y2 = seg2.y2;
                    if(Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
                        // seg2 above seg1
                        continue;
                    }
                    if(Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
                        // seg2 below seg1
                        continue;
                    }
                    if(GeoGlobe.Geometry.segmentsIntersect(seg1, seg2)) {
                        intersect = true;
                        break outer;
                    }
                }
            }
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**
     * Method: getSortedSegments
     *
     * Returns:
     * {Array} An array of segment objects.  Segment objects have properties
     *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.
     *     The end point is represented by x2 and y2.  Start and end are
     *     ordered so that x1 < x2.
     */
    getSortedSegments: function() {
        var numSeg = this.components.length - 1;
        var segments = new Array(numSeg), point1, point2;
        for(var i=0; i<numSeg; ++i) {
            point1 = this.components[i];
            point2 = this.components[i + 1];
            if(point1.x < point2.x) {
                segments[i] = {
                    x1: point1.x,
                    y1: point1.y,
                    x2: point2.x,
                    y2: point2.y
                };
            } else {
                segments[i] = {
                    x1: point2.x,
                    y1: point2.y,
                    x2: point1.x,
                    y2: point1.y
                };
            }
        }
        // more efficient to define this somewhere static
        function byX1(seg1, seg2) {
            return seg1.x1 - seg2.x1;
        }
        return segments.sort(byX1);
    },
    
    /**
     * Method: splitWithSegment
     * Split this geometry with the given segment.
     *
     * Parameters:
     * seg - {Object} An object with x1, y1, x2, and y2 properties referencing
     *     segment endpoint coordinates.
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source segment must be within the
     *     tolerance distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of one of the source segment's
     *     endpoints will be assumed to occur at the endpoint.
     *
     * Returns:
     * {Object} An object with *lines* and *points* properties.  If the given
     *     segment intersects this linestring, the lines array will reference
     *     geometries that result from the split.  The points array will contain
     *     all intersection points.  Intersection points are sorted along the
     *     segment (in order from x1,y1 to x2,y2).
     */
    splitWithSegment: function(seg, options) {
        var edge = !(options && options.edge === false);
        var tolerance = options && options.tolerance;
        var lines = [];
        var verts = this.getVertices();
        var points = [];
        var intersections = [];
        var split = false;
        var vert1, vert2, point;
        var node, vertex, target;
        var interOptions = {point: true, tolerance: tolerance};
        var result = null;
        for(var i=0, stop=verts.length-2; i<=stop; ++i) {
            vert1 = verts[i];
            points.push(vert1.clone());
            vert2 = verts[i+1];
            target = {x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y};
            point = GeoGlobe.Geometry.segmentsIntersect(
                seg, target, interOptions
            );
            if(point instanceof GeoGlobe.Geometry.Point) {
                if((point.x === seg.x1 && point.y === seg.y1) ||
                   (point.x === seg.x2 && point.y === seg.y2) ||
                   point.equals(vert1) || point.equals(vert2)) {
                    vertex = true;
                } else {
                    vertex = false;
                }
                if(vertex || edge) {
                    // push intersections different than the previous
                    if(!point.equals(intersections[intersections.length-1])) {
                        intersections.push(point.clone());
                    }
                    if(i === 0) {
                        if(point.equals(vert1)) {
                            continue;
                        }
                    }
                    if(point.equals(vert2)) {
                        continue;
                    }
                    split = true;
                    if(!point.equals(vert1)) {
                        points.push(point);
                    }
                    lines.push(new GeoGlobe.Geometry.LineString(points));
                    points = [point.clone()];
                }
            }
        }
        if(split) {
            points.push(vert2.clone());
            lines.push(new GeoGlobe.Geometry.LineString(points));
        }
        if(intersections.length > 0) {
            // sort intersections along segment
            var xDir = seg.x1 < seg.x2 ? 1 : -1;
            var yDir = seg.y1 < seg.y2 ? 1 : -1;
            result = {
                lines: lines,
                points: intersections.sort(function(p1, p2) {
                    return (xDir * p1.x - xDir * p2.x) || (yDir * p1.y - yDir * p2.y);
                })
            };
        }
        return result;
    },

    /**
     * Method: split
     * Use this geometry (the source) to attempt to split a target geometry.
     * 
     * Parameters:
     * target - {<GeoGlobe.Geometry>} The target geometry.
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    split: function(target, options) {
        var results = null;
        var mutual = options && options.mutual;
        var sourceSplit, targetSplit, sourceParts, targetParts;
        if(target instanceof GeoGlobe.Geometry.LineString) {
            var verts = this.getVertices();
            var vert1, vert2, seg, splits, lines, point;
            var points = [];
            sourceParts = [];
            for(var i=0, stop=verts.length-2; i<=stop; ++i) {
                vert1 = verts[i];
                vert2 = verts[i+1];
                seg = {
                    x1: vert1.x, y1: vert1.y,
                    x2: vert2.x, y2: vert2.y
                };
                targetParts = targetParts || [target];
                if(mutual) {
                    points.push(vert1.clone());
                }
                for(var j=0; j<targetParts.length; ++j) {
                    splits = targetParts[j].splitWithSegment(seg, options);
                    if(splits) {
                        // splice in new features
                        lines = splits.lines;
                        if(lines.length > 0) {
                            lines.unshift(j, 1);
                            Array.prototype.splice.apply(targetParts, lines);
                            j += lines.length - 2;
                        }
                        if(mutual) {
                            for(var k=0, len=splits.points.length; k<len; ++k) {
                                point = splits.points[k];
                                if(!point.equals(vert1)) {
                                    points.push(point);
                                    sourceParts.push(new GeoGlobe.Geometry.LineString(points));
                                    if(point.equals(vert2)) {
                                        points = [];
                                    } else {
                                        points = [point.clone()];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if(mutual && sourceParts.length > 0 && points.length > 0) {
                points.push(vert2.clone());
                sourceParts.push(new GeoGlobe.Geometry.LineString(points));
            }
        } else {
            results = target.splitWith(this, options);
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetSplit || sourceSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    /**
     * Method: splitWith
     * Split this geometry (the target) with the given geometry (the source).
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} A geometry used to split this
     *     geometry (the source).
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    splitWith: function(geometry, options) {
        return geometry.split(this, options);

    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        var vertices;
        if(nodes === true) {
            vertices = [
                this.components[0],
                this.components[this.components.length-1]
            ];
        } else if (nodes === false) {
            vertices = this.components.slice(1, this.components.length-1);
        } else {
            vertices = this.components.slice();
        }
        return vertices;
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best = {};
        var min = Number.POSITIVE_INFINITY;
        if(geometry instanceof GeoGlobe.Geometry.Point) {
            var segs = this.getSortedSegments();
            var x = geometry.x;
            var y = geometry.y;
            var seg;
            for(var i=0, len=segs.length; i<len; ++i) {
                seg = segs[i];
                result = GeoGlobe.Geometry.distanceToSegment(geometry, seg);
                if(result.distance < min) {
                    min = result.distance;
                    best = result;
                    if(min === 0) {
                        break;
                    }
                } else {
                    // if distance increases and we cross y0 to the right of x0, no need to keep looking.
                    if(seg.x2 > x && ((y > seg.y1 && y < seg.y2) || (y < seg.y1 && y > seg.y2))) {
                        break;
                    }
                }
            }
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x, y0: best.y,
                    x1: x, y1: y
                };
            } else {
                best = best.distance;
            }
        } else if(geometry instanceof GeoGlobe.Geometry.LineString) { 
            var segs0 = this.getSortedSegments();
            var segs1 = geometry.getSortedSegments();
            var seg0, seg1, intersection, x0, y0;
            var len1 = segs1.length;
            var interOptions = {point: true};
            outer: for(var i=0, len=segs0.length; i<len; ++i) {
                seg0 = segs0[i];
                x0 = seg0.x1;
                y0 = seg0.y1;
                for(var j=0; j<len1; ++j) {
                    seg1 = segs1[j];
                    intersection = GeoGlobe.Geometry.segmentsIntersect(seg0, seg1, interOptions);
                    if(intersection) {
                        min = 0;
                        best = {
                            distance: 0,
                            x0: intersection.x, y0: intersection.y,
                            x1: intersection.x, y1: intersection.y
                        };
                        break outer;
                    } else {
                        result = GeoGlobe.Geometry.distanceToSegment({x: x0, y: y0}, seg1);
                        if(result.distance < min) {
                            min = result.distance;
                            best = {
                                distance: min,
                                x0: x0, y0: y0,
                                x1: result.x, y1: result.y
                            };
                        }
                    }
                }
            }
            if(!details) {
                best = best.distance;
            }
            if(min !== 0) {
                // check the final vertex in this line's sorted segments
                if(seg0) {
                    result = geometry.distanceTo(
                        new GeoGlobe.Geometry.Point(seg0.x2, seg0.y2),
                        options
                    );
                    var dist = details ? result.distance : result;
                    if(dist < min) {
                        if(details) {
                            best = {
                                distance: min,
                                x0: result.x1, y0: result.y1,
                                x1: result.x0, y1: result.y0
                            };
                        } else {
                            best = dist;
                        }
                    }
                }
            }
        } else {
            best = geometry.distanceTo(this, options);
            // swap since target comes from this line
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x1, y0: best.y1,
                    x1: best.x0, y1: best.y0
                };
            }
        }
        return best;
    },
    
    /**
     * APIMethod: simplify
     * This function will return a simplified LineString.
     * Simplification is based on the Douglas-Peucker algorithm.
     *
     *
     * Parameters:
     * tolerance - {number} threshhold for simplification in map units
     *
     * Returns:
     * {GeoGlobe.Geometry.LineString} the simplified LineString
     */
    simplify: function(tolerance){
        if (this && this !== null) {
            var points = this.getVertices();
            if (points.length < 3) {
                return this;
            }
    
            var compareNumbers = function(a, b){
                return (a-b);
            };
    
            /**
             * Private function doing the Douglas-Peucker reduction
             */
            var douglasPeuckerReduction = function(points, firstPoint, lastPoint, tolerance){
                var maxDistance = 0;
                var indexFarthest = 0;
    
                for (var index = firstPoint, distance; index < lastPoint; index++) {
                    distance = perpendicularDistance(points[firstPoint], points[lastPoint], points[index]);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        indexFarthest = index;
                    }
                }
    
                if (maxDistance > tolerance && indexFarthest != firstPoint) {
                    //Add the largest point that exceeds the tolerance
                    pointIndexsToKeep.push(indexFarthest);
                    douglasPeuckerReduction(points, firstPoint, indexFarthest, tolerance);
                    douglasPeuckerReduction(points, indexFarthest, lastPoint, tolerance);
                }
            };
    
            /**
             * Private function calculating the perpendicular distance
             * TODO: check whether GeoGlobe.Geometry.LineString::distanceTo() is faster or slower
             */
            var perpendicularDistance = function(point1, point2, point){
                //Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
                //Base = v((x1-x2)²+(x1-x2)²)                               *Base of Triangle*
                //Area = .5*Base*H                                          *Solve for height
                //Height = Area/.5/Base
    
                var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));
                var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
                var height = area / bottom * 2;
    
                return height;
            };
    
            var firstPoint = 0;
            var lastPoint = points.length - 1;
            var pointIndexsToKeep = [];
    
            //Add the first and last index to the keepers
            pointIndexsToKeep.push(firstPoint);
            pointIndexsToKeep.push(lastPoint);
    
            //The first and the last point cannot be the same
            while (points[firstPoint].equals(points[lastPoint])) {
                lastPoint--;
                //Addition: the first point not equal to first point in the LineString is kept as well
                pointIndexsToKeep.push(lastPoint);
            }
    
            douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);
            var returnPoints = [];
            pointIndexsToKeep.sort(compareNumbers);
            for (var index = 0; index < pointIndexsToKeep.length; index++) {
                returnPoints.push(points[pointIndexsToKeep[index]]);
            }
            return new GeoGlobe.Geometry.LineString(returnPoints);
    
        }
        else {
            return this;
        }
    },

    CLASS_NAME: "GeoGlobe.Geometry.LineString"
});

/**
 * APIMethod: GeoGlobe.Geometry.LineString.createCurveLine
 * 创建一个弧线几何对象。
 *
 * Parameters:
 * points - {Array(<GeoGlobe.Geometry.Point>)} 弧线的端点。
 */
GeoGlobe.Geometry.LineString.createCurveLine = function(points){
    var curvePoints = [];
	for (var i = 0; i < points.length - 1; i++) {
        var curveCoordinates = GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints(points[i], points[i + 1]);
        if (curveCoordinates && curveCoordinates.length > 0) {
            curvePoints = curvePoints.concat(curveCoordinates);
        }
    }
    var lineString = new Geo.Geometry.LineString(curvePoints);
    return lineString;
};

/**
 * Method: GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints
 * 根据弧线的两个端点获取曲线的坐标。
 *
 * Parameters:
 * point1 - {<GeoGlobe.Geometry.Point>} 弧线的一端点。
 * point2 - {<GeoGlobe.Geometry.Point>} 弧线的另一端点。
 */
GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints = function(point1, point2){
    if (!point1 || !point2 || !(point1 instanceof GeoGlobe.Geometry.Point) || !(point2 instanceof GeoGlobe.Geometry.Point)) {
        return null;
    }
    var o = function(h){
        return 1 - 2 * h + h * h;
    };
    var n = function(h){
        return 2 * h - 2 * h * h;
    };
    var m = function(h){
        return h * h;
    };
    curveCoordinates = [];
    var k = 30;
    var x = false;
    var r, y, l, e, A, u, p;
    var s = [];
    var v = 0;
    var q = 0;
    if (typeof(point2) == "undefined") {
        if (typeof(curveCoordinates) != "undefined") {
            curveCoordinates = [];
        }
        return;
    }
    var g = parseFloat(point1.y);
    var f = parseFloat(point2.y);
    var C = parseFloat(point1.x);
    var B = parseFloat(point2.x);
    if (B > C) {
        if (parseFloat(B - C) > 180) {
            if (C < 0) {
                C = parseFloat(180 + 180 + C);
            }
        }
    }
    if (C > B) {
        if (parseFloat(C - B) > 180) {
            if (B < 0) {
                B = parseFloat(180 + 180 + B);
            }
        }
    }
    u = 0;
    p = 0;
    if (f == g) {
        r = 0;
        y = C - B;
    }
    else {
        if (B == C) {
            r = Math.PI / 2;
            y = g - f;
        }
        else {
            r = Math.atan((f - g) / (B - C));
            y = (f - g) / Math.sin(r);
        }
    }
    if (p == 0) {
        p = (r + (Math.PI / 5));
    }
    l = y / 2;
    A = l * Math.cos(p) + C;
    e = l * Math.sin(p) + g;
    for (v = 0; v < k + 1; v++) {
        curveCoordinates.push(new GeoGlobe.Geometry.Point((C * o(q) + A * n(q)) + B * m(q), (g * o(q) + e * n(q) + f * m(q))));
        q = q + (1 / k);
    }
    return curveCoordinates;
};/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/LineString.js
 */

/**
 * Class: GeoGlobe.Geometry.LinearRing
 * 
 * A Linear Ring is a special LineString which is closed. It closes itself 
 * automatically on every addPoint/removePoint by adding a copy of the first
 * point as the last point. 
 * 
 * Also, as it is the first in the line family to close itself, a getArea()
 * function is defined to calculate the enclosed area of the linearRing
 * 闭合线几何对象类(起点与终点重合的线)。
 * 
 * Inherits:
 *  - <GeoGlobe.Geometry.LineString>
 */
GeoGlobe.Geometry.LinearRing = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.LineString, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of 
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**
     * Constructor: GeoGlobe.Geometry.LinearRing
     * Linear rings are constructed with an array of points.  This array
     *     can represent a closed or open ring.  If the ring is open (the last
     *     point does not equal the first point), the constructor will close
     *     the ring.  If the ring is already closed (the last point does equal
     *     the first point), it will be left closed.
     * 
     * Parameters:
     * points - {Array(<GeoGlobe.Geometry.Point>)} points
     */

    /**
     * APIMethod: addComponent
     * Adds a point to geometry components.  If the point is to be added to
     *     the end of the components array and it is the same as the last point
     *     already in that array, the duplicate point is not added.  This has 
     *     the effect of closing the ring if it is not already closed, and 
     *     doing the right thing if it is already closed.  This behavior can 
     *     be overridden by calling the method with a non-null index as the 
     *     second argument.
     *
     * Parameters:
     * point - {<GeoGlobe.Geometry.Point>}
     * index - {Integer} Index into the array to insert the component
     * 
     * Returns:
     * {Boolean} Was the Point successfully added?
     */
    addComponent: function(point, index) {
        var added = false;

        //remove last point
        var lastPoint = this.components.pop();

        // given an index, add the point
        // without an index only add non-duplicate points
        if(index != null || !point.equals(lastPoint)) {
            added = GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                    arguments);
        }

        //append copy of first point
        var firstPoint = this.components[0];
        GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        
        return added;
    },
    
    /**
     * APIMethod: removeComponent
     * Removes a point from geometry components.
     *
     * Parameters:
     * point - {<GeoGlobe.Geometry.Point>}
     *
     * Returns: 
     * {Boolean} The component was removed.
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 3);
        if (removed) {
            //remove last point
            this.components.pop();
            
            //remove our point
            GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                    arguments);
            //append copy of first point
            var firstPoint = this.components[0];
            GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        }
        return removed;
    },
    
    /**
     * APIMethod: move
     * Moves a geometry by the given displacement along positive x and y axes.
     *     This modifies the position of the geometry and clears the cached
     *     bounds.
     *
     * Parameters:
     * x - {Float} Distance to move geometry in positive x direction. 
     * y - {Float} Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        for(var i = 0, len=this.components.length; i<len - 1; i++) {
            this.components[i].move(x, y);
        }
    },

    /**
     * APIMethod: rotate
     * Rotate a geometry around some origin
     *
     * Parameters:
     * angle - {Float} Rotation angle in degrees (measured counterclockwise
     *                 from the positive x-axis)
     * origin - {<GeoGlobe.Geometry.Point>} Center point for the rotation
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**
     * APIMethod: resize
     * Resize a geometry relative to some origin.  Use this method to apply
     *     a uniform scaling to a geometry.
     *
     * Parameters:
     * scale - {Float} Factor by which to scale the geometry.  A scale of 2
     *                 doubles the size of the geometry in each dimension
     *                 (lines, for example, will be twice as long, and polygons
     *                 will have four times the area).
     * origin - {<GeoGlobe.Geometry.Point>} Point of origin for resizing
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
     * 
     * Returns:
     * {<GeoGlobe.Geometry>} - The current geometry. 
     */
    resize: function(scale, origin, ratio) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },
    
    /**
     * APIMethod: transform
     * Reproject the components geometry from source to dest.
     *
     * Parameters:
     * source - {<GeoGlobe.SpatialReference>}
     * dest - {<GeoGlobe.SpatialReference>}
     * 
     * Returns:
     * {<GeoGlobe.Geometry>} 
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },
    
    /**
     * APIMethod: getCentroid
     *
     * Returns:
     * {<GeoGlobe.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function() {
        if (this.components) {
            var len = this.components.length;
            if (len > 0 && len <= 2) {
                return this.components[0].clone();
            } else if (len > 2) {
                var sumX = 0.0;
                var sumY = 0.0;
                var x0 = this.components[0].x;
                var y0 = this.components[0].y;
                var area = -1 * this.getArea();
                if (area != 0) {
                    for (var i = 0; i < len - 1; i++) {
                        var b = this.components[i];
                        var c = this.components[i+1];
                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                    }
                    var x = x0 + sumX / (6 * area);
                    var y = y0 + sumY / (6 * area);
                } else {
                    for (var i = 0; i < len - 1; i++) {
                        sumX += this.components[i].x;
                        sumY += this.components[i].y;
                    }
                    var x = sumX / (len - 1);
                    var y = sumY / (len - 1);
                }
                return new GeoGlobe.Geometry.Point(x, y);
            } else {
                return null;
            }
        }
    },

    /**
     * APIMethod: getArea
     * Note - The area is positive if the ring is oriented CW, otherwise
     *         it will be negative.
     * 
     * Returns:
     * {Float} The signed area for a ring.
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 2)) {
            var sum = 0.0;
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var b = this.components[i];
                var c = this.components[i+1];
                sum += (b.x + c.x) * (c.y - b.y);
            }
            area = - sum / 2.0;
        }
        return area;
    },
    
    /**
     * APIMethod: getGeodesicArea
     * Calculate the approximate area of the polygon were it projected onto
     *     the earth.  Note that this area will be positive if ring is oriented
     *     clockwise, otherwise it will be negative.
     *
     * Parameters:
     * projection - {<GeoGlobe.SpatialReference>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * Returns:
     * {float} The approximate signed geodesic area of the polygon in square
     *     meters.
     */
    getGeodesicArea: function(projection) {
        var ring = this;  // so we can work with a clone if needed
        if(projection) {
            //var gg = new OpenLayers.Projection("EPSG:4326");
            var gg = new GeoGlobe.SpatialReference("EPSG:4326");
            if(!gg.equals(projection)) {
                ring = this.clone().transform(projection, gg);
            }
        }
        var area = 0.0;
        var len = ring.components && ring.components.length;
        if(len > 2) {
            var p1, p2;
            for(var i=0; i<len-1; i++) {
                p1 = ring.components[i];
                p2 = ring.components[i+1];
                area += GeoGlobe.Util.rad(p2.x - p1.x) *
                        (2 + Math.sin(GeoGlobe.Util.rad(p1.y)) +
                        Math.sin(GeoGlobe.Util.rad(p2.y)));
            }
            area = area * 6378137.0 * 6378137.0 / 2.0;
        }
        return area;
    },
    
    /**
     * Method: containsPoint
     * Test if a point is inside a linear ring.  For the case where a point
     *     is coincident with a linear ring edge, returns 1.  Otherwise,
     *     returns boolean.
     *
     * Parameters:
     * point - {<GeoGlobe.Geometry.Point>}
     *
     * Returns:
     * {Boolean | Number} The point is inside the linear ring.  Returns 1 if
     *     the point is coincident with an edge.  Returns boolean otherwise.
     */
    containsPoint: function(point) {
        var approx = GeoGlobe.Number.limitSigDigs;
        var digs = 14;
        var px = approx(point.x, digs);
        var py = approx(point.y, digs);
        function getX(y, x1, y1, x2, y2) {
            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
        }
        var numSeg = this.components.length - 1;
        var start, end, x1, y1, x2, y2, cx, cy;
        var crosses = 0;
        for(var i=0; i<numSeg; ++i) {
            start = this.components[i];
            x1 = approx(start.x, digs);
            y1 = approx(start.y, digs);
            end = this.components[i + 1];
            x2 = approx(end.x, digs);
            y2 = approx(end.y, digs);
            
            /**
             * The following conditions enforce five edge-crossing rules:
             *    1. points coincident with edges are considered contained;
             *    2. an upward edge includes its starting endpoint, and
             *    excludes its final endpoint;
             *    3. a downward edge excludes its starting endpoint, and
             *    includes its final endpoint;
             *    4. horizontal edges are excluded; and
             *    5. the edge-ray intersection point must be strictly right
             *    of the point P.
             */
            if(y1 == y2) {
                // horizontal edge
                if(py == y1) {
                    // point on horizontal line
                    if(x1 <= x2 && (px >= x1 && px <= x2) || // right or vert
                       x1 >= x2 && (px <= x1 && px >= x2)) { // left or vert
                        // point on edge
                        crosses = -1;
                        break;
                    }
                }
                // ignore other horizontal edges
                continue;
            }
            cx = approx(getX(py, x1, y1, x2, y2), digs);
            if(cx == px) {
                // point on line
                if(y1 < y2 && (py >= y1 && py <= y2) || // upward
                   y1 > y2 && (py <= y1 && py >= y2)) { // downward
                    // point on edge
                    crosses = -1;
                    break;
                }
            }
            if(cx <= px) {
                // no crossing to the right
                continue;
            }
            if(x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
                // no crossing
                continue;
            }
            if(y1 < y2 && (py >= y1 && py < y2) || // upward
               y1 > y2 && (py < y1 && py >= y2)) { // downward
                ++crosses;
            }
        }
        var contained = (crosses == -1) ?
            // on edge
            1 :
            // even (out) or odd (in)
            !!(crosses & 1);

        return contained;
    },

    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LineString") {
            intersect = geometry.intersects(this);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") {
            intersect = GeoGlobe.Geometry.LineString.prototype.intersects.apply(
                this, [geometry]
            );
        } else {
            // check for component intersections
            for(var i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = geometry.components[i].intersects(this);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        return (nodes === true) ? [] : this.components.slice(0, this.components.length-1);
    },

    CLASS_NAME: "GeoGlobe.Geometry.LinearRing"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/Collection.js
 * @requires View2D/Geometry/LinearRing.js
 */

/**
 * Class: GeoGlobe.Geometry.Polygon 
 * Polygon is a collection of Geometry.LinearRings. 
 * 多边形几何对象类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection> 
 *  - <GeoGlobe.Geometry> 
 */
GeoGlobe.Geometry.Polygon = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["GeoGlobe.Geometry.LinearRing"],

    /**
     * Constructor: GeoGlobe.Geometry.Polygon
     * Constructor for a Polygon geometry. 
     * The first ring (this.component[0])is the outer bounds of the polygon and 
     * all subsequent rings (this.component[1-n]) are internal holes.
     *
     *
     * Parameters:
     * components - {Array(<GeoGlobe.Geometry.LinearRing>)} 
     */

    /** 
     * APIMethod: getArea
     * Calculated by subtracting the areas of the internal holes from the 
     *   area of the outer hole.
     * 
     * Returns:
     * {float} The area of the geometry
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getArea());
            for (var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getArea());
            }
        }
        return area;
    },

    /** 
     * APIMethod: getGeodesicArea
     * Calculate the approximate area of the polygon were it projected onto
     *     the earth.
     *
     * Parameters:
     * projection - {<OpenLayers.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * Returns:
     * {float} The approximate geodesic area of the polygon in square meters.
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        if(this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getGeodesicArea(projection));
            for(var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getGeodesicArea(projection));
            }
        }
        return area;
    },

    /**
     * Method: containsPoint
     * Test if a point is inside a polygon.  Points on a polygon edge are
     *     considered inside.
     *
     * Parameters:
     * point - {<GeoGlobe.Geometry.Point>}
     *
     * Returns:
     * {Boolean | Number} The point is inside the polygon.  Returns 1 if the
     *     point is on an edge.  Returns boolean otherwise.
     */
    containsPoint: function(point) {
        var numRings = this.components.length;
        var contained = false;
        if(numRings > 0) {
            // check exterior ring - 1 means on edge, boolean otherwise
            contained = this.components[0].containsPoint(point);
            if(contained !== 1) {
                if(contained && numRings > 1) {
                    // check interior rings
                    var hole;
                    for(var i=1; i<numRings; ++i) {
                        hole = this.components[i].containsPoint(point);
                        if(hole) {
                            if(hole === 1) {
                                // on edge
                                contained = 1;
                            } else {
                                // in hole
                                contained = false;
                            }                            
                            break;
                        }
                    }
                }
            }
        }
        return contained;
    },

    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     * 确定输入几何是否相交。 
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        var i, len;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LineString" ||
                  geometry.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") {
            // check if rings/linestrings intersect
            for(i=0, len=this.components.length; i<len; ++i) {
                intersect = geometry.intersects(this.components[i]);
                if(intersect) {
                    break;
                }
            }
            if(!intersect) {
                // check if this poly contains points of the ring/linestring
                for(i=0, len=geometry.components.length; i<len; ++i) {
                    intersect = this.containsPoint(geometry.components[i]);
                    if(intersect) {
                        break;
                    }
                }
            }
        } else {
            for(i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = this.intersects(geometry.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        // check case where this poly is wholly contained by another
        if(!intersect && geometry.CLASS_NAME == "GeoGlobe.Geometry.Polygon") {
            // exterior ring points will be contained in the other geometry
            var ring = this.components[0];
            for(i=0, len=ring.components.length; i<len; ++i) {
                intersect = geometry.containsPoint(ring.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var result;
        // this is the case where we might not be looking for distance to edge
        if(!edge && this.intersects(geometry)) {
            result = 0;
        } else {
            result = GeoGlobe.Geometry.Collection.prototype.distanceTo.apply(
                this, [geometry, options]
            );
        }
        return result;
    },

    CLASS_NAME: "GeoGlobe.Geometry.Polygon"
});

/**
 * APIMethod: createRegularPolygon
 * Create a regular polygon around a radius. Useful for creating circles 
 * and the like.
 *
 * Parameters:
 * origin - {<GeoGlobe.Geometry.Point>} center of polygon.
 * radius - {Float} distance to vertex, in map units.
 * sides - {Integer} Number of sides. 20 approximates a circle.
 * rotation - {Float} original angle of rotation, in degrees.
 */
GeoGlobe.Geometry.Polygon.createRegularPolygon = function(origin, radius, sides, rotation) {  
    var angle = Math.PI * ((1/sides) - (1/2));
    if(rotation) {
        angle += (rotation / 180) * Math.PI;
    }
    var rotatedAngle, x, y;
    var points = [];
    for(var i=0; i<sides; ++i) {
        rotatedAngle = angle + (i * 2 * Math.PI / sides);
        x = origin.x + (radius * Math.cos(rotatedAngle));
        y = origin.y + (radius * Math.sin(rotatedAngle));
        points.push(new GeoGlobe.Geometry.Point(x, y));
    }
    var ring = new GeoGlobe.Geometry.LinearRing(points);
    return new GeoGlobe.Geometry.Polygon([ring]);
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/Collection.js
 * @requires View2D/Geometry/LineString.js
 */

/**
 * Class: GeoGlobe.Geometry.MultiLineString
 * A MultiLineString is a geometry with multiple <GeoGlobe.Geometry.LineString>
 * components.
 * 线集合几何对象类，由多个线几何对象（非闭合线）组成的。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection>
 *  - <GeoGlobe.Geometry> 
 */
GeoGlobe.Geometry.MultiLineString = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["GeoGlobe.Geometry.LineString"],

    /**
     * Constructor: GeoGlobe.Geometry.MultiLineString
     * Constructor for a MultiLineString Geometry.
     *
     * Parameters: 
     * components - {Array(<GeoGlobe.Geometry.LineString>)} 
     *
     */
    
    /**
     * Method: split
     * Use this geometry (the source) to attempt to split a target geometry.
     * 
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The target geometry.
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    split: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, sourceLine, sourceLines, sourceSplit, targetSplit;
        var sourceParts = [];
        var targetParts = [geometry];
        for(var i=0, len=this.components.length; i<len; ++i) {
            sourceLine = this.components[i];
            sourceSplit = false;
            for(var j=0; j < targetParts.length; ++j) { 
                splits = sourceLine.split(targetParts[j], options);
                if(splits) {
                    if(mutual) {
                        sourceLines = splits[0];
                        for(var k=0, klen=sourceLines.length; k<klen; ++k) {
                            if(k===0 && sourceParts.length) {
                                sourceParts[sourceParts.length-1].addComponent(
                                    sourceLines[k]
                                );
                            } else {
                                sourceParts.push(
                                    new GeoGlobe.Geometry.MultiLineString([
                                        sourceLines[k]
                                    ])
                                );
                            }
                        }
                        sourceSplit = true;
                        splits = splits[1];
                    }
                    if(splits.length) {
                        // splice in new target parts
                        splits.unshift(j, 1);
                        Array.prototype.splice.apply(targetParts, splits);
                        break;
                    }
                }
            }
            if(!sourceSplit) {
                // source line was not hit
                if(sourceParts.length) {
                    // add line to existing multi
                    sourceParts[sourceParts.length-1].addComponent(
                        sourceLine.clone()
                    );
                } else {
                    // create a fresh multi
                    sourceParts = [
                        new GeoGlobe.Geometry.MultiLineString(
                            sourceLine.clone()
                        )
                    ];
                }
            }
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },
    
    /**
     * Method: splitWith
     * Split this geometry (the target) with the given geometry (the source).
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} A geometry used to split this
     *     geometry (the source).
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    splitWith: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, targetLine, sourceLines, sourceSplit, targetSplit, sourceParts, targetParts;
        if(geometry instanceof GeoGlobe.Geometry.LineString) {
            targetParts = [];
            sourceParts = [geometry];
            for(var i=0, len=this.components.length; i<len; ++i) {
                targetSplit = false;
                targetLine = this.components[i];
                for(var j=0; j<sourceParts.length; ++j) {
                    splits = sourceParts[j].split(targetLine, options);
                    if(splits) {
                        if(mutual) {
                            sourceLines = splits[0];
                            if(sourceLines.length) {
                                // splice in new source parts
                                sourceLines.unshift(j, 1);
                                Array.prototype.splice.apply(sourceParts, sourceLines);
                                j += sourceLines.length - 2;
                            }
                            splits = splits[1];
                            if(splits.length === 0) {
                                splits = [targetLine.clone()];
                            }
                        }
                        for(var k=0, klen=splits.length; k<klen; ++k) {
                            if(k===0 && targetParts.length) {
                                targetParts[targetParts.length-1].addComponent(
                                    splits[k]
                                );
                            } else {
                                targetParts.push(
                                    new GeoGlobe.Geometry.MultiLineString([
                                        splits[k]
                                    ])
                                );
                            }
                        }
                        targetSplit = true;                    
                    }
                }
                if(!targetSplit) {
                    // target component was not hit
                    if(targetParts.length) {
                        // add it to any existing multi-line
                        targetParts[targetParts.length-1].addComponent(
                            targetLine.clone()
                        );
                    } else {
                        // or start with a fresh multi-line
                        targetParts = [
                            new GeoGlobe.Geometry.MultiLineString([
                                targetLine.clone()
                            ])
                        ];
                    }
                    
                }
            }
        } else {
            results = geometry.split(this);
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    CLASS_NAME: "GeoGlobe.Geometry.MultiLineString"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Geometry/Collection.js
 * @requires View2D/Geometry/Polygon.js
 */

/**
 * Class: GeoGlobe.Geometry.MultiPolygon
 * MultiPolygon is a geometry with multiple <GeoGlobe.Geometry.Polygon>
 * components.  Create a new instance with the <GeoGlobe.Geometry.MultiPolygon>
 * constructor.
 * 多边形集合几何对象类，由多个多边形几何对象组成。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection>
 */
GeoGlobe.Geometry.MultiPolygon = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["GeoGlobe.Geometry.Polygon"],

    /**
     * Constructor: GeoGlobe.Geometry.MultiPolygon
     * Create a new MultiPolygon geometry
     *
     * Parameters:
     * components - {Array(<GeoGlobe.Geometry.Polygon>)} An array of polygons
     *              used to generate the MultiPolygon
     *
     */

    CLASS_NAME: "GeoGlobe.Geometry.MultiPolygon"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

// TRASH THIS
GeoGlobe.State = {
    /** states */
    UNKNOWN: 'Unknown',
    INSERT: 'Insert',
    UPDATE: 'Update',
    DELETE: 'Delete'
};

/**
 * @requires View2D/tool/Util.js
 */

/**
 * Class: GeoGlobe.Feature
 * Vector features use the GeoGlobe.Geometry classes as geometry description.
 * They have an 'attributes' property, which is the data object, and a 'style'
 * property, the default values of which are defined in the 
 * <GeoGlobe.Feature.style> objects.
 * 
 */
GeoGlobe.Feature = GeoGlobe.Class4OL({

	/** 
     * Property: id 
     * {String} 
     */
    id: null,
	
    /** 
     * Property: fid 
     * {String} 
     */
    fid: null,
	
	/** 
     * Property: lonlat 
     * {<GeoGlobe.LngLat>} 
     */
    lonlat: null,
    
    /** 
     * APIProperty: geometry 
     * {<GeoGlobe.Geometry>} 
     */
    geometry: null,

    /** 
     * APIProperty: attributes 
     * {Object} This object holds arbitrary, serializable properties that
     *     describe the feature.
     */
    attributes: null,
	
	/** 
     * Property: data 
     * {Object} 
     */
    data: null,
	
    /**
     * Property: bounds
     * {<GeoGlobe.LngLatBounds>} The box bounding that feature's geometry, that
     *     property can be set by an <GeoGlobe.Format> object when
     *     deserializing the feature, so in most cases it represents an
     *     information set by the server. 
     */
    bounds: null,

    /** 
     * Property: state 
     * {String} 
     */
    state: null,
    
    /**
     * APIProperty: url
     * {String} If this property is set it will be taken into account by
     *     {<GeoGlobe.HTTP>} when upadting or deleting the feature.
     */
    url: null,
    
    /**
     * Property: renderIntent
     * {String} rendering intent currently being used
     */
    //renderIntent: "default",
    
    /**
     * APIProperty: modified
     * {Object} An object with the originals of the geometry and attributes of
     * the feature, if they were changed. Currently this property is only read
     * by <GeoGlobe.Format.WFST.v1>, and written by
     * <OpenLayers.Control.ModifyFeature>, which sets the geometry property.
     * Applications can set the originals of modified attributes in the
     * attributes property. Note that applications have to check if this
     * object and the attributes property is already created before using it.
     * After a change made with ModifyFeature, this object could look like
     *
     * (code)
     * {
     *     geometry: >Object
     * }
     * (end)
     *
     * When an application has made changes to feature attributes, it could
     * have set the attributes to something like this:
     *
     * (code)
     * {
     *     attributes: {
     *         myAttribute: "original"
     *     }
     * }
     * (end)
     *
     * Note that <GeoGlobe.Format.WFST.v1> only checks for truthy values in
     * *modified.geometry* and the attribute names in *modified.attributes*,
     * but it is recommended to set the original values (and not just true) as
     * attribute value, so applications could use this information to undo
     * changes.
     */
    modified: null,

    /** 
     * Constructor: GeoGlobe.Feature
     * Create a vector feature. 
     * 
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>} The geometry that this feature
     *     represents.
     * attributes - {Object} An optional object that will be mapped to the
     *     <attributes> property. 
     */
    initialize: function(geometry, attributes) {
        //OpenLayers.Feature.prototype.initialize.apply(this,[null, null, attributes]);
		this.data = (attributes != null) ? attributes : {};
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME + "_"); 
        this.lonlat = null;
        this.geometry = geometry ? geometry : null;
        this.state = null;
        this.attributes = {};
        if (attributes) {
            this.attributes = GeoGlobe.Util.extend(this.attributes,
                                                     attributes);
        }
        //this.style = style ? style : null; 
    },
    
    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {
        //if (this.layer) {
        //    this.layer.removeFeatures(this);
        //    this.layer = null;
        //}
            
        this.geometry = null;
        this.modified = null;
        //OpenLayers.Feature.prototype.destroy.apply(this, arguments);
		this.id = null;
        this.lonlat = null;
        this.data = null;
    },
    
    /**
     * Method: clone
     * Create a clone of this vector feature.  Does not set any non-standard
     *     properties.
     *
     * Returns:
     * {<GeoGlobe.Feature} An exact clone of this vector feature.
     */
    clone: function () {
        return new GeoGlobe.Feature(
            this.geometry ? this.geometry.clone() : null,
            this.attributes);
    },

    /**
     * Method: onScreen
     * Determine whether the feature is within the map viewport.  This method
     *     tests for an intersection between the geometry and the viewport
     *     bounds.  If a more effecient but less precise geometry bounds
     *     intersection is desired, call the method with the boundsOnly
     *     parameter true.
     *
     * Parameters:
     * boundsOnly - {Boolean} Only test whether a feature's bounds intersects
     *     the viewport bounds.  Default is false.  If false, the feature's
     *     geometry must intersect the viewport for onScreen to return true.
     * 
     * Returns:
     * {Boolean} The feature is currently visible on screen (optionally
     *     based on its bounds if boundsOnly is true).
     */
	/*
    onScreen:function(boundsOnly) {
        var onScreen = false;
        if(this.layer && this.layer.map) {
            var screenBounds = this.layer.map.getExtent();
            if(boundsOnly) {
                var featureBounds = this.geometry.getBounds();
                onScreen = screenBounds.intersectsBounds(featureBounds);
            } else {
                var screenPoly = screenBounds.toGeometry();
                onScreen = screenPoly.intersects(this.geometry);
            }
        }    
        return onScreen;
    },
    */

    /**
     * Method: getVisibility
     * Determine whether the feature is displayed or not. It may not displayed
     *     because:
     *     - its style display property is set to 'none',
     *     - it doesn't belong to any layer,
     *     - the styleMap creates a symbolizer with display property set to 'none'
     *          for it,
     *     - the layer which it belongs to is not visible.
     * 
     * Returns:
     * {Boolean} The feature is currently displayed.
     */
	/*
    getVisibility: function() {
        return !(this.style && this.style.display == 'none' ||
                 !this.layer ||
                 this.layer && this.layer.styleMap &&
                 this.layer.styleMap.createSymbolizer(this, this.renderIntent).display == 'none' ||
                 this.layer && !this.layer.getVisibility());
    },
    */
    /**
     * Method: createMarker
     * HACK - we need to decide if all vector features should be able to
     *     create markers
     * 
     * Returns:
     * {<GeoGlobe.Marker>} For now just returns null
     */
    createMarker: function() {
        return null;
    },

    /**
     * Method: destroyMarker
     * HACK - we need to decide if all vector features should be able to
     *     delete markers
     * 
     * If user overrides the createMarker() function, s/he should be able
     *   to also specify an alternative function for destroying it
     */
    destroyMarker: function() {
        // pass
    },

    /**
     * Method: createPopup
     * HACK - we need to decide if all vector features should be able to
     *     create popups
     * 
     * Returns:
     * {<GeoGlobe.Popup>} For now just returns null
     */
    createPopup: function() {
        return null;
    },

    /**
     * Method: atPoint
     * Determins whether the feature intersects with the specified location.
     * 
     * Parameters: 
     * lonlat - {<GeoGlobe.LngLat>|Object} OpenLayers.LonLat or an
     *     object with a 'lon' and 'lat' properties.
     * toleranceLon - {float} Optional tolerance in Geometric Coords
     * toleranceLat - {float} Optional tolerance in Geographic Coords
     * 
     * Returns:
     * {Boolean} Whether or not the feature is at the specified location
     */
    atPoint: function(lonlat, toleranceLon, toleranceLat) {
        var atPoint = false;
        if(this.geometry) {
            atPoint = this.geometry.atPoint(lonlat, toleranceLon, 
                                                    toleranceLat);
        }
        return atPoint;
    },

    /**
     * Method: destroyPopup
     * HACK - we need to decide if all vector features should be able to
     * delete popups
     */
    destroyPopup: function() {
        // pass
    },

    /**
     * Method: move
     * Moves the feature and redraws it at its new location
     *
     * Parameters:
     * location - {<OpenLayers.LonLat> or <OpenLayers.Pixel>} the
     *         location to which to move the feature.
     */
	/*
    move: function(location) {

        if(!this.layer || !this.geometry.move){
            //do nothing if no layer or immoveable geometry
            return undefined;
        }

        var pixel;
        if (location.CLASS_NAME == "OpenLayers.LonLat") {
            pixel = this.layer.getViewPortPxFromLonLat(location);
        } else {
            pixel = location;
        }
        
        var lastPixel = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat());
        var res = this.layer.map.getResolution();
        this.geometry.move(res * (pixel.x - lastPixel.x),
                           res * (lastPixel.y - pixel.y));
        this.layer.drawFeature(this);
        return lastPixel;
    },
    */
    
    /**
     * Method: toState
     * Sets the new state
     *
     * Parameters:
     * state - {String} 
     */
    toState: function(state) {
        if (state == GeoGlobe.State.UPDATE) {
            switch (this.state) {
                case GeoGlobe.State.UNKNOWN:
                case GeoGlobe.State.DELETE:
                    this.state = state;
                    break;
                case GeoGlobe.State.UPDATE:
                case GeoGlobe.State.INSERT:
                    break;
            }
        } else if (state == GeoGlobe.State.INSERT) {
            switch (this.state) {
                case GeoGlobe.State.UNKNOWN:
                    break;
                default:
                    this.state = state;
                    break;
            }
        } else if (state == GeoGlobe.State.DELETE) {
            switch (this.state) {
                case GeoGlobe.State.INSERT:
                    // the feature should be destroyed
                    break;
                case GeoGlobe.State.DELETE:
                    break;
                case GeoGlobe.State.UNKNOWN:
                case GeoGlobe.State.UPDATE:
                    this.state = state;
                    break;
            }
        } else if (state == GeoGlobe.State.UNKNOWN) {
            this.state = state;
        }
    },
    
    CLASS_NAME: "GeoGlobe.Feature"
});


/**
 * Constant: GeoGlobe.Feature.style
 * OpenLayers features can have a number of style attributes. The 'default' 
 *     style will typically be used if no other style is specified. These
 *     styles correspond for the most part, to the styling properties defined
 *     by the SVG standard. 
 *     Information on fill properties: http://www.w3.org/TR/SVG/painting.html#FillProperties
 *     Information on stroke properties: http://www.w3.org/TR/SVG/painting.html#StrokeProperties
 *
 * Symbolizer properties:
 * fill - {Boolean} Set to false if no fill is desired.
 * fillColor - {String} Hex fill color.  Default is "#ee9900".
 * fillOpacity - {Number} Fill opacity (0-1).  Default is 0.4 
 * stroke - {Boolean} Set to false if no stroke is desired.
 * strokeColor - {String} Hex stroke color.  Default is "#ee9900".
 * strokeOpacity - {Number} Stroke opacity (0-1).  Default is 1.
 * strokeWidth - {Number} Pixel stroke width.  Default is 1.
 * strokeLinecap - {String} Stroke cap type.  Default is "round".  [butt | round | square]
 * strokeDashstyle - {String} Stroke dash style.  Default is "solid". [dot | dash | dashdot | longdash | longdashdot | solid]
 * graphic - {Boolean} Set to false if no graphic is desired.
 * pointRadius - {Number} Pixel point radius.  Default is 6.
 * pointerEvents - {String}  Default is "visiblePainted".
 * cursor - {String} Default is "".
 * externalGraphic - {String} Url to an external graphic that will be used for rendering points.
 * graphicWidth - {Number} Pixel width for sizing an external graphic.
 * graphicHeight - {Number} Pixel height for sizing an external graphic.
 * graphicOpacity - {Number} Opacity (0-1) for an external graphic.
 * graphicXOffset - {Number} Pixel offset along the positive x axis for displacing an external graphic.
 * graphicYOffset - {Number} Pixel offset along the positive y axis for displacing an external graphic.
 * rotation - {Number} For point symbolizers, this is the rotation of a graphic in the clockwise direction about its center point (or any point off center as specified by graphicXOffset and graphicYOffset).
 * graphicZIndex - {Number} The integer z-index value to use in rendering.
 * graphicName - {String} Named graphic to use when rendering points.  Supported values include "circle" (default),
 *     "square", "star", "x", "cross", "triangle".
 * graphicTitle - {String} Tooltip when hovering over a feature. *deprecated*, use title instead
 * title - {String} Tooltip when hovering over a feature. Not supported by the canvas renderer.
 * backgroundGraphic - {String} Url to a graphic to be used as the background under an externalGraphic.
 * backgroundGraphicZIndex - {Number} The integer z-index value to use in rendering the background graphic.
 * backgroundXOffset - {Number} The x offset (in pixels) for the background graphic.
 * backgroundYOffset - {Number} The y offset (in pixels) for the background graphic.
 * backgroundHeight - {Number} The height of the background graphic.  If not provided, the graphicHeight will be used.
 * backgroundWidth - {Number} The width of the background width.  If not provided, the graphicWidth will be used.
 * label - {String} The text for an optional label. For browsers that use the canvas renderer, this requires either
 *     fillText or mozDrawText to be available.
 * labelAlign - {String} Label alignment. This specifies the insertion point relative to the text. It is a string
 *     composed of two characters. The first character is for the horizontal alignment, the second for the vertical
 *     alignment. Valid values for horizontal alignment: "l"=left, "c"=center, "r"=right. Valid values for vertical
 *     alignment: "t"=top, "m"=middle, "b"=bottom. Example values: "lt", "cm", "rb". Default is "cm".
 * labelXOffset - {Number} Pixel offset along the positive x axis for displacing the label. Not supported by the canvas renderer.
 * labelYOffset - {Number} Pixel offset along the positive y axis for displacing the label. Not supported by the canvas renderer.
 * labelSelect - {Boolean} If set to true, labels will be selectable using SelectFeature or similar controls.
 *     Default is false.
 * labelOutlineColor - {String} The color of the label outline. Default is 'white'. Only supported by the canvas & SVG renderers.
 * labelOutlineWidth - {Number} The width of the label outline. Default is 3, set to 0 or null to disable. Only supported by the  SVG renderers.
 * labelOutlineOpacity - {Number} The opacity (0-1) of the label outline. Default is fontOpacity. Only supported by the canvas & SVG renderers.
 * fontColor - {String} The font color for the label, to be provided like CSS.
 * fontOpacity - {Number} Opacity (0-1) for the label
 * fontFamily - {String} The font family for the label, to be provided like in CSS.
 * fontSize - {String} The font size for the label, to be provided like in CSS.
 * fontStyle - {String} The font style for the label, to be provided like in CSS.
 * fontWeight - {String} The font weight for the label, to be provided like in CSS.
 * display - {String} Symbolizers will have no effect if display is set to "none".  All other values have no effect.
 */
/*
GeoGlobe.Feature.style = {
    'default': {
        fillColor: "#ee9900",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#ee9900",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    'select': {
        fillColor: "blue",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "blue",
        strokeOpacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'temporary': {
        fillColor: "#66cccc",
        fillOpacity: 0.2, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#66cccc",
        strokeOpacity: 1,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'delete': {
        display: "none"
    }
};
*/

/**
 * Method: getBoundsByFeatures
 * 获取要素数组范围
 *
 * Parameters:
 * features - {Array(<GeoGlobe.Feature>)}
 *
 * Returns:
 * {<GeoGlobe.LngLatBounds>} 数据范围对象。
 */
GeoGlobe.Feature.getBoundsByFeatures = function(features){
	var len = features.length;
	var geometries = new Array(len);
	for (var i=0; i<len; ++i) {
		geometries[i] = features[i].geometry;
	}
	var geom = new GeoGlobe.Geometry.Collection(geometries);
	geom.calculateBounds();
	return geom.bounds;
};

/**
 * Function: GeoGlobe.Feature.fromGeoJson
 * 根据geojson对象，获得GeoGlobe.Feature对象数组
 * 
 * Returns:
 * {Array(<GeoGlobe.Feature>)} 要素对象数组。
 */
GeoGlobe.Feature.fromGeoJson = function(geojson) {
    var fea;
    if (GeoGlobe.Format && GeoGlobe.Format.GeoJSON) {
        format = new GeoGlobe.Format.GeoJSON();
    	var fea = format.read(geojson);
    }
    return fea;
};/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @requires View2D/tool/Class.js
 * @requires View2D/tool/Util.js
 */

/**
 * Class: GeoGlobe.Filter
 * This class represents an OGC Filter.
 * 支持OGC标准的过滤器类。
 */
GeoGlobe.Filter = GeoGlobe.Class4OL({
    
    /** 
     * Constructor: GeoGlobe.Filter
     * This class represents a generic filter.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     * 
     * Returns:
     * {<GeoGlobe.Filter>}
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
    },

    /** 
     * APIMethod: destroy
     * Remove reference to anything added.
     */
    destroy: function() {
    },

    /**
     * APIMethod: evaluate
     * Evaluates this filter in a specific context.  Instances or subclasses
     * are supposed to override this method.
     * 
     * Parameters:
     * context - {Object} Context to use in evaluating the filter.  If a vector
     *     feature is provided, the feature.attributes will be used as context.
     * 
     * Returns:
     * {Boolean} The filter applies.
     */
    evaluate: function(context) {
        return true;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter. Should be implemented by subclasses.
     * 
     * Returns:
     * {<GeoGlobe.Filter>} Clone of this filter.
     */
    clone: function() {
        return null;
    },
    
    /**
     * APIMethod: toString
     *
     * Returns:
     * {String} Include <GeoGlobe.Format.CQL> in your build to get a CQL
     *     representation of the filter returned. Otherwise "[Object object]"
     *     will be returned.
     */
    toString: function() {
        var string;
        if (GeoGlobe.Format && GeoGlobe.Format.CQL) {
            string = GeoGlobe.Format.CQL.prototype.write(this);
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },
    
    CLASS_NAME: "GeoGlobe.Filter"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @requires View2D/Filter/Filter.js
 */

/**
 * Class: GeoGlobe.Filter.FeatureId
 * This class represents a ogc:FeatureId Filter, as being used for rule-based SLD
 * styling
 * OGC：FeatureId过滤器，用于SLD样式规则。
 * 
 * Inherits from:
 * - <GeoGlobe.Filter>
 */
GeoGlobe.Filter.FeatureId = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /** 
     * APIProperty: fids
     * {Array(String)} Feature Ids to evaluate this rule against. 
     *     To be passed inside the params object.
     */
    fids: null,
    
    /** 
     * Property: type
     * {String} Type to identify this filter.
     */
    type: "FID",
    
    /** 
     * Constructor: GeoGlobe.Filter.FeatureId
     * Creates an ogc:FeatureId rule.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *           rule
     * 
     * Returns:
     * {<GeoGlobe.Filter.FeatureId>}
     */
    initialize: function(options) {
        this.fids = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: evaluate
     * evaluates this rule for a specific feature
     * 
     * Parameters:
     * feature - {<GeoGlobe.Feature>} feature to apply the rule to.
     *           For vector features, the check is run against the fid,
     *           for plain features against the id.
     * 
     * Returns:
     * {Boolean} true if the rule applies, false if it does not
     */
    evaluate: function(feature) {
        for (var i=0, len=this.fids.length; i<len; i++) {
            var fid = feature.fid || feature.id;
            if (fid == this.fids[i]) {
                return true;
            }
        }
        return false;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<GeoGlobe.Filter.FeatureId>} Clone of this filter.
     */
    clone: function() {
        var filter = new GeoGlobe.Filter.FeatureId();
        GeoGlobe.Util.extend(filter, this);
        filter.fids = this.fids.slice();
        return filter;
    },
    
    CLASS_NAME: "GeoGlobe.Filter.FeatureId"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @requires View2D/Filter/Filter.js
 */

/**
 * Class: GeoGlobe.Filter.Logical
 * This class represents ogc:And, ogc:Or and ogc:Not rules.
 * OGC逻辑运算符规则过滤器类。
 * 
 * Inherits from:
 * - <GeoGlobe.Filter>
 */
GeoGlobe.Filter.Logical = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * APIProperty: filters
     * {Array(<GeoGlobe.Filter>)} Child filters for this filter.
     */
    filters: null, 
     
    /**
     * APIProperty: type
     * {String} type of logical operator. Available types are:
     * - GeoGlobe.Filter.Logical.AND = "&&";
     * - GeoGlobe.Filter.Logical.OR  = "||";
     * - GeoGlobe.Filter.Logical.NOT = "!";
     */
    type: null,

    /** 
     * Constructor: GeoGlobe.Filter.Logical
     * Creates a logical filter (And, Or, Not).
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *     filter.
     * 
     * Returns:
     * {<GeoGlobe.Filter.Logical>}
     */
    initialize: function(options) {
        this.filters = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
    },
    
    /** 
     * APIMethod: destroy
     * Remove reference to child filters.
     */
    destroy: function() {
        this.filters = null;
        GeoGlobe.Filter.prototype.destroy.apply(this);
    },

    /**
     * APIMethod: evaluate
     * Evaluates this filter in a specific context.
     * 
     * Parameters:
     * context - {Object} Context to use in evaluating the filter.  A vector
     *     feature may also be provided to evaluate feature attributes in 
     *     comparison filters or geometries in spatial filters.
     * 
     * Returns:
     * {Boolean} The filter applies.
     */
    evaluate: function(context) {
        var i, len;
        switch(this.type) {
            case GeoGlobe.Filter.Logical.AND:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == false) {
                        return false;
                    }
                }
                return true;
                
            case GeoGlobe.Filter.Logical.OR:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == true) {
                        return true;
                    }
                }
                return false;
            
            case GeoGlobe.Filter.Logical.NOT:
                return (!this.filters[0].evaluate(context));
        }
        return undefined;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<GeoGlobe.Filter.Logical>} Clone of this filter.
     */
    clone: function() {
        var filters = [];        
        for(var i=0, len=this.filters.length; i<len; ++i) {
            filters.push(this.filters[i].clone());
        }
        return new GeoGlobe.Filter.Logical({
            type: this.type,
            filters: filters
        });
    },
    
    CLASS_NAME: "GeoGlobe.Filter.Logical"
});


GeoGlobe.Filter.Logical.AND = "&&";
GeoGlobe.Filter.Logical.OR  = "||";
GeoGlobe.Filter.Logical.NOT = "!";
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Filter/Filter.js
 */

/**
 * Class: GeoGlobe.Filter.Comparison
 * This class represents a comparison filter.
 * 比较操作符过滤器类。
 * 
 * Inherits from:
 * - <GeoGlobe.Filter>
 */
GeoGlobe.Filter.Comparison = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * APIProperty: type
     * {String} type: type of the comparison. This is one of
     * - GeoGlobe.Filter.Comparison.EQUAL_TO                 = "==";
     * - GeoGlobe.Filter.Comparison.NOT_EQUAL_TO             = "!=";
     * - GeoGlobe.Filter.Comparison.LESS_THAN                = "<";
     * - GeoGlobe.Filter.Comparison.GREATER_THAN             = ">";
     * - GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO    = "<=";
     * - GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
     * - GeoGlobe.Filter.Comparison.BETWEEN                  = "..";
     * - GeoGlobe.Filter.Comparison.LIKE                     = "~";
     * - GeoGlobe.Filter.Comparison.IS_NULL                  = "NULL";
     */
    type: null,
    
    /**
     * APIProperty: property
     * {String}
     * name of the context property to compare
     */
    property: null,
    
    /**
     * APIProperty: value
     * {Number} or {String}
     * comparison value for binary comparisons. In the case of a String, this
     * can be a combination of text and propertyNames in the form
     * "literal ${propertyName}"
     */
    value: null,
    
    /**
     * Property: matchCase
     * {Boolean} Force case sensitive searches for EQUAL_TO and NOT_EQUAL_TO
     *     comparisons.  The Filter Encoding 1.1 specification added a matchCase
     *     attribute to ogc:PropertyIsEqualTo and ogc:PropertyIsNotEqualTo
     *     elements.  This property will be serialized with those elements only
     *     if using the v1.1.0 filter format. However, when evaluating filters
     *     here, the matchCase property will always be respected (for EQUAL_TO
     *     and NOT_EQUAL_TO).  Default is true. 
     */
    matchCase: true,
    
    /**
     * APIProperty: lowerBoundary
     * {Number} or {String}
     * lower boundary for between comparisons. In the case of a String, this
     * can be a combination of text and propertyNames in the form
     * "literal ${propertyName}"
     */
    lowerBoundary: null,
    
    /**
     * APIProperty: upperBoundary
     * {Number} or {String}
     * upper boundary for between comparisons. In the case of a String, this
     * can be a combination of text and propertyNames in the form
     * "literal ${propertyName}"
     */
    upperBoundary: null,

    /** 
     * Constructor: GeoGlobe.Filter.Comparison
     * Creates a comparison rule.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *           rule
     * 
     * Returns:
     * {<GeoGlobe.Filter.Comparison>}
     */
    initialize: function(options) {
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
        // since matchCase on PropertyIsLike is not schema compliant, we only
        // want to use this if explicitly asked for
        if (this.type === GeoGlobe.Filter.Comparison.LIKE 
            && options.matchCase === undefined) {
                this.matchCase = null;
        }
    },

    /**
     * APIMethod: evaluate
     * Evaluates this filter in a specific context.
     * 
     * Parameters:
     * context - {Object} Context to use in evaluating the filter.  If a vector
     *     feature is provided, the feature.attributes will be used as context.
     * 
     * Returns:
     * {Boolean} The filter applies.
     */
    evaluate: function(context) {
        if (context instanceof GeoGlobe.Feature) {
            context = context.attributes;
        }
        var result = false;
        var got = context[this.property];
		if (got === undefined) {
            return false;
        }
        var exp;
        switch(this.type) {
            case GeoGlobe.Filter.Comparison.EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() == exp.toUpperCase());
                } else {
                    result = (got == exp);
                }
                break;
            case GeoGlobe.Filter.Comparison.NOT_EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() != exp.toUpperCase());
                } else {
                    result = (got != exp);
                }
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN:
                result = got < this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN:
                result = got > this.value;
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO:
                result = got <= this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO:
                result = got >= this.value;
                break;
            case GeoGlobe.Filter.Comparison.BETWEEN:
                result = (got >= this.lowerBoundary) &&
                    (got <= this.upperBoundary);
                break;
            case GeoGlobe.Filter.Comparison.LIKE:
                var regexp = new RegExp(this.value, "gi");
                result = regexp.test(got);
                break;
            case GeoGlobe.Filter.Comparison.IS_NULL:
                result = (got === null);
                break;
        }
        return result;
    },
    
    /**
     * APIMethod: value2regex
     * Converts the value of this rule into a regular expression string,
     * according to the wildcard characters specified. This method has to
     * be called after instantiation of this class, if the value is not a
     * regular expression already.
     * 
     * Parameters:
     * wildCard   - {Char} wildcard character in the above value, default
     *              is "*"
     * singleChar - {Char} single-character wildcard in the above value
     *              default is "."
     * escapeChar - {Char} escape character in the above value, default is
     *              "!"
     * 
     * Returns:
     * {String} regular expression string
     */
    value2regex: function(wildCard, singleChar, escapeChar) {
        if (wildCard == ".") {
            throw new Error("'.' is an unsupported wildCard character for " +
                            "GeoGlobe.Filter.Comparison");
        }
        

        // set UMN MapServer defaults for unspecified parameters
        wildCard = wildCard ? wildCard : "*";
        singleChar = singleChar ? singleChar : ".";
        escapeChar = escapeChar ? escapeChar : "!";
        
        this.value = this.value.replace(
                new RegExp("\\"+escapeChar+"(.|$)", "g"), "\\$1");
        this.value = this.value.replace(
                new RegExp("\\"+singleChar, "g"), ".");
        this.value = this.value.replace(
                new RegExp("\\"+wildCard, "g"), ".*");
        this.value = this.value.replace(
                new RegExp("\\\\.\\*", "g"), "\\"+wildCard);
        this.value = this.value.replace(
                new RegExp("\\\\\\.", "g"), "\\"+singleChar);
        
        return this.value;
    },
    
    /**
     * Method: regex2value
     * Convert the value of this rule from a regular expression string into an
     *     ogc literal string using a wildCard of *, a singleChar of ., and an
     *     escape of !.  Leaves the <value> property unmodified.
     * 
     * Returns:
     * {String} A string value.
     */
    regex2value: function() {
        
        var value = this.value;
        
        // replace ! with !!
        value = value.replace(/!/g, "!!");

        // replace \. with !. (watching out for \\.)
        value = value.replace(/(\\)?\\\./g, function($0, $1) {
            return $1 ? $0 : "!.";
        });
        
        // replace \* with #* (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "!*";
        });
        
        // replace \\ with \
        value = value.replace(/\\\\/g, "\\");

        // convert .* to * (the sequence #.* is not allowed)
        value = value.replace(/\.\*/g, "*");
        
        return value;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<GeoGlobe.Filter.Comparison>} Clone of this filter.
     */
    clone: function() {
        return GeoGlobe.Util.extend(new GeoGlobe.Filter.Comparison(), this);
    },
    
    CLASS_NAME: "GeoGlobe.Filter.Comparison"
});


GeoGlobe.Filter.Comparison.EQUAL_TO                 = "==";
GeoGlobe.Filter.Comparison.NOT_EQUAL_TO             = "!=";
GeoGlobe.Filter.Comparison.LESS_THAN                = "<";
GeoGlobe.Filter.Comparison.GREATER_THAN             = ">";
GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO    = "<=";
GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
GeoGlobe.Filter.Comparison.BETWEEN                  = "..";
GeoGlobe.Filter.Comparison.LIKE                     = "~";
GeoGlobe.Filter.Comparison.IS_NULL                  = "NULL";
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Filter/Filter.js
 */

/**
 * Class: GeoGlobe.Filter.Spatial
 * This class represents a spatial filter.
 * Currently implemented: BBOX, DWithin and Intersects
 * 空间关系过滤器。
 * 
 * Inherits from:
 * - <GeoGlobe.Filter>
 */
GeoGlobe.Filter.Spatial = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * APIProperty: type
     * {String} Type of spatial filter.
     *
     * The type should be one of:
     * - GeoGlobe.Filter.Spatial.BBOX
     * - GeoGlobe.Filter.Spatial.INTERSECTS
     * - GeoGlobe.Filter.Spatial.DWITHIN
     * - GeoGlobe.Filter.Spatial.WITHIN
     * - GeoGlobe.Filter.Spatial.CONTAINS
     */
    type: null,
    
    /**
     * APIProperty: property
     * {String} Name of the context property to compare.
     */
    property: null,
    
    /**
     * APIProperty: value
     * {<GeoGlobe.LngLatBounds> || <GeoGlobe.Geometry>} The bounds or geometry
     *     to be used by the filter.  Use bounds for BBOX filters and geometry
     *     for INTERSECTS or DWITHIN filters.
     */
    value: null,

    /**
     * APIProperty: distance
     * {Number} The distance to use in a DWithin spatial filter.
     */
    distance: null,

    /**
     * APIProperty: distanceUnits
     * {String} The units to use for the distance, e.g. 'm'.
     */
    distanceUnits: null,
    
    /** 
     * Constructor: GeoGlobe.Filter.Spatial
     * Creates a spatial filter.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *     filter.
     * 
     * Returns:
     * {<GeoGlobe.Filter.Spatial>}
     */

   /**
    * Method: evaluate
    * Evaluates this filter for a specific feature.
    * 
    * Parameters:
    * feature - {<GeoGlobe.Feature>} feature to apply the filter to.
    * 
    * Returns:
    * {Boolean} The feature meets filter criteria.
    */
    evaluate: function(feature) {
        var intersect = false;
        switch(this.type) {
            case GeoGlobe.Filter.Spatial.BBOX:
            case GeoGlobe.Filter.Spatial.INTERSECTS:
                if(feature.geometry) {
                    var geom = this.value;
                    if(this.value.CLASS_NAME == "GeoGlobe.LngLatBounds") {
                        geom = this.value.toGeometry();
                    }
                    if(feature.geometry.intersects(geom)) {
                        intersect = true;
                    }
                }
                break;
            default:
                throw new Error('evaluate is not implemented for this filter type.');
        }
        return intersect;
    },

    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<GeoGlobe.Filter.Spatial>} Clone of this filter.
     */
    clone: function() {
        var options = GeoGlobe.Util.applyDefaults({
            value: this.value && this.value.clone && this.value.clone()
        }, this);
        return new GeoGlobe.Filter.Spatial(options);
    },
    CLASS_NAME: "GeoGlobe.Filter.Spatial"
});

GeoGlobe.Filter.Spatial.BBOX = "BBOX";
GeoGlobe.Filter.Spatial.INTERSECTS = "INTERSECTS";
GeoGlobe.Filter.Spatial.DWITHIN = "DWITHIN";
GeoGlobe.Filter.Spatial.WITHIN = "WITHIN";
GeoGlobe.Filter.Spatial.CONTAINS = "CONTAINS";
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Filter/Filter.js
 */

/**
 * Class: GeoGlobe.Filter.Function
 * This class represents a filter function.
 * We are using this class for creation of complex 
 * filters that can contain filter functions as values.
 * Nesting function as other functions parameter is supported.
 * 
 * Inherits from:
 * - <GeoGlobe.Filter>
 */
GeoGlobe.Filter.Function = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * APIProperty: name
     * {String} Name of the function.
     */
    name: null,
    
    /**
     * APIProperty: params
     * {Array(<GeoGlobe.Filter.Function> || String || Number)} Function parameters
     * For now support only other Functions, String or Number
     */
    params: null,  
    
    /** 
     * Constructor: GeoGlobe.Filter.Function
     * Creates a filter function.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *     function.
     * 
     * Returns:
     * {<GeoGlobe.Filter.Function>}
     */

    CLASS_NAME: "GeoGlobe.Filter.Function"
});

/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/tool/Class.js
 */

/**
 * Class: GeoGlobe.Protocol
 * Abstract vector layer protocol class.  Not to be instantiated directly.  Use
 *     one of the protocol subclasses instead.
 */
GeoGlobe.Protocol = GeoGlobe.Class4OL({
    
    /**
     * Property: format
     * {<GeoGlobe.Format>} The format used by this protocol.
     */
    format: null,
    
    /**
     * Property: options
     * {Object} Any options sent to the constructor.
     */
    options: null,

    /**
     * Property: autoDestroy
     * {Boolean} The creator of the protocol can set autoDestroy to false
     *      to fully control when the protocol is destroyed. Defaults to
     *      true.
     */
    autoDestroy: true,
   
    /**
     * Property: defaultFilter
     * {<GeoGlobe.Filter>} Optional default filter to read requests
     */
    defaultFilter: null,
    
    /**
     * Constructor: GeoGlobe.Protocol
     * Abstract class for vector protocols.  Create instances of a subclass.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        options = options || {};
        GeoGlobe.Util.extend(this, options);
        this.options = options;
    },

    /**
     * Method: mergeWithDefaultFilter
     * Merge filter passed to the read method with the default one
     *
     * Parameters:
     * filter - {<GeoGlobe.Filter>}
     */
    mergeWithDefaultFilter: function(filter) {
        var merged;
        if (filter && this.defaultFilter) {
            merged = new GeoGlobe.Filter.Logical({
                type: GeoGlobe.Filter.Logical.AND,
                filters: [this.defaultFilter, filter]
            });
        } else {
            merged = filter || this.defaultFilter || undefined;
        }
        return merged;
    },

    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        this.options = null;
        this.format = null;
    },
    
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} An <GeoGlobe.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    read: function(options) {
        options = options || {};
        options.filter = this.mergeWithDefaultFilter(options.filter);
    },
    
    
    /**
     * APIMethod: create
     * Construct a request for writing newly created features.
     *
     * Parameters:
     * features - {Array({<GeoGlobe.Feature>})} or
     *            {<GeoGlobe.Feature>}
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} An <GeoGlobe.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    create: function() {
    },
    
    /**
     * APIMethod: update
     * Construct a request updating modified features.
     *
     * Parameters:
     * features - {Array({<GeoGlobe.Feature>})} or
     *            {<GeoGlobe.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} An <GeoGlobe.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    update: function() {
    },
    
    /**
     * APIMethod: delete
     * Construct a request deleting a removed feature.
     *
     * Parameters:
     * feature - {<GeoGlobe.Feature>}
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} An <GeoGlobe.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    "delete": function() {
    },

    /**
     * APIMethod: commit
     * Go over the features and for each take action
     * based on the feature state. Possible actions are create,
     * update and delete.
     *
     * Parameters:
     * features - {Array({<GeoGlobe.Feature>})}
     * options - {Object} Object whose possible keys are "create", "update",
     *      "delete", "callback" and "scope", the values referenced by the
     *      first three are objects as passed to the "create", "update", and
     *      "delete" methods, the value referenced by the "callback" key is
     *      a function which is called when the commit operation is complete
     *      using the scope referenced by the "scope" key.
     *
     * Returns:
     * {Array({<GeoGlobe.Protocol.Response>})} An array of
     * <GeoGlobe.Protocol.Response> objects.
     */
    commit: function() {
    },

    /**
     * Method: abort
     * Abort an ongoing request.
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>}
     */
    abort: function(response) {
    },
   
    /**
     * Method: createCallback
     * Returns a function that applies the given public method with resp and
     *     options arguments.
     *
     * Parameters:
     * method - {Function} The method to be applied by the callback.
     * response - {<GeoGlobe.Protocol.Response>} The protocol response object.
     * options - {Object} Options sent to the protocol method
     */
    createCallback: function(method, response, options) {
        return GeoGlobe.Function.bind(function() {
            method.apply(this, [response, options]);
        }, this);
    },
   
    CLASS_NAME: "GeoGlobe.Protocol" 
});

/**
 * Class: GeoGlobe.Protocol.Response
 * Protocols return Response objects to their users.
 */
GeoGlobe.Protocol.Response = GeoGlobe.Class4OL({
    /**
     * Property: code
     * {Number} - GeoGlobe.Protocol.Response.SUCCESS or
     *            GeoGlobe.Protocol.Response.FAILURE
     */
    code: null,

    /**
     * Property: requestType
     * {String} The type of request this response corresponds to. Either
     *      "create", "read", "update" or "delete".
     */
    requestType: null,

    /**
     * Property: last
     * {Boolean} - true if this is the last response expected in a commit,
     * false otherwise, defaults to true.
     */
    last: true,

    /**
     * Property: features
     * {Array({<GeoGlobe.Feature>})} or {<GeoGlobe.Feature>}
     * The features returned in the response by the server. Depending on the 
     * protocol's read payload, either features or data will be populated.
     */
    features: null,

    /**
     * Property: data
     * {Object}
     * The data returned in the response by the server. Depending on the 
     * protocol's read payload, either features or data will be populated.
     */
    data: null,

    /**
     * Property: reqFeatures
     * {Array({<GeoGlobe.Feature>})} or {<GeoGlobe.Feature>}
     * The features provided by the user and placed in the request by the
     *      protocol.
     */
    reqFeatures: null,

    /**
     * Property: priv
     */
    priv: null,

    /**
     * Property: error
     * {Object} The error object in case a service exception was encountered.
     */
    error: null,

    /**
     * Constructor: GeoGlobe.Protocol.Response
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
    },

    /**
     * Method: success
     *
     * Returns:
     * {Boolean} - true on success, false otherwise
     */
    success: function() {
        return this.code > 0;
    },

    CLASS_NAME: "GeoGlobe.Protocol.Response"
});

GeoGlobe.Protocol.Response.SUCCESS = 1;
GeoGlobe.Protocol.Response.FAILURE = 0;
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Protocol.js
 * @requires GeoGlobe/Request/XMLHttpRequest.js
 */

/**
 * if application uses the query string, for example, for BBOX parameters,
 * GeoGlobe/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * Class: GeoGlobe.Protocol.HTTP
 * A basic HTTP protocol for vector layers.  Create a new instance with the
 *     <GeoGlobe.Protocol.HTTP> constructor.
 *
 * Inherits from:
 *  - <GeoGlobe.Protocol>
 */
GeoGlobe.Protocol.HTTP = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     * Property: url
     * {String} Service URL, read-only, set through the options
     *     passed to constructor.
     */
    url: null,

    /**
     * Property: headers
     * {Object} HTTP request headers, read-only, set through the options
     *     passed to the constructor,
     *     Example: {'Content-Type': 'plain/text'}
     */
    headers: null,

    /**
     * Property: params
     * {Object} Parameters of GET requests, read-only, set through the options
     *     passed to the constructor,
     *     Example: {'bbox': '5,5,5,5'}
     */
    params: null,
    
    /**
     * Property: callback
     * {Object} Function to be called when the <read>, <create>,
     *     <update>, <delete> or <commit> operation completes, read-only,
     *     set through the options passed to the constructor.
     */
    callback: null,

    /**
     * Property: scope
     * {Object} Callback execution scope, read-only, set through the
     *     options passed to the constructor.
     */
    scope: null,

    /**
     * APIProperty: readWithPOST
     * {Boolean} true if read operations are done with POST requests
     *     instead of GET, defaults to false.
     */
    readWithPOST: false,

    /**
     * APIProperty: updateWithPOST
     * {Boolean} true if update operations are done with POST requests
     *     defaults to false.
     */
    updateWithPOST: false,
    
    /**
     * APIProperty: deleteWithPOST
     * {Boolean} true if delete operations are done with POST requests
     *     defaults to false.
     *     if true, POST data is set to output of format.write().
     */
    deleteWithPOST: false,

    /**
     * Property: wildcarded.
     * {Boolean} If true percent signs are added around values
     *     read from LIKE filters, for example if the protocol
     *     read method is passed a LIKE filter whose property
     *     is "foo" and whose value is "bar" the string
     *     "foo__ilike=%bar%" will be sent in the query string;
     *     defaults to false.
     */
    wildcarded: false,

    /**
     * APIProperty: srsInBBOX
     * {Boolean} Include the SRS identifier in BBOX query string parameter.  
     *     Default is false.  If true and the layer has a projection object set,
     *     any BBOX filter will be serialized with a fifth item identifying the
     *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     */
    srsInBBOX: false,

    /**
     * Constructor: GeoGlobe.Protocol.HTTP
     * A class for giving layers generic HTTP protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options include:
     * url - {String}
     * headers - {Object} 
     * params - {Object} URL parameters for GET requests
     * format - {<GeoGlobe.Format>}
     * callback - {Function}
     * scope - {Object}
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.headers = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);

        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var format = new GeoGlobe.Format.QueryStringFilter({
                wildcarded: this.wildcarded,
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        this.params = null;
        this.headers = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * APIMethod: filterToParams
     * Optional method to translate an <GeoGlobe.Filter> object into an object
     *     that can be serialized as request query string provided.  If a custom
     *     method is not provided, the filter will be serialized using the 
     *     <GeoGlobe.Format.QueryStringFilter> class.
     *
     * Parameters:
     * filter - {<GeoGlobe.Filter>} filter to convert.
     * params - {Object} The parameters object.
     *
     * Returns:
     * {Object} The resulting parameters object.
     */
    
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Valid options:
     * url - {String} Url for the request.
     * params - {Object} Parameters to get serialized as a query string.
     * headers - {Object} Headers to be set on the request.
     * filter - {<GeoGlobe.Filter>} Filter to get serialized as a
     *     query string.
     * readWithPOST - {Boolean} If the request should be done with POST.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} A response object, whose "priv" property
     *     references the HTTP request, this object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = options || {};
        options.params = GeoGlobe.Util.applyDefaults(
            options.params, this.options.params);
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var readWithPOST = (options.readWithPOST !== undefined) ?
                           options.readWithPOST : this.readWithPOST;
        var resp = new GeoGlobe.Protocol.Response({requestType: "read"});
        if(readWithPOST) {
            var headers = options.headers || {};
            headers["Content-Type"] = "application/x-www-form-urlencoded";
            resp.priv = GeoGlobe.Request.POST({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                data: GeoGlobe.Util.getParameterString(options.params),
                headers: headers
            });
        } else {
            resp.priv = GeoGlobe.Request.GET({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                params: options.params,
                headers: options.headers
            });
        }
        return resp;
    },

    /**
     * Method: handleRead
     * Individual callbacks are created for read, create and update, should
     *     a subclass need to override each one separately.
     *
     * Parameters:
     * resp - {<GeoGlobe.Protocol.Response>} The response object to pass to
     *     the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * APIMethod: create
     * Construct a request for writing newly created features.
     *
     * Parameters:
     * features - {Array({<GeoGlobe.Feature.Vector>})} or
     *     {<GeoGlobe.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} An <GeoGlobe.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the features received from the server.
     */
    create: function(features, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: features,
            requestType: "create"
        });

        resp.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleCreate, resp, options),
            headers: options.headers,
            data: this.format.write(features)
        });

        return resp;
    },

    /**
     * Method: handleCreate
     * Called the the request issued by <create> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<GeoGlobe.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create call.
     */
    handleCreate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * APIMethod: update
     * Construct a request updating modified feature.
     *
     * Parameters:
     * feature - {<GeoGlobe.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} An <GeoGlobe.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the feature received from the server.
     */
    update: function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: feature,
            requestType: "update"
        });

        var method = this.updateWithPOST ? "POST" : "PUT";
        resp.priv = GeoGlobe.Request[method]({
            url: url,
            callback: this.createCallback(this.handleUpdate, resp, options),
            headers: options.headers,
            data: this.format.write(feature)
        });

        return resp;
    },

    /**
     * Method: handleUpdate
     * Called the the request issued by <update> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<GeoGlobe.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the update call.
     */
    handleUpdate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * APIMethod: delete
     * Construct a request deleting a removed feature.
     *
     * Parameters:
     * feature - {<GeoGlobe.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} An <GeoGlobe.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes.
     */
    "delete": function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: feature,
            requestType: "delete"
        });

        var method = this.deleteWithPOST ? "POST" : "DELETE";
        var requestOptions = {
            url: url,
            callback: this.createCallback(this.handleDelete, resp, options),
            headers: options.headers
        };
        if (this.deleteWithPOST) {
            requestOptions.data = this.format.write(feature);
        }
        resp.priv = GeoGlobe.Request[method](requestOptions);

        return resp;
    },

    /**
     * Method: handleDelete
     * Called the the request issued by <delete> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<GeoGlobe.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the delete call.
     */
    handleDelete: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Method: handleResponse
     * Called by CRUD specific handlers.
     *
     * Parameters:
     * resp - {<GeoGlobe.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create, read, update,
     *     or delete call.
     */
    handleResponse: function(resp, options) {
        var request = resp.priv;
        if(options.callback) {
            if(request.status >= 200 && request.status < 300) {
                // success
                if(resp.requestType != "delete") {
                    resp.features = this.parseFeatures(request);
                }
                resp.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                // failure
                resp.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * Method: parseFeatures
     * Read HTTP response body and return features.
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     *
     * Returns:
     * {Array({<GeoGlobe.Feature.Vector>})} or
     *     {<GeoGlobe.Feature.Vector>} Array of features or a single feature.
     */
    parseFeatures: function(request) {
        var doc = request.responseXML;
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if (!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    /**
     * APIMethod: commit
     * Iterate over each feature and take action based on the feature state.
     *     Possible actions are create, update and delete.
     *
     * Parameters:
     * features - {Array({<GeoGlobe.Feature.Vector>})}
     * options - {Object} Optional object for setting up intermediate commit
     *     callbacks.
     *
     * Valid options:
     * create - {Object} Optional object to be passed to the <create> method.
     * update - {Object} Optional object to be passed to the <update> method.
     * delete - {Object} Optional object to be passed to the <delete> method.
     * callback - {Function} Optional function to be called when the commit
     *     is complete.
     * scope - {Object} Optional object to be set as the scope of the callback.
     *
     * Returns:
     * {Array(<GeoGlobe.Protocol.Response>)} An array of response objects,
     *     one per request made to the server, each object's "priv" property
     *     references the corresponding HTTP request.
     */
    commit: function(features, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        var resp = [], nResponses = 0;
        
        // Divide up features before issuing any requests.  This properly
        // counts requests in the event that any responses come in before
        // all requests have been issued.
        var types = {};
        types[GeoGlobe.State.INSERT] = [];
        types[GeoGlobe.State.UPDATE] = [];
        types[GeoGlobe.State.DELETE] = [];
        var feature, list, requestFeatures = [];
        for(var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            list = types[feature.state];
            if(list) {
                list.push(feature);
                requestFeatures.push(feature); 
            }
        }
        // tally up number of requests
        var nRequests = (types[GeoGlobe.State.INSERT].length > 0 ? 1 : 0) +
            types[GeoGlobe.State.UPDATE].length +
            types[GeoGlobe.State.DELETE].length;
        
        // This response will be sent to the final callback after all the others
        // have been fired.
        var success = true;
        var finalResponse = new GeoGlobe.Protocol.Response({
            reqFeatures: requestFeatures        
        });
        
        function insertCallback(response) {
            var len = response.features ? response.features.length : 0;
            var fids = new Array(len);
            for(var i=0; i<len; ++i) {
                fids[i] = response.features[i].fid;
            }   
            finalResponse.insertIds = fids;
            callback.apply(this, [response]);
        }
 
        function callback(response) {
            this.callUserCallback(response, options);
            success = success && response.success();
            nResponses++;
            if (nResponses >= nRequests) {
                if (options.callback) {
                    finalResponse.code = success ?
                        GeoGlobe.Protocol.Response.SUCCESS :
                        GeoGlobe.Protocol.Response.FAILURE;
                    options.callback.apply(options.scope, [finalResponse]);
                }    
            }
        }

        // start issuing requests
        var queue = types[GeoGlobe.State.INSERT];
        if(queue.length > 0) {
            resp.push(this.create(
                queue, GeoGlobe.Util.applyDefaults(
                    {callback: insertCallback, scope: this}, options.create
                )
            ));
        }
        queue = types[GeoGlobe.State.UPDATE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this.update(
                queue[i], GeoGlobe.Util.applyDefaults(
                    {callback: callback, scope: this}, options.update
                ))
            );
        }
        queue = types[GeoGlobe.State.DELETE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this["delete"](
                queue[i], GeoGlobe.Util.applyDefaults(
                    {callback: callback, scope: this}, options["delete"]
                ))
            );
        }
        return resp;
    },

    /**
     * APIMethod: abort
     * Abort an ongoing request, the response object passed to
     * this method must come from this HTTP protocol (as a result
     * of a create, read, update, delete or commit operation).
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>}
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },

    /**
     * Method: callUserCallback
     * This method is used from within the commit method each time an
     *     an HTTP response is received from the server, it is responsible
     *     for calling the user-supplied callbacks.
     *
     * Parameters:
     * resp - {<GeoGlobe.Protocol.Response>}
     * options - {Object} The map of options passed to the commit call.
     */
    callUserCallback: function(resp, options) {
        var opt = options[resp.requestType];
        if(opt && opt.callback) {
            opt.callback.call(opt.scope, resp);
        }
    },

    CLASS_NAME: "GeoGlobe.Protocol.HTTP"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Protocol/Protocol.js
 */

/**
 * Class: GeoGlobe.Protocol.WFS
 * Used to create a versioned WFS protocol.  Default version is 1.0.0.
 *
 * Returns:
 * {<GeoGlobe.Protocol>} A WFS protocol of the given version.
 *
 * Example:
 * (code)
 *     var protocol = new GeoGlobe.Protocol.WFS({
 *         version: "1.1.0",
 *         url:  "http://demo.opengeo.org/geoserver/wfs",
 *         featureType: "tasmania_roads",
 *         featureNS: "http://www.openplans.org/topp",
 *         geometryName: "the_geom"
 *     });
 * (end)
 *
 * See the protocols for specific WFS versions for more detail.
 */
GeoGlobe.Protocol.WFS = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Protocol.WFS.DEFAULTS
    );
    var cls = GeoGlobe.Protocol.WFS["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFS version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: GeoGlobe.Protocol.WFS.DEFAULTS
 */
GeoGlobe.Protocol.WFS.DEFAULTS = {
    "version": "1.0.0"
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Protocol/WFS.js
 */

/**
 * Class: GeoGlobe.Protocol.WFS.v1
 * Abstract class for for v1.0.0 and v1.1.0 protocol.
 *
 * Inherits from:
 *  - <GeoGlobe.Protocol>
 */
GeoGlobe.Protocol.WFS.v1 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: null,
    
    /**
     * Property: srsName
     * {String} Name of spatial reference system.  Default is "EPSG:4326".
     */
    srsName: "EPSG:4326",
    
    /**
     * Property: featureType
     * {String} Local feature typeName.
     */
    featureType: null,
    
    /**
     * Property: featureNS
     * {String} Feature namespace.
     */
    featureNS: null,
    
    /**
     * Property: geometryName
     * {String} Name of the geometry attribute for features.  Default is
     *     "the_geom" for WFS <version> 1.0, and null for higher versions.
     */
    geometryName: "the_geom",

    /**
     * Property: maxFeatures
     * {Integer} Optional maximum number of features to retrieve.
     */
    
    /**
     * Property: schema
     * {String} Optional schema location that will be included in the
     *     schemaLocation attribute value.  Note that the feature type schema
     *     is required for a strict XML validator (on transactions with an
     *     insert for example), but is *not* required by the WFS specification
     *     (since the server is supposed to know about feature type schemas).
     */
    schema: null,

    /**
     * Property: featurePrefix
     * {String} Namespace alias for feature type.  Default is "feature".
     */
    featurePrefix: "feature",
    
    /**
     * Property: formatOptions
     * {Object} Optional options for the format.  If a format is not provided,
     *     this property can be used to extend the default format options.
     */
    formatOptions: null,

    /** 
     * Property: readFormat 
     * {<GeoGlobe.Format>} For WFS requests it is possible to get a  
     *     different output format than GML. In that case, we cannot parse  
     *     the response with the default format (WFST) and we need a different 
     *     format for reading. 
     */ 
    readFormat: null,
    
    /**
     * Property: readOptions
     * {Object} Optional object to pass to format's read.
     */
    readOptions: null,
    
    /**
     * Constructor: GeoGlobe.Protocol.WFS
     * A class for giving layers WFS protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * url - {String} URL to send requests to (required).
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (required, but can be autodetected
     *     during the first query if GML is used as readFormat and
     *     featurePrefix is provided and matches the prefix used by the server
     *     for this featureType).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     for writing if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  The default is
     *     'the_geom' for WFS <version> 1.0, and null for higher versions. If
     *     null, it will be set to the name of the first geometry found in the
     *     first read operation.
     * multi - {Boolean} If set to true, geometries will be casted to Multi
     *     geometries before they are written in a transaction. No casting will
     *     be done when reading features.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = GeoGlobe.Format.WFST(GeoGlobe.Util.extend({
                version: this.version,
                featureType: this.featureType,
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                geometryName: this.geometryName,
                srsName: this.srsName,
                schema: this.schema
            }, this.formatOptions));
        }
        if (!options.geometryName && parseFloat(this.format.version) > 1.0) {
            this.setGeometryName(null);
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * APIMethod: read
     * Construct a request for reading new features.  Since WFS splits the
     *     basic CRUD operations into GetFeature requests (for read) and
     *     Transactions (for all others), this method does not make use of the
     *     format's read method (that is only about reading transaction
     *     responses).
     *
     * Parameters:
     * options - {Object} Options for the read operation, in addition to the
     *     options set on the instance (options set here will take precedence).
     *
     * To use a configured protocol to get e.g. a WFS hit count, applications
     * could do the following:
     *
     * (code)
     * protocol.read({
     *     readOptions: {output: "object"},
     *     resultType: "hits",
     *     maxFeatures: null,
     *     callback: function(resp) {
     *         // process resp.numberOfFeatures here
     *     }
     * });
     * (end)
     *
     * To use a configured protocol to use WFS paging (if supported by the
     * server), applications could do the following:
     *
     * (code)
     * protocol.read({
     *     startIndex: 0,
     *     count: 50
     * });
     * (end)
     *
     * To limit the attributes returned by the GetFeature request, applications
     * can use the propertyNames option to specify the properties to include in
     * the response:
     *
     * (code)
     * protocol.read({
     *     propertyNames: ["DURATION", "INTENSITY"]
     * });
     * (end)
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options || {});
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});
        
        var data = GeoGlobe.Format.XML.prototype.write.apply(
            this.format, [this.format.writeNode("wfs:GetFeature", options)]
        );

        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     * APIMethod: setFeatureType
     * Change the feature type on the fly.
     *
     * Parameters:
     * featureType - {String} Local (without prefix) feature typeName.
     */
    setFeatureType: function(featureType) {
        this.featureType = featureType;
        this.format.featureType = featureType;
    },
 
    /**
     * APIMethod: setGeometryName
     * Sets the geometryName option after instantiation.
     *
     * Parameters:
     * geometryName - {String} Name of geometry attribute.
     */
    setGeometryName: function(geometryName) {
        this.geometryName = geometryName;
        this.format.geometryName = geometryName;
    },
    
    /**
     * Method: handleRead
     * Deal with response from the read request.
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>} The response object to pass
     *     to the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(response, options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);

        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                var result = this.parseResponse(request, options.readOptions);
                if (result && result.success !== false) { 
                    if (options.readOptions && options.readOptions.output == "object") {
                        GeoGlobe.Util.extend(response, result);
                    } else {
                        response.features = result;
                    }
                    response.code = GeoGlobe.Protocol.Response.SUCCESS;
                } else {
                    // failure (service exception)
                    response.code = GeoGlobe.Protocol.Response.FAILURE;
                    response.error = result;
                }
            } else {
                // failure
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Method: parseResponse
     * Read HTTP response body and return features
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     * options - {Object} Optional object to pass to format's read
     *
     * Returns:
     * {Object} or {Array({<GeoGlobe.Feature>})} or
     *     {<GeoGlobe.Feature>} 
     * An object with a features property, an array of features or a single 
     * feature.
     */
    parseResponse: function(request, options) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
		
        //var result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
        //    this.format.read(doc, options);
		var result=null;
        try{
        	result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
            this.format.read(doc, options);
        }catch(e){
        	var error = "程序运行异常："+e.name + "，"+e.message;
        	alert(error);
        	//throw e;
        }
        if (!this.featureNS) {
            var format = this.readFormat || this.format;
            this.featureNS = format.featureNS;
            // no need to auto-configure again on subsequent reads
            format.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(format.geometryName);
            }
        }
        return result;
    },

    /**
     * Method: commit
     * Given a list of feature, assemble a batch request for update, create,
     *     and delete transactions.  A commit call on the prototype amounts
     *     to writing a WFS transaction - so the write method on the format
     *     is used.
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>)}
     * options - {Object}
     *
     * Valid options properties:
     * nativeElements - {Array({Object})} Array of objects with information for writing
     * out <Native> elements, these objects have vendorId, safeToIgnore and
     * value properties. The <Native> element is intended to allow access to 
     * vendor specific capabilities of any particular web feature server or 
     * datastore.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} A response object with a features
     *     property containing any insertIds and a priv property referencing
     *     the XMLHttpRequest object.
     */
    commit: function(features, options) {

        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);
        
        var response = new GeoGlobe.Protocol.Response({
            requestType: "commit",
            reqFeatures: features
        });
        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            headers: options.headers,
            data: this.format.write(features, options),
            callback: this.createCallback(this.handleCommit, response, options)
        });
        
        return response;
    },
    
    /**
     * Method: handleCommit
     * Called when the commit request returns.
     * 
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>} The response object to pass
     *     to the user callback.
     * options - {Object} The user options passed to the commit call.
     */
    handleCommit: function(response, options) {
        if(options.callback) {
            var request = response.priv;

            // ensure that we have an xml doc
            var data = request.responseXML;
            if(!data || !data.documentElement) {
                data = request.responseText;
            }
            
            var obj = this.format.read(data) || {};
            
            response.insertIds = obj.insertIds || [];
            if (obj.success) {
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                response.code = GeoGlobe.Protocol.Response.FAILURE;
                response.error = obj;
            }
            options.callback.call(options.scope, response);
        }
    },
    
    /**
     * Method: filterDelete
     * Send a request that deletes all features by their filter.
     * 
     * Parameters:
     * filter - {<GeoGlobe.Filter>} filter
     */
    filterDelete: function(filter, options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);    
        
        var response = new GeoGlobe.Protocol.Response({
            requestType: "commit"
        });    
        
        var root = this.format.createElementNSPlus("wfs:Transaction", {
            attributes: {
                service: "WFS",
                version: this.version
            }
        });
        
        var deleteNode = this.format.createElementNSPlus("wfs:Delete", {
            attributes: {
                typeName: (options.featureNS ? this.featurePrefix + ":" : "") +
                    options.featureType
            }
        });       
        
        if(options.featureNS) {
            deleteNode.setAttribute("xmlns:" + this.featurePrefix, options.featureNS);
        }
        var filterNode = this.format.writeNode("ogc:Filter", filter);
        
        deleteNode.appendChild(filterNode);
        
        root.appendChild(deleteNode);
        
        var data = GeoGlobe.Format.XML.prototype.write.apply(
            this.format, [root]
        );
        
        return GeoGlobe.Request.POST({
            url: this.url,
            callback : options.callback || function(){},
            data: data
        });   
        
    },

    /**
     * Method: abort
     * Abort an ongoing request, the response object passed to
     * this method must come from this protocol (as a result
     * of a read, or commit operation).
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>}
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },
  
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Protocol/WFS/v1.js
 * @requires View2D/Format/WFST/v1_0_0.js
 */

/**
 * Class: GeoGlobe.Protocol.WFS.v1_0_0
 * A WFS v1.0.0 protocol for vector layers.  Create a new instance with the
 *     <GeoGlobe.Protocol.WFS.v1_0_0> constructor.
 *
 * Inherits from:
 *  - <GeoGlobe.Protocol.WFS.v1>
 */
GeoGlobe.Protocol.WFS.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.0.0",
    
    /**
     * Constructor: GeoGlobe.Protocol.WFS.v1_0_0
     * A class for giving layers WFS v1.0.0 protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     */
   
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_0_0" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Protocol/WFS/v1.js
 * @requires View2D/Format/WFST/v1_1_0.js
 */

/**
 * Class: GeoGlobe.Protocol.WFS.v1_1_0
 * A WFS v1.1.0 protocol for vector layers.  Create a new instance with the
 *     <GeoGlobe.Protocol.WFS.v1_1_0> constructor.
 *
 * Differences from the v1.0.0 protocol:
 *  - uses Filter Encoding 1.1.0 instead of 1.0.0
 *  - uses GML 3 instead of 2 if no format is provided
 *  
 * Inherits from:
 *  - <GeoGlobe.Protocol.WFS.v1>
 */
GeoGlobe.Protocol.WFS.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.1.0",
    
    /**
     * Constructor: GeoGlobe.Protocol.WFS.v1_1_0
     * A class for giving layers WFS v1.1.0 protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     * outputFormat - {String} Optional output format to use for WFS GetFeature
     *     requests. This can be any format advertized by the WFS's
     *     GetCapabilities response. If set, an appropriate readFormat also
     *     has to be provided, unless outputFormat is GML3, GML2 or JSON.
     * readFormat - {<GeoGlobe.Format>} An appropriate format parser if
     *     outputFormat is none of GML3, GML2 or JSON.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.WFS.v1.prototype.initialize.apply(this, arguments);
        if (this.outputFormat && !this.readFormat) {
            if (this.outputFormat.toLowerCase() == "gml2") {
                this.readFormat = new GeoGlobe.Format.GML.v2({
                    featureType: this.featureType,
                    featureNS: this.featureNS,
                    geometryName: this.geometryName
                });
            } else if (this.outputFormat.toLowerCase() == "json") {
                this.readFormat = new GeoGlobe.Format.GeoJSON();
            }
        }
    },
   
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_1_0"
});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Protocol.js
 */

/**
 * Class: GeoGlobe.Protocol.CSW
 * Used to create a versioned CSW protocol. Default version is 2.0.2.
 */
GeoGlobe.Protocol.CSW = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Protocol.CSW.DEFAULTS
    );
    var cls = GeoGlobe.Protocol.CSW["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSW version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: GeoGlobe.Protocol.CSW.DEFAULTS
 */
GeoGlobe.Protocol.CSW.DEFAULTS = {
    "version": "2.0.2"
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Protocol/CSW.js
 * @requires GeoGlobe/Format/CSWGetRecords/v2_0_2.js
 */

/**
 * Class: GeoGlobe.Protocol.CSW.v2_0_2
 * CS-W (Catalogue services for the Web) version 2.0.2 protocol.
 *
 * Inherits from:
 *  - <GeoGlobe.Protocol>
 */
GeoGlobe.Protocol.CSW.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     * Property: formatOptions
     * {Object} Optional options for the format.  If a format is not provided,
     *     this property can be used to extend the default format options.
     */
    formatOptions: null,

    /**
     * Constructor: GeoGlobe.Protocol.CSW.v2_0_2
     * A class for CSW version 2.0.2 protocol management.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = new GeoGlobe.Format.CSWGetRecords.v2_0_2(GeoGlobe.Util.extend({
            }, this.formatOptions));
        }
    },

    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Method: read
     * Construct a request for reading new records from the Catalogue.
     */
    read: function(options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options || {});
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});

        var data = this.format.write(options.params || options);

        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     * Method: handleRead
     * Deal with response from the read request.
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>} The response object to pass
     *     to the user callback.
     *     This response is given a code property, and optionally a data property.
     *     The latter represents the CSW records as returned by the call to
     *     the CSW format read method.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(response, options) {
        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                response.data = this.parseData(request);
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                // failure
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Method: parseData
     * Read HTTP response body and return records
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     *
     * Returns:
     * {Object} The CSW records as returned by the call to the format read method.
     */
    parseData: function(request) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    CLASS_NAME: "GeoGlobe.Protocol.CSW.v2_0_2"

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Protocol/Protocol.js
 * @requires View2D/Feature/Feature.js
 * @requires View2D/Format/GeoJSON.js
 */

/**
 * if application uses the query string, for example, for BBOX parameters,
 * GeoGlobe/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * Class: GeoGlobe.Protocol.Script
 * A basic Script protocol for vector layers.  Create a new instance with the
 *     <GeoGlobe.Protocol.Script> constructor.  A script protocol is used to
 *     get around the same origin policy.  It works with services that return
 *     JSONP - that is, JSON wrapped in a client-specified callback.  The
 *     protocol handles fetching and parsing of feature data and sends parsed
 *     features to the <callback> configured with the protocol.  The protocol
 *     expects features serialized as GeoJSON by default, but can be configured
 *     to work with other formats by setting the <format> property.
 *
 * Inherits from:
 *  - <GeoGlobe.Protocol>
 */
GeoGlobe.Protocol.Script = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     * APIProperty: url
     * {String} Service URL.  The service is expected to return serialized 
     *     features wrapped in a named callback (where the callback name is
     *     generated by this protocol).
     *     Read-only, set through the options passed to the constructor.
     */
    url: null,

    /**
     * APIProperty: params
     * {Object} Query string parameters to be appended to the URL.
     *     Read-only, set through the options passed to the constructor.
     *     Example: {maxFeatures: 50}
     */
    params: null,
    
    /**
     * APIProperty: callback
     * {Object} Function to be called when the <read> operation completes.
     */
    callback: null,

    /**
     * APIProperty: callbackTemplate
     * {String} Template for creating a unique callback function name
     * for the registry. Should include ${id}.  The ${id} variable will be
     * replaced with a string identifier prefixed with a "c" (e.g. c1, c2).
     * Default is "GeoGlobe.Protocol.Script.registry.${id}".
     */
    callbackTemplate: "GeoGlobe.Protocol.Script.registry.${id}",

    /**
     * APIProperty: callbackKey
     * {String} The name of the query string parameter that the service 
     *     recognizes as the callback identifier.  Default is "callback".
     *     This key is used to generate the URL for the script.  For example
     *     setting <callbackKey> to "myCallback" would result in a URL like 
     *     http://example.com/?myCallback=...
     */
    callbackKey: "callback",

    /**
     * APIProperty: callbackPrefix
     * {String} Where a service requires that the callback query string 
     *     parameter value is prefixed by some string, this value may be set.
     *     For example, setting <callbackPrefix> to "foo:" would result in a
     *     URL like http://example.com/?callback=foo:...  Default is "".
     */
    callbackPrefix: "",

    /**
     * APIProperty: scope
     * {Object} Optional ``this`` object for the callback. Read-only, set 
     *     through the options passed to the constructor.
     */
    scope: null,

    /**
     * APIProperty: format
     * {<GeoGlobe.Format>} Format for parsing features.  Default is an 
     *     <GeoGlobe.Format.GeoJSON> format.  If an alternative is provided,
     *     the format's read method must take an object and return an array
     *     of features.
     */
    format: null,

    /**
     * Property: pendingRequests
     * {Object} References all pending requests.  Property names are script 
     *     identifiers and property values are script elements.
     */
    pendingRequests: null,

    /**
     * APIProperty: srsInBBOX
     * {Boolean} Include the SRS identifier in BBOX query string parameter.
     *     Setting this property has no effect if a custom filterToParams method
     *     is provided.   Default is false.  If true and the layer has a 
     *     projection object set, any BBOX filter will be serialized with a 
     *     fifth item identifying the projection.  
     *     E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     */
    srsInBBOX: false,

    /**
     * Constructor: GeoGlobe.Protocol.Script
     * A class for giving layers generic Script protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options include:
     * url - {String}
     * params - {Object}
     * callback - {Function}
     * scope - {Object}
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.pendingRequests = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);
        if (!this.format) {
            this.format = new GeoGlobe.Format.GeoJSON();
        }

        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var format = new GeoGlobe.Format.QueryStringFilter({
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Valid options:
     * url - {String} Url for the request.
     * params - {Object} Parameters to get serialized as a query string.
     * filter - {<GeoGlobe.Filter>} Filter to get serialized as a
     *     query string.
     *
     * Returns:
     * {<GeoGlobe.Protocol.Response>} A response object, whose "priv" property
     *     references the injected script.  This object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        options.params = GeoGlobe.Util.applyDefaults(
            options.params, this.options.params
        );
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});
        var request = this.createRequest(
            options.url, 
            options.params, 
            GeoGlobe.Function.bind(function(data) {
                response.data = data;
                this.handleRead(response, options);
            }, this)
        );
        response.priv = request;
        return response;
    },

    /** 
     * APIMethod: filterToParams 
     * Optional method to translate an <GeoGlobe.Filter> object into an object 
     *     that can be serialized as request query string provided.  If a custom 
     *     method is not provided, any filter will not be serialized. 
     * 
     * Parameters: 
     * filter - {<GeoGlobe.Filter>} filter to convert. 
     * params - {Object} The parameters object. 
     * 
     * Returns: 
     * {Object} The resulting parameters object. 
     */

    /** 
     * Method: createRequest
     * Issues a request for features by creating injecting a script in the 
     *     document head.
     *
     * Parameters:
     * url - {String} Service URL.
     * params - {Object} Query string parameters.
     * callback - {Function} Callback to be called with resulting data.
     *
     * Returns:
     * {HTMLScriptElement} The script pending execution.
     */
    createRequest: function(url, params, callback) {
        var id = GeoGlobe.Protocol.Script.register(callback);
        var name = GeoGlobe.String.format(this.callbackTemplate, {id: id});
        params = GeoGlobe.Util.extend({}, params);
        params[this.callbackKey] = this.callbackPrefix + name;
        url = GeoGlobe.Util.urlAppend(
            url, GeoGlobe.Util.getParameterString(params)
        );
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        script.id = "GeoGlobe_Protocol_Script_" + id;
        this.pendingRequests[script.id] = script;
        var head = document.getElementsByTagName("head")[0];
        head.appendChild(script);
        return script;
    },
    
    /** 
     * Method: destroyRequest
     * Remove a script node associated with a response from the document.  Also
     *     unregisters the callback and removes the script from the 
     *     <pendingRequests> object.
     *
     * Parameters:
     * script - {HTMLScriptElement}
     */
    destroyRequest: function(script) {
        GeoGlobe.Protocol.Script.unregister(script.id.split("_").pop());
        delete this.pendingRequests[script.id];
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
    },

    /**
     * Method: handleRead
     * Individual callbacks are created for read, create and update, should
     *     a subclass need to override each one separately.
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>} The response object to pass to
     *     the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(response, options) {
        this.handleResponse(response, options);
    },

    /**
     * Method: handleResponse
     * Called by CRUD specific handlers.
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create, read, update,
     *     or delete call.
     */
    handleResponse: function(response, options) {
        if (options.callback) {
            if (response.data) {
                response.features = this.parseFeatures(response.data);
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            this.destroyRequest(response.priv);
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Method: parseFeatures
     * Read Script response body and return features.
     *
     * Parameters:
     * data - {Object} The data sent to the callback function by the server.
     *
     * Returns:
     * {Array({<GeoGlobe.Feature>})} or
     *     {<GeoGlobe.Feature>} Array of features or a single feature.
     */
    parseFeatures: function(data) {
        return this.format.read(data);
    },

    /**
     * APIMethod: abort
     * Abort an ongoing request.  If no response is provided, all pending 
     *     requests will be aborted.
     *
     * Parameters:
     * response - {<GeoGlobe.Protocol.Response>} The response object returned
     *     from a <read> request.
     */
    abort: function(response) {
        if (response) {
            this.destroyRequest(response.priv);
        } else {
            for (var key in this.pendingRequests) {
                this.destroyRequest(this.pendingRequests[key]);
            }
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        this.abort();
        delete this.params;
        delete this.format;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    CLASS_NAME: "GeoGlobe.Protocol.Script" 
});

(function() {
    var o = GeoGlobe.Protocol.Script;
    var counter = 0;
    o.registry = {};
    
    /**
     * Function: GeoGlobe.Protocol.Script.register
     * Register a callback for a newly created script.
     *
     * Parameters:
     * callback - {Function} The callback to be executed when the newly added
     *     script loads.  This callback will be called with a single argument
     *     that is the JSON returned by the service.
     *
     * Returns:
     * {Number} An identifier for retrieving the registered callback.
     */
    o.register = function(callback) {
        var id = "c"+(++counter);
        o.registry[id] = function() {
            callback.apply(this, arguments);
        };
        return id;
    };
    
    /**
     * Function: GeoGlobe.Protocol.Script.unregister
     * Unregister a callback previously registered with the register function.
     *
     * Parameters:
     * id - {Number} The identifer returned by the register function.
     */
    o.unregister = function(id) {
        delete o.registry[id];
    };
})();
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/tool/Class.js
 * @requires View2D/tool/Util.js
 */

/**
 * Class: GeoGlobe.Format
 * Base class for format reading/writing a variety of formats.  Subclasses
 *     of GeoGlobe.Format are expected to have read and write methods.
 * 格式化基类。
 */
GeoGlobe.Format = GeoGlobe.Class4OL({
    
    /**
     * Property: options
     * {Object} A reference to options passed to the constructor.
     */
    options: null,
    
    /**
     * APIProperty: externalProjection
     * {<GeoGlobe.SpatialReference>} When passed a externalProjection and
     *     internalProjection, the format will reproject the geometries it
     *     reads or writes. The externalProjection is the projection used by
     *     the content which is passed into read or which comes out of write.
     *     In order to reproject, a projection transformation function for the
     *     specified projections must be available. This support may be 
     *     provided via proj4js or via a custom transformation function. See
     *     {<GeoGlobe.SpatialReference.addTransform>} for more information on
     *     custom transformations.
     */
    externalProjection: null,

    /**
     * APIProperty: internalProjection
     * {<GeoGlobe.SpatialReference>} When passed a externalProjection and
     *     internalProjection, the format will reproject the geometries it
     *     reads or writes. The internalProjection is the projection used by
     *     the geometries which are returned by read or which are passed into
     *     write.  In order to reproject, a projection transformation function
     *     for the specified projections must be available. This support may be
     *     provided via proj4js or via a custom transformation function. See
     *     {<GeoGlobe.SpatialReference.addTransform>} for more information on
     *     custom transformations.
     */
    internalProjection: null,

    /**
     * APIProperty: data
     * {Object} When <keepData> is true, this is the parsed string sent to
     *     <read>.
     */
    data: null,

    /**
     * APIProperty: keepData
     * {Object} Maintain a reference (<data>) to the most recently read data.
     *     Default is false.
     */
    keepData: false,

    /**
     * Constructor: GeoGlobe.Format
     * Instances of this class are not useful.  See one of the subclasses.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *           format
     *
     * Valid options:
     * keepData - {Boolean} If true, upon <read>, the data property will be
     *     set to the parsed object (e.g. the json or xml object).
     *
     * Returns:
     * An instance of GeoGlobe.Format
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
        this.options = options;
    },
    
    /**
     * APIMethod: destroy
     * Clean up.
     */
    destroy: function() {
    },

    /**
     * Method: read
     * Read data from a string, and return an object whose type depends on the
     * subclass. 
     * 
     * Parameters:
     * data - {string} Data to read/parse.
     *
     * Returns:
     * Depends on the subclass
     */
    read: function(data) {
        throw new Error('Read not implemented.');
    },
    
    /**
     * Method: write
     * Accept an object, and return a string. 
     *
     * Parameters:
     * object - {Object} Object to be serialized
     *
     * Returns:
     * {String} A string representation of the object.
     */
    write: function(object) {
        throw new Error('Write not implemented.');
    },

    CLASS_NAME: "GeoGlobe.Format"
});     
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/Format.js
 */

/**
 * Class: GeoGlobe.Format.XML
 * Read and write XML.  For cross-browser XML generation, use methods on an
 *     instance of the XML format class instead of on <code>document<end>.
 *     The DOM creation and traversing methods exposed here all mimic the
 *     W3C XML DOM methods.  Create a new parser with the
 *     <GeoGlobe.Format.XML> constructor.
 * XML的格式化类。
 *
 * Inherits from:
 *  - <GeoGlobe.Format>
 */
GeoGlobe.Format.XML = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.  Properties
     *     of this object should not be set individually.  Read-only.  All
     *     XML subclasses should have their own namespaces object.  Use
     *     <setNamespace> to add or set a namespace alias after construction.
     */
    namespaces: null,
    
    /**
     * Property: namespaceAlias
     * {Object} Mapping of namespace URI to namespace alias.  This object
     *     is read-only.  Use <setNamespace> to add or set a namespace alias.
     */
    namespaceAlias: null,
    
    /**
     * Property: defaultPrefix
     * {String} The default namespace alias for creating element nodes.
     */
    defaultPrefix: null,
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {},
    
    /**
     * Property: writers
     * As a compliment to the <readers> property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {},

    /**
     * Property: xmldom
     * {XMLDom} If this browser uses ActiveX, this will be set to a XMLDOM
     *     object.  It is not intended to be a browser sniffing property.
     *     Instead, the xmldom property is used instead of <code>document<end>
     *     where namespaced node creation methods are not supported. In all
     *     other browsers, this remains null.
     */
    xmldom: null,

    /**
     * Constructor: GeoGlobe.Format.XML
     * Construct an XML parser.  The parser is used to read and write XML.
     *     Reading XML from a string returns a DOM element.  Writing XML from
     *     a DOM element returns a string.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on
     *     the object.
     */
    initialize: function(options) {
        if(window.ActiveXObject) {
            this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
        }
        GeoGlobe.Format.prototype.initialize.apply(this, [options]);
        // clone the namespace object and set all namespace aliases
        this.namespaces = GeoGlobe.Util.extend({}, this.namespaces);
        this.namespaceAlias = {};
        for(var alias in this.namespaces) {
            this.namespaceAlias[this.namespaces[alias]] = alias;
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up.
     */
    destroy: function() {
        this.xmldom = null;
        GeoGlobe.Format.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: setNamespace
     * Set a namespace alias and URI for the format.
     *
     * Parameters:
     * alias - {String} The namespace alias (prefix).
     * uri - {String} The namespace URI.
     */
    setNamespace: function(alias, uri) {
        this.namespaces[alias] = uri;
        this.namespaceAlias[uri] = alias;
    },

    /**
     * APIMethod: read
     * Deserialize a XML string and return a DOM node.
     *
     * Parameters:
     * text - {String} A XML string
     
     * Returns:
     * {DOMElement} A DOM node
     */
    read: function(text) {
        var index = text.indexOf('<');
        if(index > 0) {
            text = text.substring(index);
        }
        var node = GeoGlobe.Util.Try(
            GeoGlobe.Function.bind((
                function() {
                    var xmldom;
                    /**
                     * Since we want to be able to call this method on the prototype
                     * itself, this.xmldom may not exist even if in IE.
                     */
                    if(window.ActiveXObject && !this.xmldom) {
                        xmldom = new ActiveXObject("Microsoft.XMLDOM");
                    } else {
                        xmldom = this.xmldom;
                        
                    }
                    xmldom.loadXML(text);
                    return xmldom;
                }
            ), this),
            function() {
                return new DOMParser().parseFromString(text, 'text/xml');
            },
            function() {
                var req = new XMLHttpRequest();
                req.open("GET", "data:" + "text/xml" +
                         ";charset=utf-8," + encodeURIComponent(text), false);
                if(req.overrideMimeType) {
                    req.overrideMimeType("text/xml");
                }
                req.send(null);
                return req.responseXML;
            }
        );

        if(this.keepData) {
            this.data = node;
        }

        return node;
    },

    /**
     * APIMethod: write
     * Serialize a DOM node into a XML string.
     * 
     * Parameters:
     * node - {DOMElement} A DOM node.
     *
     * Returns:
     * {String} The XML string representation of the input node.
     */
    write: function(node) {
        var data;
        //if(this.xmldom) {//20160407修改，解决不支持IE11的问题
        if(node.xml) {
            data = node.xml;
        } else {
            var serializer = new XMLSerializer();
            if (node.nodeType == 1) {
                // Add nodes to a document before serializing. Everything else
                // is serialized as is. This may need more work. See #1218 .
                var doc = document.implementation.createDocument("", "", null);
                if (doc.importNode) {
                    node = doc.importNode(node, true);
                }
                doc.appendChild(node);
                data = serializer.serializeToString(doc);
            } else {
                data = serializer.serializeToString(node);
            }
        }
        return data;
    },

    /**
     * APIMethod: createElementNS
     * Create a new element with namespace.  This node can be appended to
     *     another node with the standard node.appendChild method.  For
     *     cross-browser support, this method must be used instead of
     *     document.createElementNS.
     *
     * Parameters:
     * uri - {String} Namespace URI for the element.
     * name - {String} The qualified name of the element (prefix:localname).
     * 
     * Returns:
     * {Element} A DOM element with namespace.
     */
    createElementNS: function(uri, name) {
        var element;
        if(this.xmldom) {
            if(typeof uri == "string") {
                element = this.xmldom.createNode(1, name, uri);
            } else {
                element = this.xmldom.createNode(1, name, "");
            }
        } else {
            element = document.createElementNS(uri, name);
        }
        return element;
    },

    /**
     * APIMethod: createDocumentFragment
     * Create a document fragment node that can be appended to another node
     *     created by createElementNS.  This will call 
     *     document.createDocumentFragment outside of IE.  In IE, the ActiveX
     *     object's createDocumentFragment method is used.
     *
     * Returns:
     * {Element} A document fragment.
     */
    createDocumentFragment: function() {
        var element;
        if (this.xmldom) {
            element = this.xmldom.createDocumentFragment();
        } else {
            element = document.createDocumentFragment();
        }
        return element;
    },

    /**
     * APIMethod: createTextNode
     * Create a text node.  This node can be appended to another node with
     *     the standard node.appendChild method.  For cross-browser support,
     *     this method must be used instead of document.createTextNode.
     * 
     * Parameters:
     * text - {String} The text of the node.
     * 
     * Returns: 
     * {DOMElement} A DOM text node.
     */
    createTextNode: function(text) {
        var node;
        if (typeof text !== "string") {
            text = String(text);
        }
        if(this.xmldom) {
            node = this.xmldom.createTextNode(text);
        } else {
            node = document.createTextNode(text);
        }
        return node;
    },

    /**
     * APIMethod: getElementsByTagNameNS
     * Get a list of elements on a node given the namespace URI and local name.
     *     To return all nodes in a given namespace, use '*' for the name
     *     argument.  To return all nodes of a given (local) name, regardless
     *     of namespace, use '*' for the uri argument.
     * 
     * Parameters:
     * node - {Element} Node on which to search for other nodes.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the tag (without the prefix).
     * 
     * Returns:
     * {NodeList} A node list or array of elements.
     */
    getElementsByTagNameNS: function(node, uri, name) {
        var elements = [];
        if(node.getElementsByTagNameNS) {
            elements = node.getElementsByTagNameNS(uri, name);
        } else {
            // brute force method
            var allNodes = node.getElementsByTagName("*");
            var potentialNode, fullName;
            for(var i=0, len=allNodes.length; i<len; ++i) {
                potentialNode = allNodes[i];
                fullName = (potentialNode.prefix) ?
                           (potentialNode.prefix + ":" + name) : name;
                if((name == "*") || (fullName == potentialNode.nodeName)) {
                    if((uri == "*") || (uri == potentialNode.namespaceURI)) {
                        elements.push(potentialNode);
                    }
                }
            }
        }
        return elements;
    },

    /**
     * APIMethod: getAttributeNodeNS
     * Get an attribute node given the namespace URI and local name.
     * 
     * Parameters:
     * node - {Element} Node on which to search for attribute nodes.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the attribute (without the prefix).
     * 
     * Returns:
     * {DOMElement} An attribute node or null if none found.
     */
    getAttributeNodeNS: function(node, uri, name) {
        var attributeNode = null;
        if(node.getAttributeNodeNS) {
            attributeNode = node.getAttributeNodeNS(uri, name);
        } else {
            var attributes = node.attributes;
            var potentialNode, fullName;
            for(var i=0, len=attributes.length; i<len; ++i) {
                potentialNode = attributes[i];
                if(potentialNode.namespaceURI == uri) {
                    fullName = (potentialNode.prefix) ?
                               (potentialNode.prefix + ":" + name) : name;
                    if(fullName == potentialNode.nodeName) {
                        attributeNode = potentialNode;
                        break;
                    }
                }
            }
        }
        return attributeNode;
    },

    /**
     * APIMethod: getAttributeNS
     * Get an attribute value given the namespace URI and local name.
     * 
     * Parameters:
     * node - {Element} Node on which to search for an attribute.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the attribute (without the prefix).
     * 
     * Returns:
     * {String} An attribute value or and empty string if none found.
     */
    getAttributeNS: function(node, uri, name) {
        var attributeValue = "";
        if(node.getAttributeNS) {
            attributeValue = node.getAttributeNS(uri, name) || "";
        } else {
            var attributeNode = this.getAttributeNodeNS(node, uri, name);
            if(attributeNode) {
                attributeValue = attributeNode.nodeValue;
            }
        }
        return attributeValue;
    },
    
    /**
     * APIMethod: getChildValue
     * Get the textual value of the node if it exists, or return an
     *     optional default string.  Returns an empty string if no first child
     *     exists and no default value is supplied.
     *
     * Parameters:
     * node - {DOMElement} The element used to look for a first child value.
     * def - {String} Optional string to return in the event that no
     *     first child value exists.
     *
     * Returns:
     * {String} The value of the first child of the given node.
     */
    getChildValue: function(node, def) {
        var value = def || "";
        if(node) {
            for(var child=node.firstChild; child; child=child.nextSibling) {
                switch(child.nodeType) {
                    case 3: // text node
                    case 4: // cdata section
                        value += child.nodeValue;
                }
            }
        }
        return value;
    },

    /**
     * APIMethod: isSimpleContent
     * Test if the given node has only simple content (i.e. no child element
     *     nodes).
     *
     * Parameters:
     * node - {DOMElement} An element node.
     *
     * Returns:
     * {Boolean} The node has no child element nodes (nodes of type 1). 
     */
    isSimpleContent: function(node) {
        var simple = true;
        for(var child=node.firstChild; child; child=child.nextSibling) {
            if(child.nodeType === 1) {
                simple = false;
                break;
            }
        }
        return simple;
    },
    
    /**
     * APIMethod: contentType
     * Determine the content type for a given node.
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {Integer} One of GeoGlobe.Format.XML.CONTENT_TYPE.{EMPTY,SIMPLE,COMPLEX,MIXED}
     *     if the node has no, simple, complex, or mixed content.
     */
    contentType: function(node) {
        var simple = false,
            complex = false;
            
        var type = GeoGlobe.Format.XML.CONTENT_TYPE.EMPTY;

        for(var child=node.firstChild; child; child=child.nextSibling) {
            switch(child.nodeType) {
                case 1: // element
                    complex = true;
                    break;
                case 8: // comment
                    break;
                default:
                    simple = true;
            }
            if(complex && simple) {
                break;
            }
        }
        
        if(complex && simple) {
            type = GeoGlobe.Format.XML.CONTENT_TYPE.MIXED;
        } else if(complex) {
            return GeoGlobe.Format.XML.CONTENT_TYPE.COMPLEX;
        } else if(simple) {
            return GeoGlobe.Format.XML.CONTENT_TYPE.SIMPLE;
        }
        return type;
    },

    /**
     * APIMethod: hasAttributeNS
     * Determine whether a node has a particular attribute matching the given
     *     name and namespace.
     * 
     * Parameters:
     * node - {Element} Node on which to search for an attribute.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the attribute (without the prefix).
     * 
     * Returns:
     * {Boolean} The node has an attribute matching the name and namespace.
     */
    hasAttributeNS: function(node, uri, name) {
        var found = false;
        if(node.hasAttributeNS) {
            found = node.hasAttributeNS(uri, name);
        } else {
            found = !!this.getAttributeNodeNS(node, uri, name);
        }
        return found;
    },
    
    /**
     * APIMethod: setAttributeNS
     * Adds a new attribute or changes the value of an attribute with the given
     *     namespace and name.
     *
     * Parameters:
     * node - {Element} Element node on which to set the attribute.
     * uri - {String} Namespace URI for the attribute.
     * name - {String} Qualified name (prefix:localname) for the attribute.
     * value - {String} Attribute value.
     */
    setAttributeNS: function(node, uri, name, value) {
        if(node.setAttributeNS) {
            node.setAttributeNS(uri, name, value);
        } else {
            if(this.xmldom) {
                if(uri) {
                    var attribute = node.ownerDocument.createNode(
                        2, name, uri
                    );
                    attribute.nodeValue = value;
                    node.setAttributeNode(attribute);
                } else {
                    node.setAttribute(name, value);
                }
            } else {
                throw "setAttributeNS not implemented";
            }
        }
    },

    /**
     * Method: createElementNSPlus
     * Shorthand for creating namespaced elements with optional attributes and
     *     child text nodes.
     *
     * Parameters:
     * name - {String} The qualified node name.
     * options - {Object} Optional object for node configuration.
     *
     * Valid options:
     * uri - {String} Optional namespace uri for the element - supply a prefix
     *     instead if the namespace uri is a property of the format's namespace
     *     object.
     * attributes - {Object} Optional attributes to be set using the
     *     <setAttributes> method.
     * value - {String} Optional text to be appended as a text node.
     *
     * Returns:
     * {Element} An element node.
     */
    createElementNSPlus: function(name, options) {
        options = options || {};
        // order of prefix preference
        // 1. in the uri option
        // 2. in the prefix option
        // 3. in the qualified name
        // 4. from the defaultPrefix
        var uri = options.uri || this.namespaces[options.prefix];
        if(!uri) {
            var loc = name.indexOf(":");
            uri = this.namespaces[name.substring(0, loc)];
        }
        if(!uri) {
            uri = this.namespaces[this.defaultPrefix];
        }
        var node = this.createElementNS(uri, name);
        if(options.attributes) {
            this.setAttributes(node, options.attributes);
        }
        var value = options.value;
        if(value != null) {
            node.appendChild(this.createTextNode(value));
        }
        return node;
    },
    
    /**
     * Method: setAttributes
     * Set multiple attributes given key value pairs from an object.
     *
     * Parameters:
     * node - {Element} An element node.
     * obj - {Object || Array} An object whose properties represent attribute
     *     names and values represent attribute values.  If an attribute name
     *     is a qualified name ("prefix:local"), the prefix will be looked up
     *     in the parsers {namespaces} object.  If the prefix is found,
     *     setAttributeNS will be used instead of setAttribute.
     */
    setAttributes: function(node, obj) {
        var value, uri;
        for(var name in obj) {
            if(obj[name] != null && obj[name].toString) {
                value = obj[name].toString();
                // check for qualified attribute name ("prefix:local")
                uri = this.namespaces[name.substring(0, name.indexOf(":"))] || null;
                this.setAttributeNS(node, uri, name, value);
            }
        }
    },

    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var group = this.readers[node.namespaceURI ? this.namespaceAlias[node.namespaceURI]: this.defaultPrefix];
        if(group) {
            var local = node.localName || node.nodeName.split(":").pop();
            var reader = group[local] || group["*"];
            if(reader) {
                reader.apply(this, [node, obj]);
            }
        }
        return obj;
    },

    /**
     * Method: readChildNodes
     * Shorthand for applying the named readers to all children of a node.
     *     For each child of type 1 (element), <readSelf> is called.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     *
     * Returns:
     * {Object} The input object, modified.
     */
    readChildNodes: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var children = node.childNodes;
        var child;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                this.readNode(child, obj);
            }
        }
        return obj;
    },

    /**
     * Method: writeNode
     * Shorthand for applying one of the named writers and appending the
     *     results to a node.  If a qualified name is not provided for the
     *     second argument (and a local name is used instead), the namespace
     *     of the parent node will be assumed.
     *
     * Parameters:
     * name - {String} The name of a node to generate.  If a qualified name
     *     (e.g. "pre:Name") is used, the namespace prefix is assumed to be
     *     in the <writers> group.  If a local name is used (e.g. "Name") then
     *     the namespace of the parent is assumed.  If a local name is used
     *     and no parent is supplied, then the default namespace is assumed.
     * obj - {Object} Structure containing data for the writer.
     * parent - {DOMElement} Result will be appended to this node.  If no parent
     *     is supplied, the node will not be appended to anything.
     *
     * Returns:
     * {DOMElement} The child node.
     */
    writeNode: function(name, obj, parent) {
        var prefix, local;
        var split = name.indexOf(":");
        if(split > 0) {
            prefix = name.substring(0, split);
            local = name.substring(split + 1);
        } else {
            if(parent) {
                prefix = this.namespaceAlias[parent.namespaceURI];
            } else {
                prefix = this.defaultPrefix;
            }
            local = name;
        }
        var child = this.writers[prefix][local].apply(this, [obj]);
        if(parent) {
            parent.appendChild(child);
        }
        return child;
    },

    /**
     * APIMethod: getChildEl
     * Get the first child element.  Optionally only return the first child
     *     if it matches the given name and namespace URI.
     *
     * Parameters:
     * node - {DOMElement} The parent node.
     * name - {String} Optional node name (local) to search for.
     * uri - {String} Optional namespace URI to search for.
     *
     * Returns:
     * {DOMElement} The first child.  Returns null if no element is found, if
     *     something significant besides an element is found, or if the element
     *     found does not match the optional name and uri.
     */
    getChildEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.firstChild, name, uri);
    },
    
    /**
     * APIMethod: getNextEl
     * Get the next sibling element.  Optionally get the first sibling only
     *     if it matches the given local name and namespace URI.
     *
     * Parameters:
     * node - {DOMElement} The node.
     * name - {String} Optional local name of the sibling to search for.
     * uri - {String} Optional namespace URI of the sibling to search for.
     *
     * Returns:
     * {DOMElement} The next sibling element.  Returns null if no element is
     *     found, something significant besides an element is found, or the
     *     found element does not match the optional name and uri.
     */
    getNextEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.nextSibling, name, uri);
    },
    
    /**
     * Method: getThisOrNextEl
     * Return this node or the next element node.  Optionally get the first
     *     sibling with the given local name or namespace URI.
     *
     * Parameters:
     * node - {DOMElement} The node.
     * name - {String} Optional local name of the sibling to search for.
     * uri - {String} Optional namespace URI of the sibling to search for.
     *
     * Returns:
     * {DOMElement} The next sibling element.  Returns null if no element is
     *     found, something significant besides an element is found, or the
     *     found element does not match the query.
     */
    getThisOrNextEl: function(node, name, uri) {
        outer: for(var sibling=node; sibling; sibling=sibling.nextSibling) {
            switch(sibling.nodeType) {
                case 1: // Element
                    if((!name || name === (sibling.localName || sibling.nodeName.split(":").pop())) &&
                       (!uri || uri === sibling.namespaceURI)) {
                        // matches
                        break outer;
                    }
                    sibling = null;
                    break outer;
                case 3: // Text
                    if(/^\s*$/.test(sibling.nodeValue)) {
                        break;
                    }
                case 4: // CDATA
                case 6: // ENTITY_NODE
                case 12: // NOTATION_NODE
                case 10: // DOCUMENT_TYPE_NODE
                case 11: // DOCUMENT_FRAGMENT_NODE
                    sibling = null;
                    break outer;
            } // ignore comments and processing instructions
        }
        return sibling || null;
    },
    
    /**
     * APIMethod: lookupNamespaceURI
     * Takes a prefix and returns the namespace URI associated with it on the given
     *     node if found (and null if not). Supplying null for the prefix will
     *     return the default namespace.
     *
     * For browsers that support it, this calls the native lookupNamesapceURI
     *     function.  In other browsers, this is an implementation of
     *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
     *
     * For browsers that don't support the attribute.ownerElement property, this
     *     method cannot be called on attribute nodes.
     *     
     * Parameters:
     * node - {DOMElement} The node from which to start looking.
     * prefix - {String} The prefix to lookup or null to lookup the default namespace.
     * 
     * Returns:
     * {String} The namespace URI for the given prefix.  Returns null if the prefix
     *     cannot be found or the node is the wrong type.
     */
    lookupNamespaceURI: function(node, prefix) {
        var uri = null;
        if(node) {
            if(node.lookupNamespaceURI) {
                uri = node.lookupNamespaceURI(prefix);
            } else {
                outer: switch(node.nodeType) {
                    case 1: // ELEMENT_NODE
                        if(node.namespaceURI !== null && node.prefix === prefix) {
                            uri = node.namespaceURI;
                            break outer;
                        }
                        var len = node.attributes.length;
                        if(len) {
                            var attr;
                            for(var i=0; i<len; ++i) {
                                attr = node.attributes[i];
                                if(attr.prefix === "xmlns" && attr.name === "xmlns:" + prefix) {
                                    uri = attr.value || null;
                                    break outer;
                                } else if(attr.name === "xmlns" && prefix === null) {
                                    uri = attr.value || null;
                                    break outer;
                                }
                            }
                        }
                        uri = this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                    case 2: // ATTRIBUTE_NODE
                        uri = this.lookupNamespaceURI(node.ownerElement, prefix);
                        break outer;
                    case 9: // DOCUMENT_NODE
                        uri = this.lookupNamespaceURI(node.documentElement, prefix);
                        break outer;
                    case 6: // ENTITY_NODE
                    case 12: // NOTATION_NODE
                    case 10: // DOCUMENT_TYPE_NODE
                    case 11: // DOCUMENT_FRAGMENT_NODE
                        break outer;
                    default: 
                        // TEXT_NODE (3), CDATA_SECTION_NODE (4), ENTITY_REFERENCE_NODE (5),
                        // PROCESSING_INSTRUCTION_NODE (7), COMMENT_NODE (8)
                        uri =  this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                }
            }
        }
        return uri;
    },
    
    /**
     * Method: getXMLDoc
     * Get an XML document for nodes that are not supported in HTML (e.g.
     * createCDATASection). On IE, this will either return an existing or
     * create a new <xmldom> on the instance. On other browsers, this will
     * either return an existing or create a new shared document (see
     * <GeoGlobe.Format.XML.document>).
     *
     * Returns:
     * {XMLDocument}
     */
    getXMLDoc: function() {
        if (!GeoGlobe.Format.XML.document && !this.xmldom) {
            if (document.implementation && document.implementation.createDocument) {
                GeoGlobe.Format.XML.document =
                    document.implementation.createDocument("", "", null);
            } else if (!this.xmldom && window.ActiveXObject) {
                this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
            }
        }
        return GeoGlobe.Format.XML.document || this.xmldom;
    },

    CLASS_NAME: "GeoGlobe.Format.XML" 

});     

GeoGlobe.Format.XML.CONTENT_TYPE = {EMPTY: 0, SIMPLE: 1, COMPLEX: 2, MIXED: 3};

/**
 * APIFunction: GeoGlobe.Format.XML.lookupNamespaceURI
 * Takes a prefix and returns the namespace URI associated with it on the given
 *     node if found (and null if not). Supplying null for the prefix will
 *     return the default namespace.
 *
 * For browsers that support it, this calls the native lookupNamesapceURI
 *     function.  In other browsers, this is an implementation of
 *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
 *
 * For browsers that don't support the attribute.ownerElement property, this
 *     method cannot be called on attribute nodes.
 *     
 * Parameters:
 * node - {DOMElement} The node from which to start looking.
 * prefix - {String} The prefix to lookup or null to lookup the default namespace.
 * 
 * Returns:
 * {String} The namespace URI for the given prefix.  Returns null if the prefix
 *     cannot be found or the node is the wrong type.
 */
GeoGlobe.Format.XML.lookupNamespaceURI = GeoGlobe.Function.bind(
    GeoGlobe.Format.XML.prototype.lookupNamespaceURI,
    GeoGlobe.Format.XML.prototype
);

/**
 * Property: GeoGlobe.Format.XML.document
 * {XMLDocument} XML document to reuse for creating non-HTML compliant nodes,
 * like document.createCDATASection.
 */
GeoGlobe.Format.XML.document = null;
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/XML.js
 * @requires View2D/Format/OGCExceptionReport.js
 */

/**
 * Class: GeoGlobe.Format.XML.VersionedOGC
 * Base class for versioned formats, i.e. a format which supports multiple
 * versions.
 *
 * To enable checking if parsing succeeded, you will need to define a property
 * called errorProperty on the parser you want to check. The parser will then
 * check the returned object to see if that property is present. If it is, it
 * assumes the parsing was successful. If it is not present (or is null), it will
 * pass the document through an OGCExceptionReport parser.
 * 
 * If errorProperty is undefined for the parser, this error checking mechanism
 * will be disabled.
 *
 *
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.XML.VersionedOGC = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.
     */
    defaultVersion: null,
    
    /**
     * APIProperty: version
     * {String} Specify a version string if one is known.
     */
    version: null,

    /**
     * APIProperty: profile
     * {String} If provided, use a custom profile.
     */
    profile: null,

    /**
     * APIProperty: allowFallback
     * {Boolean} If a profiled parser cannot be found for the returned version,
     * use a non-profiled parser as the fallback. Application code using this
     * should take into account that the return object structure might be
     * missing the specifics of the profile. Defaults to false.
     */
    allowFallback: false,

    /**
     * Property: name
     * {String} The name of this parser, this is the part of the CLASS_NAME
     * except for "GeoGlobe.Format."
     */
    name: null,

    /**
     * APIProperty: stringifyOutput
     * {Boolean} If true, write will return a string otherwise a DOMElement.
     * Default is false.
     */
    stringifyOutput: false,

    /**
     * Property: parser
     * {Object} Instance of the versioned parser.  Cached for multiple read and
     *     write calls of the same version.
     */
    parser: null,

    /**
     * Constructor: GeoGlobe.Format.XML.VersionedOGC.
     * Constructor.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on
     *     the object.
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        var className = this.CLASS_NAME;
        this.name = className.substring(className.lastIndexOf(".")+1);
    },

    /**
     * Method: getVersion
     * Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     *
     * Parameters:
     * root - {DOMElement}
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} The version to use.
     */
    getVersion: function(root, options) {
        var version;
        // read
        if (root) {
            version = this.version;
            if(!version) {
                version = root.getAttribute("version");
                if(!version) {
                    version = this.defaultVersion;
                }
            }
        } else { // write
            version = (options && options.version) || 
                this.version || this.defaultVersion;
        }
        return version;
    },

    /**
     * Method: getParser
     * Get an instance of the cached parser if available, otherwise create one.
     *
     * Parameters:
     * version - {String}
     *
     * Returns:
     * {<GeoGlobe.Format>}
     */
    getParser: function(version) {
        version = version || this.defaultVersion;
        var profile = this.profile ? "_" + this.profile : "";
        if(!this.parser || this.parser.VERSION != version) {
            var format = GeoGlobe.Format[this.name][
                "v" + version.replace(/\./g, "_") + profile
            ];
            if(!format) {
                if (profile !== "" && this.allowFallback) {
                    // fallback to the non-profiled version of the parser
                    profile = "";
                    format = GeoGlobe.Format[this.name][
                        "v" + version.replace(/\./g, "_")
                    ];
                }
                if (!format) {
                    throw "Can't find a " + this.name + " parser for version " +
                          version + profile;
                }
            }
            this.parser = new format(this.options);
        }
        return this.parser;
    },

    /**
     * APIMethod: write
     * Write a document.
     *
     * Parameters:
     * obj - {Object} An object representing the document.
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} The document as a string
     */
    write: function(obj, options) {
        var version = this.getVersion(null, options);
        this.parser = this.getParser(version);
        var root = this.parser.write(obj, options);
        if (this.stringifyOutput === false) {
            return root;
        } else {
            return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
        }
    },

    /**
     * APIMethod: read
     * Read a doc and return an object representing the document.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the document.
     */
    read: function(data, options) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var version = this.getVersion(root);
        this.parser = this.getParser(version);          // Select the parser
        var obj = this.parser.read(data, options);      // Parse the data

        var errorProperty = this.parser.errorProperty || null;
        if (errorProperty !== null && obj[errorProperty] === undefined) {
            // an error must have happened, so parse it and report back
            var format = new GeoGlobe.Format.OGCExceptionReport();
            obj.error = format.read(data);
        }
        obj.version = version;
        return obj;
    },

    CLASS_NAME: "GeoGlobe.Format.XML.VersionedOGC"
});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML.js
 * @requires GeoGlobe/Feature/Feature.js
 * @requires GeoGlobe/Geometry/Point.js
 * @requires GeoGlobe/Geometry/MultiPoint.js
 * @requires GeoGlobe/Geometry/LineString.js
 * @requires GeoGlobe/Geometry/MultiLineString.js
 * @requires GeoGlobe/Geometry/Polygon.js
 * @requires GeoGlobe/Geometry/MultiPolygon.js
 */

/**
 * Class: GeoGlobe.Format.GML
 * Read/Write GML. Create a new instance with the <GeoGlobe.Format.GML>
 *     constructor.  Supports the GML simple features profile.
 * 解析GML文件类
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.GML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * APIProperty: featureNS
     * {String} Namespace used for feature attributes.  Default is
     *     "http://mapserver.gis.umn.edu/mapserver".
     */
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    
    /**
     * APIProperty: featurePrefix
     * {String} Namespace alias (or prefix) for feature nodes.  Default is
     *     "feature".
     */
    featurePrefix: "feature",
    
    /**
     * APIProperty: featureName
     * {String} Element name for features. Default is "featureMember".
     */
    featureName: "featureMember", 
    
    /**
     * APIProperty: layerName
     * {String} Name of data layer. Default is "features".
     */
    layerName: "features",
    
    /**
     * APIProperty: geometryName
     * {String} Name of geometry element.  Defaults to "geometry".
     */
    geometryName: "geometry",
    
    /** 
     * APIProperty: collectionName
     * {String} Name of featureCollection element.
     */
    collectionName: "FeatureCollection",
    
    /**
     * APIProperty: gmlns
     * {String} GML Namespace.
     */
    gmlns: "http://www.opengis.net/gml",

    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from GML.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */ 
    xy: true,
    
    /**
     * Constructor: GeoGlobe.Format.GML
     * Create a new parser for GML.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g)
        };
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Read data from a string, and return a list of features. 
     * 读取数据解析并且返回要素数组。
     * 
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array(<GeoGlobe.Feature.Vector>)} An array of features.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var featureNodes = this.getElementsByTagNameNS(data.documentElement,
                                                       this.gmlns,
                                                       this.featureName);
        var features = [];
        for(var i=0; i<featureNodes.length; i++) {
            var feature = this.parseFeature(featureNodes[i]);
            if(feature) {
                features.push(feature);
            }
        }
        return features;
    },
    
    /**
     * Method: parseFeature
     * This function is the core of the GML parsing code in GeoGlobe.
     *    It creates the geometries that are then attached to the returned
     *    feature, and calls parseAttributes() to get attribute data out.
     *    
     * Parameters:
     * node - {DOMElement} A GML feature node. 
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiPolygon", "Polygon",
                     "MultiLineString", "LineString",
                     "MultiPoint", "Point", "Envelope"];
        // FIXME: In case we parse a feature with no geometry, but boundedBy an Envelope,
        // this code creates a geometry derived from the Envelope. This is not correct.
        var type, nodeList, geometry, parser;
        for(var i=0; i<order.length; ++i) {
            type = order[i];
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        var bounds;
        var boxNodes = this.getElementsByTagNameNS(node, this.gmlns, "Box");
        for(i=0; i<boxNodes.length; ++i) {
            var boxNode = boxNodes[i];
            var box = this.parseGeometry["box"].apply(this, [boxNode]);
            var parentNode = boxNode.parentNode;
            var parentName = parentNode.localName ||
                             parentNode.nodeName.split(":").pop();
            if(parentName === "boundedBy") {
                bounds = box;
            } else {
                geometry = box.toGeometry();
            }
        }
        
        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new GeoGlobe.Feature(geometry, attributes);
        feature.bounds = bounds;
        
        feature.gml = {
            featureType: node.firstChild.nodeName.split(":")[1],
            featureNS: node.firstChild.namespaceURI,
            featureNSPrefix: node.firstChild.prefix
        };
                
        // assign fid - this can come from a "fid" or "id" attribute
        var childNode = node.firstChild;
        var fid;
        while(childNode) {
            if(childNode.nodeType == 1) {
                fid = childNode.getAttribute("fid") ||
                      childNode.getAttribute("id");
                if(fid) {
                    break;
                }
            }
            childNode = childNode.nextSibling;
        }
        feature.fid = fid;
        return feature;
    },
    
    /**
     * Property: parseGeometry
     * Properties of this object are the functions that parse geometries based
     *     on their type.
     */
    parseGeometry: {
        
        /**
         * Method: parseGeometry.point
         * Given a GML node representing a point geometry, create an GeoGlobe
         *     point geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.Point>} A point geometry.
         */
        point: function(node) {
            /**
             * Three coordinate variations to consider:
             * 1) <gml:pos>x y z</gml:pos>
             * 2) <gml:coordinates>x, y, z</gml:coordinates>
             * 3) <gml:coord><gml:X>x</gml:X><gml:Y>y</gml:Y></gml:coord>
             */
            var nodeList, coordString;
            var coords = [];

            // look for <gml:pos>
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns, "pos");
            if(nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = nodeList[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.removeSpace,
                                                      "");
                    coords = coordString.split(",");
                }
            }

            // look for <gml:coord>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coord");
                if(nodeList.length > 0) {
                    var xList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "X");
                    var yList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "Y");
                    if(xList.length > 0 && yList.length > 0) {
                        coords = [xList[0].firstChild.nodeValue,
                                  yList[0].firstChild.nodeValue];
                    }
                }
            }
                
            // preserve third dimension
            if(coords.length == 2) {
                coords[2] = null;
            }
            
            if (this.xy) {
                return new GeoGlobe.Geometry.Point(coords[0], coords[1],
                                                 coords[2]);
            }
            else{
                return new GeoGlobe.Geometry.Point(coords[1], coords[0],
                                                 coords[2]);
            }
        },
        
        /**
         * Method: parseGeometry.multipoint
         * Given a GML node representing a multipoint geometry, create an
         *     GeoGlobe multipoint geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.MultiPoint>} A multipoint geometry.
         */
        multipoint: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Point");
            var components = [];
            if(nodeList.length > 0) {
                var point;
                for(var i=0; i<nodeList.length; ++i) {
                    point = this.parseGeometry.point.apply(this, [nodeList[i]]);
                    if(point) {
                        components.push(point);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiPoint(components);
        },
        
        /**
         * Method: parseGeometry.linestring
         * Given a GML node representing a linestring geometry, create an
         *     GeoGlobe linestring geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.LineString>} A linestring geometry.
         */
        linestring: function(node, ring) {
            /**
             * Two coordinate variations to consider:
             * 1) <gml:posList dimension="d">x0 y0 z0 x1 y1 z1</gml:posList>
             * 2) <gml:coordinates>x0, y0, z0 x1, y1, z1</gml:coordinates>
             */
            var nodeList, coordString;
            var coords = [];
            var points = [];

            // look for <gml:posList>
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, "posList");
            if(nodeList.length > 0) {
                coordString = this.getChildValue(nodeList[0]);
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
                var dim = parseInt(nodeList[0].getAttribute("dimension"));
                var j, x, y, z;
                for(var i=0; i<coords.length/dim; ++i) {
                    j = i * dim;
                    x = coords[j];
                    y = coords[j+1];
                    z = (dim == 2) ? null : coords[j+2];
                    if (this.xy) {
                        points.push(new GeoGlobe.Geometry.Point(x, y, z));
                    } else {
                        points.push(new GeoGlobe.Geometry.Point(y, x, z));
                    }
                }
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = this.getChildValue(nodeList[0]);
                    coordString = coordString.replace(this.regExes.trimSpace,
                                                      "");
                    coordString = coordString.replace(this.regExes.trimComma,
                                                      ",");
                    var pointList = coordString.split(this.regExes.splitSpace);
                    for(var i=0; i<pointList.length; ++i) {
                        coords = pointList[i].split(",");
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        if (this.xy) {
                            points.push(new GeoGlobe.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]));
                        } else {
                            points.push(new GeoGlobe.Geometry.Point(coords[1],
                                                                  coords[0],
                                                                  coords[2]));
                        }
                    }
                }
            }

            var line = null;
            if(points.length != 0) {
                if(ring) {
                    line = new GeoGlobe.Geometry.LinearRing(points);
                } else {
                    line = new GeoGlobe.Geometry.LineString(points);
                }
            }
            return line;
        },
        
        /**
         * Method: parseGeometry.multilinestring
         * Given a GML node representing a multilinestring geometry, create an
         *     GeoGlobe multilinestring geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.MultiLineString>} A multilinestring geometry.
         */
        multilinestring: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LineString");
            var components = [];
            if(nodeList.length > 0) {
                var line;
                for(var i=0; i<nodeList.length; ++i) {
                    line = this.parseGeometry.linestring.apply(this,
                                                               [nodeList[i]]);
                    if(line) {
                        components.push(line);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiLineString(components);
        },
        
        /**
         * Method: parseGeometry.polygon
         * Given a GML node representing a polygon geometry, create an
         *     GeoGlobe polygon geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.Polygon>} A polygon geometry.
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LinearRing");
            var components = [];
            if(nodeList.length > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0; i<nodeList.length; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components.push(ring);
                    }
                }
            }
            return new GeoGlobe.Geometry.Polygon(components);
        },
        
        /**
         * Method: parseGeometry.multipolygon
         * Given a GML node representing a multipolygon geometry, create an
         *     GeoGlobe multipolygon geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.MultiPolygon>} A multipolygon geometry.
         */
        multipolygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Polygon");
            var components = [];
            if(nodeList.length > 0) {
                var polygon;
                for(var i=0; i<nodeList.length; ++i) {
                    polygon = this.parseGeometry.polygon.apply(this,
                                                               [nodeList[i]]);
                    if(polygon) {
                        components.push(polygon);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiPolygon(components);
        },
        
        envelope: function(node) {
            var components = [];
            var coordString;
            var envelope;
            
            var lpoint = this.getElementsByTagNameNS(node, this.gmlns, "lowerCorner");
            if (lpoint.length > 0) {
                var coords = [];
                
                if(lpoint.length > 0) {
                    coordString = lpoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var lowerPoint = new GeoGlobe.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var lowerPoint = new GeoGlobe.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            var upoint = this.getElementsByTagNameNS(node, this.gmlns, "upperCorner");
            if (upoint.length > 0) {
                var coords = [];
                
                if(upoint.length > 0) {
                    coordString = upoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var upperPoint = new GeoGlobe.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var upperPoint = new GeoGlobe.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            if (lowerPoint && upperPoint) {
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, lowerPoint.y));
                components.push(new GeoGlobe.Geometry.Point(upperPoint.x, lowerPoint.y));
                components.push(new GeoGlobe.Geometry.Point(upperPoint.x, upperPoint.y));
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, upperPoint.y));
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, lowerPoint.y));
                
                var ring = new GeoGlobe.Geometry.LinearRing(components);
                envelope = new GeoGlobe.Geometry.Polygon([ring]);
            }
            return envelope; 
        },

        /**
         * Method: parseGeometry.box
         * Given a GML node representing a box geometry, create an
         *     GeoGlobe.Bounds.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<GeoGlobe.Bounds>} A bounds representing the box.
         */
        box: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                   "coordinates");
            var coordString;
            var coords, beginPoint = null, endPoint = null;
            if (nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coords = coordString.split(" ");
                if (coords.length == 2) {
                    beginPoint = coords[0].split(",");
                    endPoint = coords[1].split(",");
                }
            }
            if (beginPoint !== null && endPoint !== null) {
                var sw = new GeoGlobe.LngLat(parseFloat(beginPoint[0]), parseFloat(beginPoint[1]));
				var ne = new GeoGlobe.LngLat(parseFloat(endPoint[0]), parseFloat(endPoint[1]));
				return new GeoGlobe.LngLatBounds(sw, ne);
            }
        }
        
    },
    
    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {Object} An attributes object.
     */
    parseAttributes: function(node) {
        var attributes = {};
        // assume attributes are children of the first type 1 child
        var childNode = node.firstChild;
        var children, i, child, grandchildren, grandchild, name, value;
        while(childNode) {
            if(childNode.nodeType == 1) {
                // attributes are type 1 children with one type 3 child
                children = childNode.childNodes;
                for(i=0; i<children.length; ++i) {
                    child = children[i];
                    if(child.nodeType == 1) {
                        grandchildren = child.childNodes;
                        if(grandchildren.length == 1) {
                            grandchild = grandchildren[0];
                            if(grandchild.nodeType == 3 ||
                               grandchild.nodeType == 4) {
                                name = (child.prefix) ?
                                        child.nodeName.split(":")[1] :
                                        child.nodeName;
                                value = grandchild.nodeValue.replace(
                                                this.regExes.trimSpace, "");
                                attributes[name] = value;
                            }
                        } else {
                            // If child has no childNodes (grandchildren),
                            // set an attribute with null value.
                            // e.g. <prefix:fieldname/> becomes
                            // {fieldname: null}
                            attributes[child.nodeName.split(":").pop()] = null;
                        }
                    }
                }
                break;
            }
            childNode = childNode.nextSibling;
        }
        return attributes;
    },
    
    /**
     * APIMethod: write
     * Generate a GML document string given a list of features. 
     * 根据要素数组生成GML格式数据。
     * 
     * Parameters:
     * features - {Array(<GeoGlobe.Feature.Vector>)} List of features to
     *     serialize into a string.
     *
     * Returns:
     * {String} A string representing the GML document.
     */
    write: function(features) {
        if(!(GeoGlobe.Util.isArray(features))) {
            features = [features];
        }
        var gml = this.createElementNS("http://www.opengis.net/wfs",
                                       "wfs:" + this.collectionName);
        for(var i=0; i<features.length; i++) {
            gml.appendChild(this.createFeatureXML(features[i]));
        }
        return GeoGlobe.Format.XML.prototype.write.apply(this, [gml]);
    },

    /** 
     * Method: createFeatureXML
     * Accept an GeoGlobe.Feature.Vector, and build a GML node for it.
     *
     * Parameters:
     * feature - {<GeoGlobe.Feature.Vector>} The feature to be built as GML.
     *
     * Returns:
     * {DOMElement} A node reprensting the feature in GML.
     */
    createFeatureXML: function(feature) {
        var geometry = feature.geometry;
        var geometryNode = this.buildGeometryNode(geometry);
        var geomContainer = this.createElementNS(this.featureNS,
                                                 this.featurePrefix + ":" +
                                                 this.geometryName);
        geomContainer.appendChild(geometryNode);
        var featureNode = this.createElementNS(this.gmlns,
                                               "gml:" + this.featureName);
        var featureContainer = this.createElementNS(this.featureNS,
                                                    this.featurePrefix + ":" +
                                                    this.layerName);
        var fid = feature.fid || feature.id;
        featureContainer.setAttribute("fid", fid);
        featureContainer.appendChild(geomContainer);
        for(var attr in feature.attributes) {
            var attrText = this.createTextNode(feature.attributes[attr]); 
            var nodename = attr.substring(attr.lastIndexOf(":") + 1);
            var attrContainer = this.createElementNS(this.featureNS,
                                                     this.featurePrefix + ":" +
                                                     nodename);
            attrContainer.appendChild(attrText);
            featureContainer.appendChild(attrContainer);
        }    
        featureNode.appendChild(featureContainer);
        return featureNode;
    },
    
    /**
     * APIMethod: buildGeometryNode
     * 根据geometry生成GML格式数据。
     */
    buildGeometryNode: function(geometry) {
        if (this.externalProjection && this.internalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, 
                               this.externalProjection);
        }    
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        return builder.apply(this, [geometry]);
    },

    /**
     * Property: buildGeometry
     * Object containing methods to do the actual geometry node building
     *     based on geometry type.
     */
    buildGeometry: {
        // TBD retrieve the srs from layer
        // srsName is non-standard, so not including it until it's right.
        // gml.setAttribute("srsName",
        //                  "http://www.opengis.net/gml/srs/epsg.xml#4326");

        /**
         * Method: buildGeometry.point
         * Given an GeoGlobe point geometry, create a GML point.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Point>} A point geometry.
         *
         * Returns:
         * {DOMElement} A GML point node.
         */
        point: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Point");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Method: buildGeometry.multipoint
         * Given an GeoGlobe multipoint geometry, create a GML multipoint.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.MultiPoint>} A multipoint geometry.
         *
         * Returns:
         * {DOMElement} A GML multipoint node.
         */
        multipoint: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPoint");
            var points = geometry.components;
            var pointMember, pointGeom;
            for(var i=0; i<points.length; i++) { 
                pointMember = this.createElementNS(this.gmlns,
                                                   "gml:pointMember");
                pointGeom = this.buildGeometry.point.apply(this,
                                                               [points[i]]);
                pointMember.appendChild(pointGeom);
                gml.appendChild(pointMember);
            }
            return gml;            
        },
        
        /**
         * Method: buildGeometry.linestring
         * Given an GeoGlobe linestring geometry, create a GML linestring.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.LineString>} A linestring geometry.
         *
         * Returns:
         * {DOMElement} A GML linestring node.
         */
        linestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LineString");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Method: buildGeometry.multilinestring
         * Given an GeoGlobe multilinestring geometry, create a GML
         *     multilinestring.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.MultiLineString>} A multilinestring
         *     geometry.
         *
         * Returns:
         * {DOMElement} A GML multilinestring node.
         */
        multilinestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiLineString");
            var lines = geometry.components;
            var lineMember, lineGeom;
            for(var i=0; i<lines.length; ++i) {
                lineMember = this.createElementNS(this.gmlns,
                                                  "gml:lineStringMember");
                lineGeom = this.buildGeometry.linestring.apply(this,
                                                                   [lines[i]]);
                lineMember.appendChild(lineGeom);
                gml.appendChild(lineMember);
            }
            return gml;
        },
        
        /**
         * Method: buildGeometry.linearring
         * Given an GeoGlobe linearring geometry, create a GML linearring.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.LinearRing>} A linearring geometry.
         *
         * Returns:
         * {DOMElement} A GML linearring node.
         */
        linearring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LinearRing");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Method: buildGeometry.polygon
         * Given an GeoGlobe polygon geometry, create a GML polygon.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Polygon>} A polygon geometry.
         *
         * Returns:
         * {DOMElement} A GML polygon node.
         */
        polygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0; i<rings.length; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.gmlns,
                                                  "gml:" + type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                                   [rings[i]]);
                ringMember.appendChild(ringGeom);
                gml.appendChild(ringMember);
            }
            return gml;
        },
        
        /**
         * Method: buildGeometry.multipolygon
         * Given an GeoGlobe multipolygon geometry, create a GML multipolygon.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.MultiPolygon>} A multipolygon
         *     geometry.
         *
         * Returns:
         * {DOMElement} A GML multipolygon node.
         */
        multipolygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPolygon");
            var polys = geometry.components;
            var polyMember, polyGeom;
            for(var i=0; i<polys.length; ++i) {
                polyMember = this.createElementNS(this.gmlns,
                                                  "gml:polygonMember");
                polyGeom = this.buildGeometry.polygon.apply(this,
                                                                [polys[i]]);
                polyMember.appendChild(polyGeom);
                gml.appendChild(polyMember);
            }
            return gml;

        },
        
        /**
         * Method: buildGeometry.bounds
         * Given an GeoGlobe bounds, create a GML box.
         *
         * Parameters:
         * bounds - {<GeoGlobe.Geometry.Bounds>} A bounds object.
         *
         * Returns:
         * {DOMElement} A GML box node.
         */
        //bounds: function(bounds) {
            //var gml = this.createElementNS(this.gmlns, "gml:Box");
            //gml.appendChild(this.buildCoordinatesNode(bounds));
            //return gml;
        //},
 
        /**
         * Method: buildGeometry.bounds
         * Given an GeoGlobe bounds, create a GML box.
         *
         * Parameters:
         * bounds - {<GeoGlobe.Geometry.Bounds>} A bounds object.
         *
         * Returns:
         * {DOMElement} A GML box node.
         */
        lnglatbounds: function(bounds) {
            var gml = this.createElementNS(this.gmlns, "gml:Box");
            gml.appendChild(this.buildCoordinatesNode(bounds));
            return gml;
        }
    },

    /**
     * Method: buildCoordinates
     * builds the coordinates XmlNode
     * (code)
     * <gml:coordinates decimal="." cs="," ts=" ">...</gml:coordinates>
     * (end)
     *
     * Parameters: 
     * geometry - {<GeoGlobe.Geometry>} 
     *
     * Returns:
     * {XmlNode} created xmlNode
     */
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.gmlns,
                                                   "gml:coordinates");
        coordinatesNode.setAttribute("decimal", ".");
        coordinatesNode.setAttribute("cs", ",");
        coordinatesNode.setAttribute("ts", " ");

        var parts = [];

        if(geometry instanceof mapboxgl.LngLatBounds){//GeoGlobe
            parts.push(geometry.getWest() + "," + geometry.getSouth());
            parts.push(geometry.getEast() + "," + geometry.getNorth());
        } else {
            var points = (geometry.components) ? geometry.components : [geometry];
            for(var i=0; i<points.length; i++) {
                parts.push(points[i].x + "," + points[i].y);                
            }            
        }

        var txtNode = this.createTextNode(parts.join(" "));
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },

    CLASS_NAME: "GeoGlobe.Format.GML"
});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML.js
 * @requires GeoGlobe/Format/GML.js
 */

/**
 * Though required in the full build, if the GML format is excluded, we set
 * the namespace here.
 */
if(!GeoGlobe.Format.GML) {
    GeoGlobe.Format.GML = {};
}

/**
 * Class: GeoGlobe.Format.GML.Base
 * Superclass for GML parsers.
 * GMLv2与GMLv3的基类
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.GML.Base = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs" // this is a convenience for reading wfs:FeatureCollection
    },
    
    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "gml",

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: null,
    
    /**
     * APIProperty: featureType
     * {Array(String) or String} The local (without prefix) feature typeName(s).
     */
    featureType: null,
    
    /**
     * APIProperty: featureNS
     * {String} The feature namespace.  Must be set in the options at
     *     construction.
     */
    featureNS: null,

    /**
     * APIProperty: geometry
     * {String} Name of geometry element.  Defaults to "geometry". If null, it
     * will be set on <read> when the first geometry is parsed.
     */
    geometryName: "geometry",

    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from GML.  Default is true.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: srsName
     * {String} URI for spatial reference system.  This is optional for
     *     single part geometries and mandatory for collections and multis.
     *     If set, the srsName attribute will be written for all geometries.
     *     Default is null.
     */
    srsName: null,

    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */ 
    xy: true,

    /**
     * Property: geometryTypes
     * {Object} Maps GeoGlobe geometry class names to GML element names.
     *     Use <setGeometryTypes> before accessing this property.
     */
    geometryTypes: null,

    /**
     * Property: singleFeatureType
     * {Boolean} True if there is only 1 featureType, and not an array
     *     of featuretypes.
     */
    singleFeatureType: null,
    
    /**
     * Property: autoConfig
     * {Boolean} Indicates if the format was configured without a <featureNS>,
     * but auto-configured <featureNS> and <featureType> during read.
     * Subclasses making use of <featureType> auto-configuration should make
     * the first call to the <readNode> method (usually in the read method)
     * with true as 3rd argument, so the auto-configured featureType can be
     * reset and the format can be reused for subsequent reads with data from
     * different featureTypes. Set to false after read if you want to keep the
     * auto-configured values.
     */

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g),
        featureMember: (/^(.*:)?featureMembers?$/)
    },

    /**
     * Constructor: GeoGlobe.Format.GML.Base
     * Instances of this class are not created directly.  Use the
     *     <GeoGlobe.Format.GML.v2> or <GeoGlobe.Format.GML.v3> constructor
     *     instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     *
     * Valid options properties:
     * featureType - {Array(String) or String} Local (without prefix) feature 
     *     typeName(s) (required for write).
     * featureNS - {String} Feature namespace (required for write).
     * geometryName - {String} Geometry element name (required for write).
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.setGeometryTypes();
        if(options && options.featureNS) {
            this.setNamespace("feature", options.featureNS);
        }
        this.singleFeatureType = !options || (typeof options.featureType === "string");
    },
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} A gml:featureMember element, a gml:featureMembers
     *     element, or an element containing either of the above at any level.
     *
     * Returns:
     * {Array(<GeoGlobe.Feature>)} An array of features.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var features = [];
        this.readNode(data, {features: features}, true);
        if(features.length == 0) {
            // look for gml:featureMember elements
            var elements = this.getElementsByTagNameNS(
                data, this.namespaces.gml, "featureMember"
            );
            if(elements.length) {
                for(var i=0, len=elements.length; i<len; ++i) {
                    this.readNode(elements[i], {features: features}, true);
                }
            } else {
                // look for gml:featureMembers elements (this is v3, but does no harm here)
                var elements = this.getElementsByTagNameNS(
                    data, this.namespaces.gml, "featureMembers"
                );
                if(elements.length) {
                    // there can be only one
                    this.readNode(elements[0], {features: features}, true);
                }
            }
        }
        return features;
    },
    
    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     * first - {Boolean} Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj, first) {
        // on subsequent calls of format.read(), we want to reset auto-
        // configured properties and auto-configure again.
        if (first === true && this.autoConfig === true) {
            this.featureType = null;
            delete this.namespaceAlias[this.featureNS];
            delete this.namespaces["feature"];
            this.featureNS = null;
        }
        // featureType auto-configuration
        if (!this.featureNS && (!(node.prefix in this.namespaces) &&
                node.parentNode.namespaceURI == this.namespaces["gml"] &&
                this.regExes.featureMember.test(node.parentNode.nodeName))) {
            this.featureType = node.nodeName.split(":").pop();
            this.setNamespace("feature", node.namespaceURI);
            this.featureNS = node.namespaceURI;
            this.autoConfig = true;
        }
        return GeoGlobe.Format.XML.prototype.readNode.apply(this, [node, obj]);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "gml": {
            "_inherit": function(node, obj, container) {
                // To be implemented by version specific parsers
            },
            "featureMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);                
            },
            "name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "boundedBy": function(node, obj) {
                var container = {};
                this.readChildNodes(node, container);
                if(container.components && container.components.length > 0) {
                    obj.bounds = container.components[0];
                }
            },
            "Point": function(node, container) {
                var obj = {points: []};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(obj.points[0]);
            },
            "coordinates": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                var coords;
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    if (this.xy) {
                        points[i] = new GeoGlobe.Geometry.Point(
                            coords[0], coords[1], coords[2]
                        );
                    } else {
                        points[i] = new GeoGlobe.Geometry.Point(
                            coords[1], coords[0], coords[2]
                        );
                    }
                }
                obj.points = points;
            },
            "coord": function(node, obj) {
                var coord = {};
                this.readChildNodes(node, coord);
                if(!obj.points) {
                    obj.points = [];
                }
                obj.points.push(new GeoGlobe.Geometry.Point(
                    coord.x, coord.y, coord.z
                ));
            },
            "X": function(node, coord) {
                coord.x = this.getChildValue(node);
            },
            "Y": function(node, coord) {
                coord.y = this.getChildValue(node);
            },
            "Z": function(node, coord) {
                coord.z = this.getChildValue(node);
            },
            "MultiPoint": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiPoint(obj.components)
                ];
            },
            "pointMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineString": function(node, container) {
                var obj = {};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.LineString(obj.points)
                );
            },
            "MultiLineString": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiLineString(obj.components)
                ];
            },
            "lineStringMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Polygon": function(node, container) {
                var obj = {outer: null, inner: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                obj.inner.unshift(obj.outer);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.Polygon(obj.inner)
                );
            },
            "LinearRing": function(node, obj) {
                var container = {};
                this.readers.gml._inherit.apply(this, [node, container]);
                this.readChildNodes(node, container);
                obj.components = [new GeoGlobe.Geometry.LinearRing(
                    container.points
                )];
            },
            "MultiPolygon": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiPolygon(obj.components)
                ];
            },
            "polygonMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "GeometryCollection": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.Collection(obj.components)
                ];
            },
            "geometryMember": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        },
        "feature": {
            "*": function(node, obj) {
                // The node can either be named like the featureType, or it
                // can be a child of the feature:featureType.  Children can be
                // geometry or attributes.
                var name;
                var local = node.localName || node.nodeName.split(":").pop();
                // Since an attribute can have the same name as the feature type
                // we only want to read the node as a feature if the parent
                // node can have feature nodes as children.  In this case, the
                // obj.features property is set.
                if (obj.features) {
                    if (!this.singleFeatureType &&
                        (GeoGlobe.Util.indexOf(this.featureType, local) !== -1)) {
                        name = "_typeName";
                    } else if(local === this.featureType) {
                        name = "_typeName";
                    }else if(GeoGlobe.Util.isArray(this.featureType_)) {
						//this.featureType_属性是补丁中新增的属性，目的是让解析器能解析多个图层的数据。
						for(var i = 0; i < this.featureType_.length;i++) {
							if(this.featureType_[i] === local) {
								name = "_typeName";
								break;
							}
						}
					}
                } else {
                    // Assume attribute elements have one child node and that the child
                    // is a text node.  Otherwise assume it is a geometry node.
                    if(node.childNodes.length == 0 ||
                       (node.childNodes.length == 1 && node.firstChild.nodeType == 3)) {
                        if(this.extractAttributes) {
                            name = "_attribute";
                        }
                    } else {
                        name = "_geometry";
                    }
                }
                if(name) {
                    this.readers.feature[name].apply(this, [node, obj]);
                }
            },
            "_typeName": function(node, obj) {
                var container = {components: [], attributes: {}};
                this.readChildNodes(node, container);
                // look for common gml namespaced elements
                if(container.name) {
                    container.attributes.name = container.name;
                }
                var feature = new GeoGlobe.Feature(
                    container.components[0], container.attributes
                );
                if (!this.singleFeatureType) {
                    feature.type = node.nodeName.split(":").pop();
                    feature.namespace = node.namespaceURI;
                }
                var fid = node.getAttribute("fid") ||
                    this.getAttributeNS(node, this.namespaces["gml"], "id");
                if(fid) {
                    feature.fid = fid;
                }
                if(this.internalProjection && this.externalProjection &&
                   feature.geometry) {
                    feature.geometry.transform(
                        this.externalProjection, this.internalProjection
                    );
                }
                if(container.bounds) {
                    feature.bounds = container.bounds;
                }
                obj.features.push(feature);
            },
            "_geometry": function(node, obj) {
                if (!this.geometryName) {
                    this.geometryName = node.nodeName.split(":").pop();
                }
                this.readChildNodes(node, obj);
            },
            "_attribute": function(node, obj) {
                var local = node.localName || node.nodeName.split(":").pop();
                var value = this.getChildValue(node);
                obj.attributes[local] = value;
            }
        },
        "wfs": {
            "FeatureCollection": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**
     * Method: write
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>) | GeoGlobe.Feature}
     *     An array of features or a single feature.
     *
     * Returns:
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "gml": {
            "featureMember": function(feature) {
                var node = this.createElementNSPlus("gml:featureMember");
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "MultiPoint": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPoint");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("pointMember", components[i], node);
                }
                return node;
            },
            "pointMember": function(geometry) {
                var node = this.createElementNSPlus("gml:pointMember");
                this.writeNode("Point", geometry, node);
                return node;
            },
            "MultiLineString": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiLineString");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("lineStringMember", components[i], node);
                }
                return node;
            },
            "lineStringMember": function(geometry) {
                var node = this.createElementNSPlus("gml:lineStringMember");
                this.writeNode("LineString", geometry, node);
                return node;
            },
            "MultiPolygon": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPolygon");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode(
                        "polygonMember", components[i], node
                    );
                }
                return node;
            },
            "polygonMember": function(geometry) {
                var node = this.createElementNSPlus("gml:polygonMember");
                this.writeNode("Polygon", geometry, node);
                return node;
            },
            "GeometryCollection": function(geometry) {
                var node = this.createElementNSPlus("gml:GeometryCollection");
                for(var i=0, len=geometry.components.length; i<len; ++i) {
                    this.writeNode("geometryMember", geometry.components[i], node);
                }
                return node;
            },
            "geometryMember": function(geometry) {
                var node = this.createElementNSPlus("gml:geometryMember");
                var child = this.writeNode("feature:_geometry", geometry);
                node.appendChild(child.firstChild);
                return node;
            }
        },
        "feature": {
            "_typeName": function(feature) {
                var node = this.createElementNSPlus("feature:" + this.featureType, {
                    attributes: {fid: feature.fid}
                });
                if(feature.geometry) {
                    this.writeNode("feature:_geometry", feature.geometry, node);
                }
                for(var name in feature.attributes) {
                    var value = feature.attributes[name];
                    if(value != null) {
                        this.writeNode(
                            "feature:_attribute",
                            {name: name, value: value}, node
                        );
                    }
                }
                return node;
            },
            "_geometry": function(geometry) {
                if(this.externalProjection && this.internalProjection) {
                    geometry = geometry.clone().transform(
                        this.internalProjection, this.externalProjection
                    );
                }    
                var node = this.createElementNSPlus(
                    "feature:" + this.geometryName
                );
                var type = this.geometryTypes[geometry.CLASS_NAME];
                var child = this.writeNode("gml:" + type, geometry, node);
                if(this.srsName) {
                    child.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "_attribute": function(obj) {
                return this.createElementNSPlus("feature:" + obj.name, {
                    value: obj.value
                });
            }
        },
        "wfs": {
            "FeatureCollection": function(features) {
                /**
                 * This is only here because GML2 only describes abstract
                 * feature collections.  Typically, you would not be using
                 * the GML format to write wfs elements.  This just provides
                 * some way to write out lists of features.  GML3 defines the
                 * featureMembers element, so that is used by default instead.
                 */
                var node = this.createElementNSPlus("wfs:FeatureCollection");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("gml:featureMember", features[i], node);
                }
                return node;
            }
        }
    },
    
    /**
     * Method: setGeometryTypes
     * Sets the <geometryTypes> mapping.
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": "LineString",
            "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
            "GeoGlobe.Geometry.Polygon": "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        };
    },
	
    /**
     * Method: setFeatureType_
     * 增加featureType_属性，让gml解析器能解析多个图层的数据。
     */
	setFeatureType_: function(featureType) {
		this.featureType_ = featureType;
	},

    CLASS_NAME: "GeoGlobe.Format.GML.Base" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/GML/Base.js
 */

/**
 * Class: GeoGlobe.Format.GML.v2
 * Parses GML version 2.
 * 解析GML文件类（V2版本当服务版本不是1.1.0时使用）。
 *
 * Inherits from:
 *  - <GeoGlobe.Format.GML.Base>
 */
GeoGlobe.Format.GML.v2 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    
    
    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd",

    /**
     * Constructor: GeoGlobe.Format.GML.v2
     * Create a parser for GML v2.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (required).
     * geometryName - {String} Geometry element name.
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "outerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "innerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "Box": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                var sw = new GeoGlobe.LngLat(min.x, min.y);
     			var ne = new GeoGlobe.LngLat(max.x, max.y);
                container.components.push(
                    new GeoGlobe.LngLatBounds(sw, ne)
                );
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.readers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.readers["wfs"]
    },

    /**
     * Method: write
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>) | GeoGlobe.Feature
     *     An array of features or a single feature.
     *
     * Returns:
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            // GML2 only has abstract feature collections
            // wfs provides a feature collection from a well-known schema
            name = "wfs:FeatureCollection";
        } else {
            name = "gml:featureMember";
        }
        var root = this.writeNode(name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("coordinates", [geometry], node);
                return node;
            },
            "coordinates": function(points) {
                var numPoints = points.length;
                var parts = new Array(numPoints);
                var point;
                for(var i=0; i<numPoints; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + "," + point.y;
                    } else {
                        parts[i] = point.y + "," + point.x;
                    }
                    if(point.z != undefined) { // allow null or undefined
                        parts[i] += "," + point.z;
                    }
                }
                return this.createElementNSPlus("gml:coordinates", {
                    attributes: {
                        decimal: ".", cs: ",", ts: " "
                    },
                    value: (numPoints == 1) ? parts[0] : parts.join(" ")
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("coordinates", geometry.components, node);
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("outerBoundaryIs", geometry.components[0], node);
                for(var i=1; i<geometry.components.length; ++i) {
                    this.writeNode(
                        "innerBoundaryIs", geometry.components[i], node
                    );
                }
                return node;
            },
            "outerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:outerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "innerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:innerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("coordinates", ring.components, node);
                return node;
            },
            "Box": function(bounds) {
                var node = this.createElementNSPlus("gml:Box");
                this.writeNode("coordinates", [
                    {x: bounds._sw.lng, y: bounds._sw.lat},
                    {x: bounds._ne.lng, y: bounds._ne.lat}
                ], node);
                // srsName attribute is optional for gml:Box
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.writers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.writers["wfs"]
    },
    
    CLASS_NAME: "GeoGlobe.Format.GML.v2" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/GML/Base.js
 */

/**
 * Class: GeoGlobe.Format.GML.v3
 * Parses GML version 3.
 * 解析GML文件类（V3版本当服务版本是1.1.0时使用）。
 *
 * Inherits from:
 *  - <GeoGlobe.Format.GML.Base>
 */
GeoGlobe.Format.GML.v3 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    
    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.  The writers
     *     conform with the Simple Features Profile for GML.
     */
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",

    /**
     * Property: curve
     * {Boolean} Write gml:Curve instead of gml:LineString elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Curve elements instead of gml:LineString, set curve
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     */
    curve: false,
    
    /**
     * Property: multiCurve
     * {Boolean} Write gml:MultiCurve instead of gml:MultiLineString.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiLineString instead of gml:MultiCurve, set multiCurve to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     */
    multiCurve: true,
    
    /**
     * Property: surface
     * {Boolean} Write gml:Surface instead of gml:Polygon elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Surface elements instead of gml:Polygon, set surface
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     */
    surface: false,

    /**
     * Property: multiSurface
     * {Boolean} Write gml:multiSurface instead of gml:MultiPolygon.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiPolygon instead of gml:multiSurface, set multiSurface to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     */
    multiSurface: true,

    /**
     * Constructor: GeoGlobe.Format.GML.v3
     * Create a parser for GML v3.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (required).
     * geometryName - {String} Geometry element name.
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "_inherit": function(node, obj, container) {
                // SRSReferenceGroup attributes
                var dim = parseInt(node.getAttribute("srsDimension"), 10) ||
                    (container && container.srsDimension);
                if (dim) {
                    obj.srsDimension = dim;
                }
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Curve": function(node, container) {
                var obj = {points: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.LineString(obj.points)
                );
            },
            "segments": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineStringSegment": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(obj.points) {
                    Array.prototype.push.apply(container.points, obj.points);
                }
            },
            "pos": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                var point;
                if(this.xy) {
                    point = new GeoGlobe.Geometry.Point(
                        coords[0], coords[1], coords[2]
                    );
                } else {
                    point = new GeoGlobe.Geometry.Point(
                        coords[1], coords[0], coords[2]
                    );
                }
                obj.points = [point];
            },
            "posList": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                // The "dimension" attribute is from the GML 3.0.1 spec.
                var dim = obj.srsDimension ||
                    parseInt(node.getAttribute("srsDimension") || node.getAttribute("dimension"), 10) || 2;
                var j, x, y, z;
                var numPoints = coords.length / dim;
                var points = new Array(numPoints);
                for(var i=0, len=coords.length; i<len; i += dim) {
                    x = coords[i];
                    y = coords[i+1];
                    z = (dim == 2) ? undefined : coords[i+2];
                    if (this.xy) {
                        points[i/dim] = new GeoGlobe.Geometry.Point(x, y, z);
                    } else {
                        points[i/dim] = new GeoGlobe.Geometry.Point(y, x, z);
                    }
                }
                obj.points = points;
            },
            "Surface": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "patches": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "PolygonPatch": function(node, obj) {
                this.readers.gml.Polygon.apply(this, [node, obj]);
            },
            "exterior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "interior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "MultiCurve": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new GeoGlobe.Geometry.MultiLineString(obj.components)
                    ];
                }
            },
            "curveMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "MultiSurface": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new GeoGlobe.Geometry.MultiPolygon(obj.components)
                    ];
                }
            },
            "surfaceMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "surfaceMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "pointMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "lineStringMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "polygonMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "geometryMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Envelope": function(node, container) {
                var obj = {points: new Array(2)};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                var sw = new GeoGlobe.LngLat(min.x, min.y);
     			var ne = new GeoGlobe.LngLat(max.x, max.y);
                container.components.push(
                    new GeoGlobe.LngLatBounds(sw, ne)
                );
            },
            "lowerCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[0] = obj.points[0];
            },
            "upperCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[1] = obj.points[0];
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers["gml"]),            
        "feature": GeoGlobe.Format.GML.Base.prototype.readers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.readers["wfs"]
    },
    
    /**
     * Method: write
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>) | GeoGlobe.Feature}
     *     An array of features or a single feature.
     *
     * Returns:
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "featureMembers": function(features) {
                var node = this.createElementNSPlus("gml:featureMembers");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("feature:_typeName", features[i], node);
                }
                return node;
            },
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("pos", geometry, node);
                return node;
            },
            "pos": function(point) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (point.x + " " + point.y) : (point.y + " " + point.x);
                return this.createElementNSPlus("gml:pos", {
                    value: pos
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "Curve": function(geometry) {
                var node = this.createElementNSPlus("gml:Curve");
                this.writeNode("segments", geometry, node);
                return node;
            },
            "segments": function(geometry) {
                var node = this.createElementNSPlus("gml:segments");
                this.writeNode("LineStringSegment", geometry, node);
                return node;
            },
            "LineStringSegment": function(geometry) {
                var node = this.createElementNSPlus("gml:LineStringSegment");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "posList": function(points) {
                // only 2d for simple features profile
                var len = points.length;
                var parts = new Array(len);
                var point;
                for(var i=0; i<len; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + " " + point.y;
                    } else {
                        parts[i] = point.y + " " + point.x;
                    }
                }
                return this.createElementNSPlus("gml:posList", {
                    value: parts.join(" ")
                }); 
            },
            "Surface": function(geometry) {
                var node = this.createElementNSPlus("gml:Surface");
                this.writeNode("patches", geometry, node);
                return node;
            },
            "patches": function(geometry) {
                var node = this.createElementNSPlus("gml:patches");
                this.writeNode("PolygonPatch", geometry, node);
                return node;
            },
            "PolygonPatch": function(geometry) {
                var node = this.createElementNSPlus("gml:PolygonPatch", {
                    attributes: {interpolation: "planar"}
                });
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "exterior": function(ring) {
                var node = this.createElementNSPlus("gml:exterior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "interior": function(ring) {
                var node = this.createElementNSPlus("gml:interior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("posList", ring.components, node);
                return node;
            },
            "MultiCurve": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiCurve");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("curveMember", components[i], node);
                }
                return node;
            },
            "curveMember": function(geometry) {
                var node = this.createElementNSPlus("gml:curveMember");
                if(this.curve) {
                    this.writeNode("Curve", geometry, node);
                } else {
                    this.writeNode("LineString", geometry, node);
                }
                return node;
            },
            "MultiSurface": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiSurface");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("surfaceMember", components[i], node);
                }
                return node;
            },
            "surfaceMember": function(polygon) {
                var node = this.createElementNSPlus("gml:surfaceMember");
                if(this.surface) {
                    this.writeNode("Surface", polygon, node);
                } else {
                    this.writeNode("Polygon", polygon, node);
                }
                return node;
            },
            "Envelope": function(bounds) {
                var node = this.createElementNSPlus("gml:Envelope");
                this.writeNode("lowerCorner", bounds, node);
                this.writeNode("upperCorner", bounds, node);
                // srsName attribute is required for gml:Envelope
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "lowerCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds._sw.lng + " " + bounds._sw.lat) :
                    (bounds._sw.lat + " " + bounds._sw.lng);
                return this.createElementNSPlus("gml:lowerCorner", {
                    value: pos
                });
            },
            "upperCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds._ne.lng + " " + bounds._ne.lat) :
                    (bounds._ne.lat + " " + bounds._ne.lng);
                return this.createElementNSPlus("gml:upperCorner", {
                    value: pos
                });
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.writers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.writers["wfs"]
    },

    /**
     * Method: setGeometryTypes
     * Sets the <geometryTypes> mapping.
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": (this.curve === true) ? "Curve": "LineString",
            "GeoGlobe.Geometry.MultiLineString": (this.multiCurve === false) ? "MultiLineString" : "MultiCurve",
            "GeoGlobe.Geometry.Polygon": (this.surface === true) ? "Surface" : "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": (this.multiSurface === false) ? "MultiPolygon" : "MultiSurface",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        };
    },
    
    CLASS_NAME: "GeoGlobe.Format.GML.v3" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/BaseTypes/Date.js
 * @requires GeoGlobe/Format/XML.js
 * @requires GeoGlobe/Feature/Feature.js
 * @requires GeoGlobe/Geometry/Point.js
 * @requires GeoGlobe/Geometry/LineString.js
 * @requires GeoGlobe/Geometry/Polygon.js
 * @requires GeoGlobe/Geometry/Collection.js
 * @requires GeoGlobe/tool/Request/XMLHttpRequest.js
 * @requires GeoGlobe/tool/Projection.js
 */

/**
 * Class: GeoGlobe.Format.KML
 * Read/Write KML. Create a new instance with the <GeoGlobe.Format.KML>
 *     constructor. 
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.KML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        kml: "http://www.opengis.net/kml/2.2",
        gx: "http://www.google.com/kml/ext/2.2"
    },

    /**
     * APIProperty: kmlns
     * {String} KML Namespace to use. Defaults to 2.0 namespace.
     */
    kmlns: "http://earth.google.com/kml/2.0",
    
    /** 
     * APIProperty: placemarksDesc
     * {String} Name of the placemarks.  Default is "No description available".
     */
    placemarksDesc: "No description available",
    
    /** 
     * APIProperty: foldersName
     * {String} Name of the folders.  Default is "GeoGlobe export".
     *          If set to null, no name element will be created.
     */
    foldersName: "GeoGlobe export",
    
    /** 
     * APIProperty: foldersDesc
     * {String} Description of the folders. Default is "Exported on [date]."
     *          If set to null, no description element will be created.
     */
    foldersDesc: "Exported on " + new Date(),
    
    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from KML.  Default is true.
     *           Extracting styleUrls requires this to be set to true
     *           Note that currently only Data and SimpleData 
     *           elements are handled.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: kvpAttributes
     * {Boolean} Only used if extractAttributes is true.
     *           If set to true, attributes will be simple
     *           key-value pairs, compatible with other formats,
     *           Any displayName elements will be ignored.
     *           If set to false, attributes will be objects,
     *           retaining any displayName elements, but not
     *           compatible with other formats. Any CDATA in
     *           displayName will be read in as a string value.
     *           Default is false.
     */
    kvpAttributes: false,
    
    /**
     * Property: extractStyles
     * {Boolean} Extract styles from KML.  Default is false.
     *           Extracting styleUrls also requires extractAttributes to be
     *           set to true
     */
    extractStyles: false,
    
    /**
     * APIProperty: extractTracks
     * {Boolean} Extract gx:Track elements from Placemark elements.  Default
     *     is false.  If true, features will be generated for all points in
     *     all gx:Track elements.  Features will have a when (Date) attribute
     *     based on when elements in the track.  If tracks include angle
     *     elements, features will have heading, tilt, and roll attributes.
     *     If track point coordinates have three values, features will have
     *     an altitude attribute with the third coordinate value.
     */
    extractTracks: false,
    
    /**
     * APIProperty: trackAttributes
     * {Array} If <extractTracks> is true, points within gx:Track elements will 
     *     be parsed as features with when, heading, tilt, and roll attributes.
     *     Any additional attribute names can be provided in <trackAttributes>.
     */
    trackAttributes: null,
    
    /**
     * Property: internalns
     * {String} KML Namespace to use -- defaults to the namespace of the
     *     Placemark node being parsed, but falls back to kmlns. 
     */
    internalns: null,

    /**
     * Property: features
     * {Array} Array of features
     *     
     */
    features: null,

    /**
     * Property: styles
     * {Object} Storage of style objects
     *     
     */
    styles: null,
    
    /**
     * Property: styleBaseUrl
     * {String}
     */
    styleBaseUrl: "",

    /**
     * Property: fetched
     * {Object} Storage of KML URLs that have been fetched before
     *     in order to prevent reloading them.
     */
    fetched: null,

    /**
     * APIProperty: maxDepth
     * {Integer} Maximum depth for recursive loading external KML URLs 
     *           Defaults to 0: do no external fetching
     */
    maxDepth: 0,

    /**
     * Constructor: GeoGlobe.Format.KML
     * Create a new parser for KML.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g),
            kmlColor: (/(\w{2})(\w{2})(\w{2})(\w{2})/),
            kmlIconPalette: (/root:\/\/icons\/palette-(\d+)(\.\w+)/),
            straightBracket: (/\$\[(.*?)\]/g)
        };
        // KML coordinates are always in longlat WGS84
        this.externalProjection = new GeoGlobe.SpatialReference("EPSG:4326");

        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Read data from a string, and return a list of features. 
     * 
     * Parameters: 
     * data    - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array(<GeoGlobe.Feature>)} List of features.
     */
    read: function(data) {
        this.features = [];
        this.styles   = {};
        this.fetched  = {};

        // Set default options 
        var options = {
            depth: 0,
            styleBaseUrl: this.styleBaseUrl
        };

        return this.parseData(data, options);
    },

    /**
     * Method: parseData
     * Read data from a string, and return a list of features. 
     * 
     * Parameters: 
     * data    - {String} or {DOMElement} data to read/parse.
     * options - {Object} Hash of options
     *
     * Returns:
     * {Array(<GeoGlobe.Feature>)} List of features.
     */
    parseData: function(data, options) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }

        // Loop throught the following node types in this order and
        // process the nodes found 
        var types = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"];
        for(var i=0, len=types.length; i<len; ++i) {
            var type = types[i];

            var nodes = this.getElementsByTagNameNS(data, "*", type);

            // skip to next type if no nodes are found
            if(nodes.length == 0) { 
                continue;
            }

            switch (type.toLowerCase()) {

                // Fetch external links 
                case "link":
                case "networklink":
                    this.parseLinks(nodes, options);
                    break;

                // parse style information
                case "style":
                    if (this.extractStyles) {
                        this.parseStyles(nodes, options);
                    }
                    break;
                case "stylemap":
                    if (this.extractStyles) {
                        this.parseStyleMaps(nodes, options);
                    }
                    break;

                // parse features
                case "placemark":
                    this.parseFeatures(nodes, options);
                    break;
            }
        }
        
        return this.features;
    },

    /**
     * Method: parseLinks
     * Finds URLs of linked KML documents and fetches them
     * 
     * Parameters: 
     * nodes   - {Array} of {DOMElement} data to read/parse.
     * options - {Object} Hash of options
     * 
     */
    parseLinks: function(nodes, options) {
        
        // Fetch external links <NetworkLink> and <Link>
        // Don't do anything if we have reached our maximum depth for recursion
        if (options.depth >= this.maxDepth) {
            return false;
        }

        // increase depth
        var newOptions = GeoGlobe.Util.extend({}, options);
        newOptions.depth++;

        for(var i=0, len=nodes.length; i<len; i++) {
            var href = this.parseProperty(nodes[i], "*", "href");
            if(href && !this.fetched[href]) {
                this.fetched[href] = true; // prevent reloading the same urls
                var data = this.fetchLink(href);
                if (data) {
                    this.parseData(data, newOptions);
                }
            } 
        }

    },

    /**
     * Method: fetchLink
     * Fetches a URL and returns the result
     * 
     * Parameters: 
     * href  - {String} url to be fetched
     * 
     */
    fetchLink: function(href) {
        var request = GeoGlobe.Request.GET({url: href, async: false});
        if (request) {
            return request.responseText;
        }
    },

    /**
     * Method: parseStyles
     * Parses <Style> nodes
     * 
     * Parameters: 
     * nodes    - {Array} of {DOMElement} data to read/parse.
     * options  - {Object} Hash of options
     * 
     */
    parseStyles: function(nodes, options) {
        for(var i=0, len=nodes.length; i<len; i++) {
            var style = this.parseStyle(nodes[i]);
            if(style) {
                var styleName = (options.styleBaseUrl || "") + "#" + style.id;
                
                this.styles[styleName] = style;
            }
        }
    },

    /**
     * Method: parseKmlColor
     * Parses a kml color (in 'aabbggrr' format) and returns the corresponding 
     * color and opacity or null if the color is invalid.
     *
     * Parameters: 
     * kmlColor - {String} a kml formated color
     *
     * Returns:
     * {Object}
     */
    parseKmlColor: function(kmlColor) {
        var color = null;
        if (kmlColor) {
            var matches = kmlColor.match(this.regExes.kmlColor);
            if (matches) {
                color = {
                    color: '#' + matches[4] + matches[3] + matches[2],
                    opacity: parseInt(matches[1], 16) / 255
                };
            }
        }
        return color;
    },

    /**
     * Method: parseStyle
     * Parses the children of a <Style> node and builds the style hash
     * accordingly
     * 
     * Parameters: 
     * node - {DOMElement} <Style> node
     * 
     */
    parseStyle: function(node) {
        var style = {};
        
        var types = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", 
                     "LabelStyle"];
        var type, styleTypeNode, nodeList, geometry, parser;
        for(var i=0, len=types.length; i<len; ++i) {
            type = types[i];
            styleTypeNode = this.getElementsByTagNameNS(node, "*", type)[0];
            if(!styleTypeNode) { 
                continue;
            }

            // only deal with first geometry of this type
            switch (type.toLowerCase()) {
                case "linestyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["strokeColor"] = color.color;
                        style["strokeOpacity"] = color.opacity;
                    }
                    
                    var width = this.parseProperty(styleTypeNode, "*", "width");
                    if (width) {
                        style["strokeWidth"] = width;
                    }
                    break;

                case "polystyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fillOpacity"] = color.opacity;
                        style["fillColor"] = color.color;
                    }
                    // Check if fill is disabled
                    var fill = this.parseProperty(styleTypeNode, "*", "fill");
                    if (fill == "0") {
                        style["fillColor"] = "none";
                    }
                    // Check if outline is disabled
                    var outline = this.parseProperty(styleTypeNode, "*", "outline");
                    if (outline == "0") {
                        style["strokeWidth"] = "0";
                    }
                   
                    break;

                case "iconstyle":
                    // set scale
                    var scale = parseFloat(this.parseProperty(styleTypeNode, 
                                                          "*", "scale") || 1);
  
                    // set default width and height of icon
                    var width = 32 * scale;
                    var height = 32 * scale;

                    var iconNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "Icon")[0];
                    if (iconNode) {
                        var href = this.parseProperty(iconNode, "*", "href");
                        if (href) {                                                   

                            var w = this.parseProperty(iconNode, "*", "w");
                            var h = this.parseProperty(iconNode, "*", "h");

                            // Settings for Google specific icons that are 64x64
                            // We set the width and height to 64 and halve the
                            // scale to prevent icons from being too big
                            var google = "http://maps.google.com/mapfiles/kml";
                            if (GeoGlobe.String.startsWith(
                                                 href, google) && !w && !h) {
                                w = 64;
                                h = 64;
                                scale = scale / 2;
                            }
                                
                            // if only dimension is defined, make sure the
                            // other one has the same value
                            w = w || h;
                            h = h || w;

                            if (w) {
                                width = parseInt(w) * scale;
                            }

                            if (h) {
                                height = parseInt(h) * scale;
                            }

                            // support for internal icons 
                            //    (/root://icons/palette-x.png)
                            // x and y tell the position on the palette:
                            // - in pixels
                            // - starting from the left bottom
                            // We translate that to a position in the list 
                            // and request the appropriate icon from the 
                            // google maps website
                            var matches = href.match(this.regExes.kmlIconPalette);
                            if (matches)  {
                                var palette = matches[1];
                                var file_extension = matches[2];

                                var x = this.parseProperty(iconNode, "*", "x");
                                var y = this.parseProperty(iconNode, "*", "y");

                                var posX = x ? x/32 : 0;
                                var posY = y ? (7 - y/32) : 7;

                                var pos = posY * 8 + posX;
                                href = "http://maps.google.com/mapfiles/kml/pal" 
                                     + palette + "/icon" + pos + file_extension;
                            }

                            style["graphicOpacity"] = 1; // fully opaque
                            style["externalGraphic"] = href;
                        }

                    }


                    // hotSpots define the offset for an Icon
                    var hotSpotNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "hotSpot")[0];
                    if (hotSpotNode) {
                        var x = parseFloat(hotSpotNode.getAttribute("x"));
                        var y = parseFloat(hotSpotNode.getAttribute("y"));

                        var xUnits = hotSpotNode.getAttribute("xunits");
                        if (xUnits == "pixels") {
                            style["graphicXOffset"] = -x * scale;
                        }
                        else if (xUnits == "insetPixels") {
                            style["graphicXOffset"] = -width + (x * scale);
                        }
                        else if (xUnits == "fraction") {
                            style["graphicXOffset"] = -width * x;
                        }

                        var yUnits = hotSpotNode.getAttribute("yunits");
                        if (yUnits == "pixels") {
                            style["graphicYOffset"] = -height + (y * scale) + 1;
                        }
                        else if (yUnits == "insetPixels") {
                            style["graphicYOffset"] = -(y * scale) + 1;
                        }
                        else if (yUnits == "fraction") {
                            style["graphicYOffset"] =  -height * (1 - y) + 1;
                        }
                    }

                    style["graphicWidth"] = width;
                    style["graphicHeight"] = height;
                    break;

                case "balloonstyle":
                    var balloonStyle = GeoGlobe.Util.getXmlNodeValue(
                                            styleTypeNode);
                    if (balloonStyle) {
                        style["balloonStyle"] = balloonStyle.replace(
                                       this.regExes.straightBracket, "${$1}");
                    }
                    break;
                case "labelstyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fontColor"] = color.color;
                        style["fontOpacity"] = color.opacity;
                    }
                    break;

                default:
            }
        }

        // Some polygons have no line color, so we use the fillColor for that
        if (!style["strokeColor"] && style["fillColor"]) {
            style["strokeColor"] = style["fillColor"];
        }

        var id = node.getAttribute("id");
        if (id && style) {
            style.id = id;
        }

        return style;
    },

    /**
     * Method: parseStyleMaps
     * Parses <StyleMap> nodes, but only uses the 'normal' key
     * 
     * Parameters: 
     * nodes    - {Array} of {DOMElement} data to read/parse.
     * options  - {Object} Hash of options
     * 
     */
    parseStyleMaps: function(nodes, options) {
        // Only the default or "normal" part of the StyleMap is processed now
        // To do the select or "highlight" bit, we'd need to change lots more

        for(var i=0, len=nodes.length; i<len; i++) {
            var node = nodes[i];
            var pairs = this.getElementsByTagNameNS(node, "*", 
                            "Pair");

            var id = node.getAttribute("id");
            for (var j=0, jlen=pairs.length; j<jlen; j++) {
                var pair = pairs[j];
                // Use the shortcut in the SLD format to quickly retrieve the 
                // value of a node. Maybe it's good to have a method in 
                // Format.XML to do this
                var key = this.parseProperty(pair, "*", "key");
                var styleUrl = this.parseProperty(pair, "*", "styleUrl");

                if (styleUrl && key == "normal") {
                    this.styles[(options.styleBaseUrl || "") + "#" + id] =
                        this.styles[(options.styleBaseUrl || "") + styleUrl];
                }

                // TODO: implement the "select" part
                //if (styleUrl && key == "highlight") {
                //}

            }
        }

    },


    /**
     * Method: parseFeatures
     * Loop through all Placemark nodes and parse them.
     * Will create a list of features
     * 
     * Parameters: 
     * nodes    - {Array} of {DOMElement} data to read/parse.
     * options  - {Object} Hash of options
     * 
     */
    parseFeatures: function(nodes, options) {
        var features = [];
        for(var i=0, len=nodes.length; i<len; i++) {
            var featureNode = nodes[i];
            var feature = this.parseFeature.apply(this,[featureNode]) ;
            if(feature) {

                // Create reference to styleUrl 
                if (this.extractStyles && feature.attributes &&
                    feature.attributes.styleUrl) {
                    feature.style = this.getStyle(feature.attributes.styleUrl, options);
                }

                if (this.extractStyles) {
                    // Make sure that <Style> nodes within a placemark are 
                    // processed as well
                    var inlineStyleNode = this.getElementsByTagNameNS(featureNode,
                                                        "*",
                                                        "Style")[0];
                    if (inlineStyleNode) {
                        var inlineStyle= this.parseStyle(inlineStyleNode);
                        if (inlineStyle) {
                            feature.style = GeoGlobe.Util.extend(
                                feature.style, inlineStyle
                            );
                        }
                    }
                }

                // check if gx:Track elements should be parsed
                if (this.extractTracks) {
                    var tracks = this.getElementsByTagNameNS(
                        featureNode, this.namespaces.gx, "Track"
                    );
                    if (tracks && tracks.length > 0) {
                        var track = tracks[0];
                        var container = {
                            features: [],
                            feature: feature
                        };
                        this.readNode(track, container);
                        if (container.features.length > 0) {
                            features.push.apply(features, container.features);
                        }
                    }
                } else {
                    // add feature to list of features
                    features.push(feature);                    
                }
            } else {
                throw "Bad Placemark: " + i;
            }
        }

        // add new features to existing feature list
        this.features = this.features.concat(features);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "kml": {
            "when": function(node, container) {
                container.whens.push(GeoGlobe.Date.parse(
                    this.getChildValue(node)
                ));
            },
            "_trackPointAttribute": function(node, container) {
                var name = node.nodeName.split(":").pop();
                container.attributes[name].push(this.getChildValue(node));
            }
        },
        "gx": {
            "Track": function(node, container) {
                var obj = {
                    whens: [],
                    points: [],
                    angles: []
                };
                if (this.trackAttributes) {
                    var name;
                    obj.attributes = {};
                    for (var i=0, ii=this.trackAttributes.length; i<ii; ++i) {
                        name = this.trackAttributes[i];
                        obj.attributes[name] = [];
                        if (!(name in this.readers.kml)) {
                            this.readers.kml[name] = this.readers.kml._trackPointAttribute;
                        }
                    }
                }
                this.readChildNodes(node, obj);
                if (obj.whens.length !== obj.points.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:coord (" +
                                    obj.points.length + ") elements.");
                }
                var hasAngles = obj.angles.length > 0;
                if (hasAngles && obj.whens.length !== obj.angles.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:angles (" +
                                    obj.angles.length + ") elements.");
                }
                var feature, point, angles;
                for (var i=0, ii=obj.whens.length; i<ii; ++i) {
                    feature = container.feature.clone();
                    feature.fid = container.feature.fid || container.feature.id;
                    point = obj.points[i];
                    feature.geometry = point;
                    if ("z" in point) {
                        feature.attributes.altitude = point.z;
                    }
                    if (this.internalProjection && this.externalProjection) {
                        feature.geometry.transform(
                            this.externalProjection, this.internalProjection
                        ); 
                    }
                    if (this.trackAttributes) {
                        for (var j=0, jj=this.trackAttributes.length; j<jj; ++j) {
                            var name = this.trackAttributes[j];
                            feature.attributes[name] = obj.attributes[name][i];
                        }
                    }
                    feature.attributes.when = obj.whens[i];
                    feature.attributes.trackId = container.feature.id;
                    if (hasAngles) {
                        angles = obj.angles[i];
                        feature.attributes.heading = parseFloat(angles[0]);
                        feature.attributes.tilt = parseFloat(angles[1]);
                        feature.attributes.roll = parseFloat(angles[2]);
                    }
                    container.features.push(feature);
                }
            },
            "coord": function(node, container) {
                var str = this.getChildValue(node);
                var coords = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                var point = new GeoGlobe.Geometry.Point(coords[0], coords[1]);
                if (coords.length > 2) {
                    point.z = parseFloat(coords[2]);
                }
                container.points.push(point);
            },
            "angles": function(node, container) {
                var str = this.getChildValue(node);
                var parts = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                container.angles.push(parts);
            }
        }
    },
    
    /**
     * Method: parseFeature
     * This function is the core of the KML parsing code in GeoGlobe.
     *     It creates the geometries that are then attached to the returned
     *     feature, and calls parseAttributes() to get attribute data out.
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {<GeoGlobe.Feature>} A vector feature.
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiGeometry", "Polygon", "LineString", "Point"];
        var type, nodeList, geometry, parser;
        for(var i=0, len=order.length; i<len; ++i) {
            type = order[i];
            this.internalns = node.namespaceURI ? 
                    node.namespaceURI : this.kmlns;
            nodeList = this.getElementsByTagNameNS(node, 
                                                   this.internalns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                var parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new GeoGlobe.Feature(geometry, attributes);

        var fid = node.getAttribute("id") || node.getAttribute("name");
        if(fid != null) {
            feature.fid = fid;
        }

        return feature;
    },        
    
    /**
     * Method: getStyle
     * Retrieves a style from a style hash using styleUrl as the key
     * If the styleUrl doesn't exist yet, we try to fetch it 
     * Internet
     * 
     * Parameters: 
     * styleUrl  - {String} URL of style
     * options   - {Object} Hash of options 
     *
     * Returns:
     * {Object}  - (reference to) Style hash
     */
    getStyle: function(styleUrl, options) {

        var styleBaseUrl = GeoGlobe.Util.removeTail(styleUrl);

        var newOptions = GeoGlobe.Util.extend({}, options);
        newOptions.depth++;
        newOptions.styleBaseUrl = styleBaseUrl;

        // Fetch remote Style URLs (if not fetched before) 
        if (!this.styles[styleUrl] 
                && !GeoGlobe.String.startsWith(styleUrl, "#") 
                && newOptions.depth <= this.maxDepth
                && !this.fetched[styleBaseUrl] ) {

            var data = this.fetchLink(styleBaseUrl);
            if (data) {
                this.parseData(data, newOptions);
            }

        }

        // return requested style
        var style = GeoGlobe.Util.extend({}, this.styles[styleUrl]);
        return style;
    },
    
    /**
     * Property: parseGeometry
     * Properties of this object are the functions that parse geometries based
     *     on their type.
     */
    parseGeometry: {
        
        /**
         * Method: parseGeometry.point
         * Given a KML node representing a point geometry, create an GeoGlobe
         *     point geometry.
         *
         * Parameters:
         * node - {DOMElement} A KML Point node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.Point>} A point geometry.
         */
        point: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var coords = [];
            if(nodeList.length > 0) {
                var coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.removeSpace, "");
                coords = coordString.split(",");
            }

            var point = null;
            if(coords.length > 1) {
                // preserve third dimension
                if(coords.length == 2) {
                    coords[2] = null;
                }
                point = new GeoGlobe.Geometry.Point(coords[0], coords[1],
                                                      coords[2]);
            } else {
                throw "Bad coordinate string: " + coordString;
            }
            return point;
        },
        
        /**
         * Method: parseGeometry.linestring
         * Given a KML node representing a linestring geometry, create an
         *     GeoGlobe linestring geometry.
         *
         * Parameters:
         * node - {DOMElement} A KML LineString node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.LineString>} A linestring geometry.
         */
        linestring: function(node, ring) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var line = null;
            if(nodeList.length > 0) {
                var coordString = this.getChildValue(nodeList[0]);

                coordString = coordString.replace(this.regExes.trimSpace,
                                                  "");
                coordString = coordString.replace(this.regExes.trimComma,
                                                  ",");
                var pointList = coordString.split(this.regExes.splitSpace);
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                var coords, numCoords;
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    numCoords = coords.length;
                    if(numCoords > 1) {
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        points[i] = new GeoGlobe.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]);
                    } else {
                        throw "Bad LineString point coordinates: " +
                              pointList[i];
                    }
                }
                if(numPoints) {
                    if(ring) {
                        line = new GeoGlobe.Geometry.LinearRing(points);
                    } else {
                        line = new GeoGlobe.Geometry.LineString(points);
                    }
                } else {
                    throw "Bad LineString coordinates: " + coordString;
                }
            }

            return line;
        },
        
        /**
         * Method: parseGeometry.polygon
         * Given a KML node representing a polygon geometry, create an
         *     GeoGlobe polygon geometry.
         *
         * Parameters:
         * node - {DOMElement} A KML Polygon node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.Polygon>} A polygon geometry.
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "LinearRing");
            var numRings = nodeList.length;
            var components = new Array(numRings);
            if(numRings > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0, len=nodeList.length; i<len; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components[i] = ring;
                    } else {
                        throw "Bad LinearRing geometry: " + i;
                    }
                }
            }
            return new GeoGlobe.Geometry.Polygon(components);
        },
        
        /**
         * Method: parseGeometry.multigeometry
         * Given a KML node representing a multigeometry, create an
         *     GeoGlobe geometry collection.
         *
         * Parameters:
         * node - {DOMElement} A KML MultiGeometry node.
         *
         * Returns:
         * {<GeoGlobe.Geometry.Collection>} A geometry collection.
         */
        multigeometry: function(node) {
            var child, parser;
            var parts = [];
            var children = node.childNodes;
            for(var i=0, len=children.length; i<len; ++i ) {
                child = children[i];
                if(child.nodeType == 1) {
                    var type = (child.prefix) ?
                            child.nodeName.split(":")[1] :
                            child.nodeName;
                    var parser = this.parseGeometry[type.toLowerCase()];
                    if(parser) {
                        parts.push(parser.apply(this, [child]));
                    }
                }
            }
            return new GeoGlobe.Geometry.Collection(parts);
        }
        
    },

    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {Object} An attributes object.
     */
    parseAttributes: function(node) {
        var attributes = {};
       
        // Extended Data is parsed first.
        var edNodes = node.getElementsByTagName("ExtendedData");
        if (edNodes.length) {
            attributes = this.parseExtendedData(edNodes[0]);
        }
        
        // assume attribute nodes are type 1 children with a type 3 or 4 child
        var child, grandchildren, grandchild;
        var children = node.childNodes;

        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                grandchildren = child.childNodes;
                if(grandchildren.length >= 1 && grandchildren.length <= 3) {
                    var grandchild;
                    switch (grandchildren.length) {
                        case 1:
                            grandchild = grandchildren[0];
                            break;
                        case 2:
                            var c1 = grandchildren[0];
                            var c2 = grandchildren[1];
                            grandchild = (c1.nodeType == 3 || c1.nodeType == 4) ?
                                c1 : c2;
                            break;
                        case 3:
                        default:
                            grandchild = grandchildren[1];
                            break;
                    }
                    if(grandchild.nodeType == 3 || grandchild.nodeType == 4) {
                        var name = (child.prefix) ?
                                child.nodeName.split(":")[1] :
                                child.nodeName;
                        var value = GeoGlobe.Util.getXmlNodeValue(grandchild);
                        if (value) {
                            value = value.replace(this.regExes.trimSpace, "");
                            attributes[name] = value;
                        }
                    }
                } 
            }
        }
        return attributes;
    },

    /**
     * Method: parseExtendedData
     * Parse ExtendedData from KML. Limited support for schemas/datatypes.
     *     See http://code.google.com/apis/kml/documentation/kmlreference.html#extendeddata
     *     for more information on extendeddata.
     */
    parseExtendedData: function(node) {
        var attributes = {};
        var i, len, data, key;
        var dataNodes = node.getElementsByTagName("Data");
        for (i = 0, len = dataNodes.length; i < len; i++) {
            data = dataNodes[i];
            key = data.getAttribute("name");
            var ed = {};
            var valueNode = data.getElementsByTagName("value");
            if (valueNode.length) {
                ed['value'] = this.getChildValue(valueNode[0]);
            }
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                var nameNode = data.getElementsByTagName("displayName");
                if (nameNode.length) {
                    ed['displayName'] = this.getChildValue(nameNode[0]);
                }
                attributes[key] = ed;
            } 
        }
        var simpleDataNodes = node.getElementsByTagName("SimpleData");
        for (i = 0, len = simpleDataNodes.length; i < len; i++) {
            var ed = {};
            data = simpleDataNodes[i];
            key = data.getAttribute("name");
            ed['value'] = this.getChildValue(data);
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                ed['displayName'] = key;
                attributes[key] = ed;
            }
        }
        
        return attributes;    
    },
    
    /**
     * Method: parseProperty
     * Convenience method to find a node and return its value
     *
     * Parameters:
     * xmlNode    - {<DOMElement>}
     * namespace  - {String} namespace of the node to find
     * tagName    - {String} name of the property to parse
     * 
     * Returns:
     * {String} The value for the requested property (defaults to null)
     */    
    parseProperty: function(xmlNode, namespace, tagName) {
        var value;
        var nodeList = this.getElementsByTagNameNS(xmlNode, namespace, tagName);
        try {
            value = GeoGlobe.Util.getXmlNodeValue(nodeList[0]);
        } catch(e) {
            value = null;
        }
     
        return value;
    },                                                              

    /**
     * APIMethod: write
     * Accept Feature Collection, and return a string. 
     * 
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>)} An array of features.
     *
     * Returns:
     * {String} A KML string.
     */
    write: function(features) {
        if(!(GeoGlobe.Util.isArray(features))) {
            features = [features];
        }
        var kml = this.createElementNS(this.kmlns, "kml");
        var folder = this.createFolderXML();
        for(var i=0, len=features.length; i<len; ++i) {
            folder.appendChild(this.createPlacemarkXML(features[i]));
        }
        kml.appendChild(folder);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [kml]);
    },

    /**
     * Method: createFolderXML
     * Creates and returns a KML folder node
     * 
     * Returns:
     * {DOMElement}
     */
    createFolderXML: function() {
        // Folder
        var folder = this.createElementNS(this.kmlns, "Folder");

        // Folder name
        if (this.foldersName) {
            var folderName = this.createElementNS(this.kmlns, "name");
            var folderNameText = this.createTextNode(this.foldersName); 
            folderName.appendChild(folderNameText);
            folder.appendChild(folderName);
        }

        // Folder description
        if (this.foldersDesc) {
            var folderDesc = this.createElementNS(this.kmlns, "description");        
            var folderDescText = this.createTextNode(this.foldersDesc); 
            folderDesc.appendChild(folderDescText);
            folder.appendChild(folderDesc);
        }

        return folder;
    },

    /**
     * Method: createPlacemarkXML
     * Creates and returns a KML placemark node representing the given feature. 
     * 
     * Parameters:
     * feature - {<GeoGlobe.Feature>}
     * 
     * Returns:
     * {DOMElement}
     */
    createPlacemarkXML: function(feature) {        
        // Placemark name
        var placemarkName = this.createElementNS(this.kmlns, "name");
        var label = (feature.style && feature.style.label) ? feature.style.label : feature.id;
        var name = feature.attributes.name || label;
        placemarkName.appendChild(this.createTextNode(name));

        // Placemark description
        var placemarkDesc = this.createElementNS(this.kmlns, "description");
        var desc = feature.attributes.description || this.placemarksDesc;
        placemarkDesc.appendChild(this.createTextNode(desc));
        
        // Placemark
        var placemarkNode = this.createElementNS(this.kmlns, "Placemark");
        if(feature.fid != null) {
            placemarkNode.setAttribute("id", feature.fid);
        }
        placemarkNode.appendChild(placemarkName);
        placemarkNode.appendChild(placemarkDesc);

        // Geometry node (Point, LineString, etc. nodes)
        var geometryNode = this.buildGeometryNode(feature.geometry);
        placemarkNode.appendChild(geometryNode);        
        
        // output attributes as extendedData
        if (feature.attributes) {
            var edNode = this.buildExtendedData(feature.attributes);
            if (edNode) {
                placemarkNode.appendChild(edNode);
            }
        }
        
        return placemarkNode;
    },    

    /**
     * Method: buildGeometryNode
     * Builds and returns a KML geometry node with the given geometry.
     * 
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */
    buildGeometryNode: function(geometry) {
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        var node = null;
        if(builder) {
            node = builder.apply(this, [geometry]);
        }
        return node;
    },

    /**
     * Property: buildGeometry
     * Object containing methods to do the actual geometry node building
     *     based on geometry type.
     */
    buildGeometry: {
        // TBD: Anybody care about namespace aliases here (these nodes have
        //    no prefixes)?

        /**
         * Method: buildGeometry.point
         * Given an GeoGlobe point geometry, create a KML point.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Point>} A point geometry.
         *
         * Returns:
         * {DOMElement} A KML point node.
         */
        point: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Point");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Method: buildGeometry.multipoint
         * Given an GeoGlobe multipoint geometry, create a KML
         *     GeometryCollection.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Point>} A multipoint geometry.
         *
         * Returns:
         * {DOMElement} A KML GeometryCollection node.
         */
        multipoint: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Method: buildGeometry.linestring
         * Given an GeoGlobe linestring geometry, create a KML linestring.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.LineString>} A linestring geometry.
         *
         * Returns:
         * {DOMElement} A KML linestring node.
         */
        linestring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LineString");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Method: buildGeometry.multilinestring
         * Given an GeoGlobe multilinestring geometry, create a KML
         *     GeometryCollection.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Point>} A multilinestring geometry.
         *
         * Returns:
         * {DOMElement} A KML GeometryCollection node.
         */
        multilinestring: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Method: buildGeometry.linearring
         * Given an GeoGlobe linearring geometry, create a KML linearring.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.LinearRing>} A linearring geometry.
         *
         * Returns:
         * {DOMElement} A KML linearring node.
         */
        linearring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LinearRing");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Method: buildGeometry.polygon
         * Given an GeoGlobe polygon geometry, create a KML polygon.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Polygon>} A polygon geometry.
         *
         * Returns:
         * {DOMElement} A KML polygon node.
         */
        polygon: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0, len=rings.length; i<len; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.kmlns, type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                               [rings[i]]);
                ringMember.appendChild(ringGeom);
                kml.appendChild(ringMember);
            }
            return kml;
        },
        
        /**
         * Method: buildGeometry.multipolygon
         * Given an GeoGlobe multipolygon geometry, create a KML
         *     GeometryCollection.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Point>} A multipolygon geometry.
         *
         * Returns:
         * {DOMElement} A KML GeometryCollection node.
         */
        multipolygon: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Method: buildGeometry.collection
         * Given an GeoGlobe geometry collection, create a KML MultiGeometry.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry.Collection>} A geometry collection.
         *
         * Returns:
         * {DOMElement} A KML MultiGeometry node.
         */
        collection: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "MultiGeometry");
            var child;
            for(var i=0, len=geometry.components.length; i<len; ++i) {
                child = this.buildGeometryNode.apply(this,
                                                     [geometry.components[i]]);
                if(child) {
                    kml.appendChild(child);
                }
            }
            return kml;
        }
    },

    /**
     * Method: buildCoordinatesNode
     * Builds and returns the KML coordinates node with the given geometry
     * <coordinates>...</coordinates>
     * 
     * Parameters:
     * geometry - {<GeoGlobe.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */     
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.kmlns, "coordinates");
        
        var path;
        var points = geometry.components;
        if(points) {
            // LineString or LinearRing
            var point;
            var numPoints = points.length;
            var parts = new Array(numPoints);
            for(var i=0; i<numPoints; ++i) {
                point = points[i];
                parts[i] = this.buildCoordinates(point);
            }
            path = parts.join(" ");
        } else {
            // Point
            path = this.buildCoordinates(geometry);
        }
        
        var txtNode = this.createTextNode(path);
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },    
    
    /**
     * Method: buildCoordinates
     *
     * Parameters:
     * point - {<GeoGlobe.Geometry.Point>}
     *
     * Returns
     * {String} a coordinate pair
     */
    buildCoordinates: function(point) {
        if (this.internalProjection && this.externalProjection) {
            point = point.clone();
            point.transform(this.internalProjection, 
                               this.externalProjection);
        }
        return point.x + "," + point.y;                     
    },

    /**
     * Method: buildExtendedData
     *
     * Parameters:
     * attributes - {Object}
     *
     * Returns
     * {DOMElement} A KML ExtendedData node or {null} if no attributes.
     */
    buildExtendedData: function(attributes) {
        var extendedData = this.createElementNS(this.kmlns, "ExtendedData");
        for (var attributeName in attributes) {
            // empty, name, description, styleUrl attributes ignored
            if (attributes[attributeName] && attributeName != "name" && attributeName != "description" && attributeName != "styleUrl") {
                var data = this.createElementNS(this.kmlns, "Data");
                data.setAttribute("name", attributeName);
                var value = this.createElementNS(this.kmlns, "value");
                if (typeof attributes[attributeName] == "object") {
                    // cater for object attributes with 'value' properties
                    // other object properties will output an empty node
                    if (attributes[attributeName].value) {
                        value.appendChild(this.createTextNode(attributes[attributeName].value));
                    }
                    if (attributes[attributeName].displayName) {
                        var displayName = this.createElementNS(this.kmlns, "displayName");
                        // displayName always written as CDATA
                        displayName.appendChild(this.getXMLDoc().createCDATASection(attributes[attributeName].displayName));
                        data.appendChild(displayName);
                    }
                } else {
                    value.appendChild(this.createTextNode(attributes[attributeName]));
                }
                data.appendChild(value);
                extendedData.appendChild(data);
            }
        }
        if (this.isSimpleContent(extendedData)) {
            return null;
        } else {
            return extendedData;
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.KML" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/XML/VersionedOGC.js
 */

/**
 * Class: GeoGlobe.Format.OWSCommon
 * Read OWSCommon. Create a new instance with the <GeoGlobe.Format.OWSCommon>
 *     constructor.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML.VersionedOGC>
 */
GeoGlobe.Format.OWSCommon = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * Constructor: OpenLayers.Format.OWSCommon
     * Create a new parser for OWSCommon.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Method: getVersion
     * Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     *
     * Parameters:
     * root - {DOMElement}
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} The version to use.
     */
    getVersion: function(root, options) {
        var version = this.version;
        if(!version) {
            // remember version does not correspond to the OWS version
            // it corresponds to the WMS/WFS/WCS etc. request version
            var uri = root.getAttribute("xmlns:ows");
            // the above will fail if the namespace prefix is different than
            // ows and if the namespace is declared on a different element
            if (uri && uri.substring(uri.lastIndexOf("/")+1) === "1.1") {
                version ="1.1.0";
            } 
            if(!version) {
                version = this.defaultVersion;
            }
        }
        return version;
    },

    /**
     * APIMethod: read
     * Read an OWSCommon document and return an object.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the structure of the document.
     */

    CLASS_NAME: "GeoGlobe.Format.OWSCommon" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/OWSCommon.js
 */

/**
 * Class: GeoGlobe.Format.OWSCommon.v1
 * Common readers and writers for OWSCommon v1.X formats
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.OWSCommon.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
   
    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} An OWSCommon document element.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the OWSCommon document.
     */
    read: function(data, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        var ows = {};
        this.readChildNodes(data, ows);
        return ows;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ows": {
            "Exception": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute('exceptionCode'),
                    locator: node.getAttribute('locator'),
                    texts: []
                };
                exceptionReport.exceptions.push(exception);
                this.readChildNodes(node, exception);
            },
            "ExceptionText": function(node, exception) {
                var text = this.getChildValue(node);
                exception.texts.push(text);
            },
            "ServiceIdentification": function(node, obj) {
                obj.serviceIdentification = {};
                this.readChildNodes(node, obj.serviceIdentification);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, serviceIdentification) {
                serviceIdentification["abstract"] = this.getChildValue(node);
            },
            "Keywords": function(node, serviceIdentification) {
                serviceIdentification.keywords = {};
                this.readChildNodes(node, serviceIdentification.keywords);
            },
            "Keyword": function(node, keywords) {
                keywords[this.getChildValue(node)] = true;
            },
            "ServiceType": function(node, serviceIdentification) {
                serviceIdentification.serviceType = {
                    codeSpace: node.getAttribute('codeSpace'), 
                    value: this.getChildValue(node)};
            },
            "ServiceTypeVersion": function(node, serviceIdentification) {
                serviceIdentification.serviceTypeVersion = this.getChildValue(node);
            },
            "Fees": function(node, serviceIdentification) {
                serviceIdentification.fees = this.getChildValue(node);
            },
            "AccessConstraints": function(node, serviceIdentification) {
                serviceIdentification.accessConstraints = 
                    this.getChildValue(node);
            },
            "ServiceProvider": function(node, obj) {
                obj.serviceProvider = {};
                this.readChildNodes(node, obj.serviceProvider);
            },
            "ProviderName": function(node, serviceProvider) {
                serviceProvider.providerName = this.getChildValue(node);
            },
            "ProviderSite": function(node, serviceProvider) {
                serviceProvider.providerSite = this.getAttributeNS(node, 
                    this.namespaces.xlink, "href");
            },
            "ServiceContact": function(node, serviceProvider) {
                serviceProvider.serviceContact = {};
                this.readChildNodes(node, serviceProvider.serviceContact);
            },
            "IndividualName": function(node, serviceContact) {
                serviceContact.individualName = this.getChildValue(node);
            },
            "PositionName": function(node, serviceContact) {
                serviceContact.positionName = this.getChildValue(node);
            },
            "ContactInfo": function(node, serviceContact) {
                serviceContact.contactInfo = {};
                this.readChildNodes(node, serviceContact.contactInfo);
            },
            "Phone": function(node, contactInfo) {
                contactInfo.phone = {};
                this.readChildNodes(node, contactInfo.phone);
            },
            "Voice": function(node, phone) {
                phone.voice = this.getChildValue(node);
            },
            "Address": function(node, contactInfo) {
                contactInfo.address = {};
                this.readChildNodes(node, contactInfo.address);
            },
            "DeliveryPoint": function(node, address) {
                address.deliveryPoint = this.getChildValue(node);
            },
            "City": function(node, address) {
                address.city = this.getChildValue(node);
            },
            "AdministrativeArea": function(node, address) {
                address.administrativeArea = this.getChildValue(node);
            },
            "PostalCode": function(node, address) {
                address.postalCode = this.getChildValue(node);
            },
            "Country": function(node, address) {
                address.country = this.getChildValue(node);
            },
            "ElectronicMailAddress": function(node, address) {
                address.electronicMailAddress = this.getChildValue(node);
            },
            "Role": function(node, serviceContact) {
                serviceContact.role = this.getChildValue(node);
            },
            "OperationsMetadata": function(node, obj) {
                obj.operationsMetadata = {};
                this.readChildNodes(node, obj.operationsMetadata);
            },
            "Operation": function(node, operationsMetadata) {
                var name = node.getAttribute("name");
                operationsMetadata[name] = {};
                this.readChildNodes(node, operationsMetadata[name]);
            },
            "DCP": function(node, operation) {
                operation.dcp = {};
                this.readChildNodes(node, operation.dcp);
            },
            "HTTP": function(node, dcp) {
                dcp.http = {};
                this.readChildNodes(node, dcp.http);
            },
            "Get": function(node, http) {
                if (!http.get) {
                    http.get = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.get.push(obj);
            },
            "Post": function(node, http) {
                if (!http.post) {
                    http.post = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.post.push(obj);
            },
            "Parameter": function(node, operation) {
                if (!operation.parameters) {
                    operation.parameters = {};
                }
                var name = node.getAttribute("name");
                operation.parameters[name] = {};
                this.readChildNodes(node, operation.parameters[name]);
            },
            "Constraint": function(node, obj) {
                if (!obj.constraints) {
                    obj.constraints = {};
                }
                var name = node.getAttribute("name");
                obj.constraints[name] = {};
                this.readChildNodes(node, obj.constraints[name]);
            },
            "Value": function(node, allowedValues) {
                allowedValues[this.getChildValue(node)] = true;
            },
            "OutputFormat": function(node, obj) {
                obj.formats.push({value: this.getChildValue(node)});
                this.readChildNodes(node, obj);
            },
            "WGS84BoundingBox": function(node, obj) {
                var boundingBox = {};
                boundingBox.crs = node.getAttribute("crs");
				if(!obj.BoundingBox){
                	obj.BoundingBox = [];
                }
                if (obj.BoundingBox) {
                    obj.BoundingBox.push(boundingBox);
                } else {
                    obj.projection = boundingBox.crs;
                    boundingBox = obj;
               }
               this.readChildNodes(node, boundingBox);
            },
            "BoundingBox": function(node, obj) {
                // FIXME: We consider that BoundingBox is the same as WGS84BoundingBox
                // LowerCorner = "min_x min_y"
                // UpperCorner = "max_x max_y"
                // It should normally depend on the projection
                this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
            },
            "LowerCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.right = pointList[0];
                obj.top = pointList[1];
                //obj.bounds = new GeoGlobe.Bounds(obj.left, obj.bottom,obj.right, obj.top);
                obj.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(obj.left, obj.bottom),new GeoGlobe.LngLat(obj.right, obj.top));
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
            "Language": function(node, obj) {
                obj.language = this.getChildValue(node);
            }
        }
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ows": {
            "BoundingBox": function(options, nodeName) {
                var node = this.createElementNSPlus(nodeName || "ows:BoundingBox", {
                    attributes: {
                        crs: options.projection
                    }
                });
                this.writeNode("ows:LowerCorner", options, node);
                this.writeNode("ows:UpperCorner", options, node);
                return node;
            },
            "LowerCorner": function(options) {
                var node = this.createElementNSPlus("ows:LowerCorner", {
                    //value: options.bounds.left + " " + options.bounds.bottom });
                    value: options.bounds._sw.lng + " " + options.bounds._sw.lat });
                return node;
            },
            "UpperCorner": function(options) {
                var node = this.createElementNSPlus("ows:UpperCorner", {
                    //value: options.bounds.right + " " + options.bounds.top });
                    value: options.bounds._ne.lng + " " + options.bounds._ne.lat });
                return node;
            },
            "Identifier": function(identifier) {
                var node = this.createElementNSPlus("ows:Identifier", {
                    value: identifier });
                return node;
            },
            "Title": function(title) {
                var node = this.createElementNSPlus("ows:Title", {
                    value: title });
                return node;
            },
            "Abstract": function(abstractValue) {
                var node = this.createElementNSPlus("ows:Abstract", {
                    value: abstractValue });
                return node;
            },
            "OutputFormat": function(format) {
                var node = this.createElementNSPlus("ows:OutputFormat", {
                    value: format });
                return node;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1"

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/OWSCommon/v1.js
 */

/**
 * Class: GeoGlobe.Format.OWSCommon.v1_0_0
 * Parser for OWS Common version 1.0.0.
 *
 * Inherits from:
 *  - <GeoGlobe.Format.OWSCommon.v1>
 */
GeoGlobe.Format.OWSCommon.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.success = false;
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('language'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            } 
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows)
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ows": GeoGlobe.Format.OWSCommon.v1.prototype.writers.ows
    },
    
    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_0_0"

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/OWSCommon/v1.js
 */

/**
 * Class: GeoGlobe.Format.OWSCommon.v1_1_0
 * Parser for OWS Common version 1.1.0.
 *
 * Inherits from:
 *  - <GeoGlobe.Format.OWSCommon.v1>
 */
GeoGlobe.Format.OWSCommon.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('xml:lang'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            },
            "AllowedValues": function(node, parameter) {
                parameter.allowedValues = {};
                this.readChildNodes(node, parameter.allowedValues);
            },
            "AnyValue": function(node, parameter) {
                parameter.anyValue = true;
            },
            "DataType": function(node, parameter) {
                parameter.dataType = this.getChildValue(node);
            },
            "Range": function(node, allowedValues) {
                allowedValues.range = {};
                this.readChildNodes(node, allowedValues.range);
            },
            "MinimumValue": function(node, range) {
                range.minValue = this.getChildValue(node);
            },
            "MaximumValue": function(node, range) {
                range.maxValue = this.getChildValue(node);
            },
            "Identifier": function(node, obj) {
                obj.identifier = this.getChildValue(node);
            },
            "SupportedCRS": function(node, obj) {
                obj.supportedCRS = this.getChildValue(node);
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers["ows"])
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "Range": function(range) {
                var node = this.createElementNSPlus("ows:Range", {
                    attributes: {
                        'ows:rangeClosure': range.closure
                    }
                });
                this.writeNode("ows:MinimumValue", range.minValue, node);
                this.writeNode("ows:MaximumValue", range.maxValue, node);
                return node;
            },
            "MinimumValue": function(minValue) {
                var node = this.createElementNSPlus("ows:MinimumValue", {
                    value: minValue
                });
                return node;
            },
            "MaximumValue": function(maxValue) {
                var node = this.createElementNSPlus("ows:MaximumValue", {
                    value: maxValue
                });
                return node;
            },
            "Value": function(value) {
                var node = this.createElementNSPlus("ows:Value", {
                    value: value
                });
                return node;
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.writers["ows"])
    },

    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_1_0"

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/XML/VersionedOGC.js
 */

/**
 * Class: GeoGlobe.Format.WFSCapabilities
 * Read WFS Capabilities.
 * WFS服务GetCapabilities操作格式化解析类。将XML格式的WFS能力描述信息解析成JavaScript对象。
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML.VersionedOGC>
 */
GeoGlobe.Format.WFSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.0".
     */
    defaultVersion: "1.1.0",

    /**
     * Constructor: GeoGlobe.Format.WFSCapabilities
     * Create a new parser for WFS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/WFSCapabilities.js
 */

/**
 * Class: GeoGlobe.Format.WFSCapabilities.v1
 * Abstract class not to be instantiated directly.
 * 抽象类，不能直接实例化，应实例化其子类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.WFSCapabilities.v1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        wfs: "http://www.opengis.net/wfs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows"
    },


    /**
     * APIProperty: errorProperty
     * {String} Which property of the returned object to check for in order to
     * determine whether or not parsing has failed. In the case that the
     * errorProperty is undefined on the returned object, the document will be
     * run through an OGCExceptionReport parser.
     */
    errorProperty: "featureTypeList",

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wfs",
    
    /**
     * Constructor: GeoGlobe.Format.WFSCapabilities.v1_1
     * Create an instance of one of the subclasses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": {
            "WFS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "FeatureTypeList": function(node, request) {
                request.featureTypeList = {
                    featureTypes: []
                };
                this.readChildNodes(node, request.featureTypeList);
            },
            "FeatureType": function(node, featureTypeList) {
                var featureType = {};
                this.readChildNodes(node, featureType);
                featureTypeList.featureTypes.push(featureType);
            },
            "Name": function(node, obj) {
                var name = this.getChildValue(node);
                if(name) {
                    var parts = name.split(":");
                    obj.name = parts.pop();
                    if(parts.length > 0) {
                        obj.featureNS = this.lookupNamespaceURI(node, parts[0]);
                    }
                }
            },
            "Title": function(node, obj) {
                var title = this.getChildValue(node);
                if(title) {
                    obj.title = title;
                }
            },
            "Abstract": function(node, obj) {
                var abst = this.getChildValue(node);
                if(abst) {
                    obj["abstract"] = abst;
                }
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/WFSCapabilities/v1.js
 */

/**
 * Class: GeoGlobe.Format.WFSCapabilities/v1_0_0
 * Read WFS Capabilities version 1.0.0.
 * WFS服务 1.0.0版本的GetCapabilities操作格式化类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WFSCapabilities.v1>
 */
GeoGlobe.Format.WFSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WFSCapabilities.v1, {
    
    /**
     * Constructor: GeoGlobe.Format.WFSCapabilities.v1_0_0
     * Create a new parser for WFS capabilities version 1.0.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "Service": function(node, capabilities) {
                capabilities.service = {};
                this.readChildNodes(node, capabilities.service);
            },
            "Fees": function(node, service) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    service.fees = fees;
                }
            },
            "AccessConstraints": function(node, service) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    service.accessConstraints = constraints;
                }
            },
            "OnlineResource": function(node, service) {
                var onlineResource = this.getChildValue(node);
                if (onlineResource && onlineResource.toLowerCase() != "none") {
                    service.onlineResource = onlineResource;
                }
            },
            "Keywords": function(node, service) {
                var keywords = this.getChildValue(node);
                if (keywords && keywords.toLowerCase() != "none") {
                    service.keywords = keywords.split(', ');
                }
            },
            "Capability": function(node, capabilities) {
                capabilities.capability = {};
                this.readChildNodes(node, capabilities.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetFeature": function(node, request) {
                request.getfeature = {
                    href: {}, // DCPType
                    formats: [] // ResultFormat
                };
                this.readChildNodes(node, request.getfeature);
            },
            "ResultFormat": function(node, obj) {
                var children = node.childNodes;
                var childNode;
                for(var i=0; i<children.length; i++) {
                    childNode = children[i];
                    if(childNode.nodeType == 1) {
                        obj.formats.push(childNode.nodeName);
                    }
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj.href);
            },
            "Get": function(node, obj) {
                obj.get = node.getAttribute("onlineResource");
            },
            "Post": function(node, obj) {
                obj.post = node.getAttribute("onlineResource");
            },
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                if (srs) {
                    obj.srs = srs;
                }
            },
			"LatLongBoundingBox": function(node, obj) {
				var minx = node.getAttribute("minx");
				var miny = node.getAttribute("miny");
				var maxx = node.getAttribute("maxx");
				var maxy = node.getAttribute("maxy");
				obj.bbox = minx + "," + miny + "," + maxx + "," + maxy;
	        },
			"TemporalFeatureLayer": function(node, featureTypeList){//新增多时态WFS查询参数
			    featureTypeList.temporalFeatureLayers = [];
			    var temporalFeatureLayer = {};
			    this.readChildNodes(node, temporalFeatureLayer);
			    featureTypeList.temporalFeatureLayers.push(temporalFeatureLayer);
			},
			"Extent": function(node, obj){//TODO，需要验证，该节点是否废弃
			    //obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			},
			"Dimension": function(node, obj) {//添加wfs:Dimension方法解析时间版本
				//obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			}
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers["wfs"])
    },
    
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_0_0" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/WFSCapabilities/v1.js
 * @requires View2D/Format/OWSCommon/v1.js
 */

/**
 * Class: GeoGlobe.Format.WFSCapabilities/v1_1_0
 * Read WFS Capabilities version 1.1.0.
 * WFS服务 1.1.0版本的GetCapabilities操作格式化类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WFSCapabilities>
 */
GeoGlobe.Format.WFSCapabilities.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WFSCapabilities.v1, {

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Constructor: GeoGlobe.Format.WFSCapabilities.v1_1_0
     * Create a new parser for WFS capabilities version 1.1.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "DefaultSRS": function(node, obj) {
                var defaultSRS = this.getChildValue(node);
                if (defaultSRS) {
                    obj.srs = defaultSRS;
                }
            },
			"WGS84BoundingBox": function(node, obj) {
				var lowerCorner = node.getElementsByTagName("ows:LowerCorner");
				var lowerCornerValue = this.getChildValue(lowerCorner[0]);
				var lowerCornerArray = lowerCornerValue.split(" ");
				
				var upperCorner = node.getElementsByTagName("ows:UpperCorner");
				var upperCornerValue = this.getChildValue(upperCorner[0]);
				var upperCornerArray = upperCornerValue.split(" ");
				obj.bbox = lowerCornerArray[0] + "," + lowerCornerArray[1] + "," + upperCornerArray[0] + "," + upperCornerArray[1];
			},
			"TemporalFeatureLayer": function(node, featureTypeList){//新增多时态WFS查询参数
			    featureTypeList.temporalFeatureLayers = [];
			    var temporalFeatureLayer = {};
			    this.readChildNodes(node, temporalFeatureLayer);
			    featureTypeList.temporalFeatureLayers.push(temporalFeatureLayer);
			},
			"Extent": function(node, obj){//TODO，需要验证，该节点是否废弃
			    //obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			},
			"Dimension": function(node, obj) {//添加wfs:Dimension方法解析时间版本
				//obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			}
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers["wfs"]),
        "ows": GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows
    },

    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_1_0" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML.js
 * @requires GeoGlobe/Format/OGCExceptionReport.js
 */
 
/**
 * Class: GeoGlobe.Format.WFSDescribeFeatureType
 * Read WFS DescribeFeatureType response
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.WFSDescribeFeatureType = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g)
    },
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        xsd: "http://www.w3.org/2001/XMLSchema"
    },
    
    /**
     * Constructor: GeoGlobe.Format.WFSDescribeFeatureType
     * Create a new parser for WFS DescribeFeatureType responses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "xsd": {
            "schema": function(node, obj) {
                var complexTypes = [];
                var customTypes = {};
                var schema = {
                    complexTypes: complexTypes,
                    customTypes: customTypes
                };
                var i, len;
                
                this.readChildNodes(node, schema);

                var attributes = node.attributes;
                var attr, name;
                for(i=0, len=attributes.length; i<len; ++i) {
                    attr = attributes[i];
                    name = attr.name;
                    if(name.indexOf("xmlns") === 0) {
                        this.setNamespace(name.split(":")[1] || "", attr.value);
                    } else {
                        obj[name] = attr.value;
                    }
                }
                obj.featureTypes = complexTypes;                
                obj.targetPrefix = this.namespaceAlias[obj.targetNamespace];
                
                // map complexTypes to names of customTypes
                var complexType, customType;
                for(i=0, len=complexTypes.length; i<len; ++i) {
                    complexType = complexTypes[i];
                    customType = customTypes[complexType.typeName];
                    if(customTypes[complexType.typeName]) {
                        complexType.typeName = customType.name;
                    }
                }
            },
            "complexType": function(node, obj) {
                var complexType = {
                    // this is a temporary typeName, it will be overwritten by
                    // the schema reader with the metadata found in the
                    // customTypes hash
                    "typeName": node.getAttribute("name")
                };
                this.readChildNodes(node, complexType);
                obj.complexTypes.push(complexType);
            },
            "complexContent": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "extension": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "sequence": function(node, obj) {
                var sequence = {
                    elements: []
                };
                this.readChildNodes(node, sequence);
                obj.properties = sequence.elements;
            },
            "element": function(node, obj) {
                var type;
                if(obj.elements) {
                    var element = {};
                    var attributes = node.attributes;
                    var attr;
                    for(var i=0, len=attributes.length; i<len; ++i) {
                        attr = attributes[i];
                        element[attr.name] = attr.value;
                    }
                    
					type = element.type || element.ref;
                    if(!type) {
                        type = {};
                        this.readChildNodes(node, type);
                        element.restriction = type;
                        element.type = type.base;
                    }
                    var fullType = type.base || type;
                    element.localType = fullType.split(":").pop();
                    obj.elements.push(element);
                    this.readChildNodes(node, element);
                }
                
                if(obj.complexTypes) {
                    type = node.getAttribute("type");
                    var localType = type.split(":").pop();
                    obj.customTypes[localType] = {
                        "name": node.getAttribute("name"),
                        "type": type
                    };
                }
            },
            "annotation": function(node, obj) {
                obj.annotation = {};
                this.readChildNodes(node, obj.annotation);
            },
            "appinfo": function(node, obj) {
                if (!obj.appinfo) {
                    obj.appinfo = [];
                }
                obj.appinfo.push(this.getChildValue(node));
            },
            "documentation": function(node, obj) {
                if (!obj.documentation) {
                    obj.documentation = [];
                }
                var value = this.getChildValue(node);
                obj.documentation.push({
                    lang: node.getAttribute("xml:lang"),
                    textContent: value.replace(this.regExes.trimSpace, "")
                });
            },
            "simpleType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "restriction": function(node, obj) {
                obj.base = node.getAttribute("base");
                this.readRestriction(node, obj);
            }
        }
    },
    
    /**
     * Method: readRestriction
     * Reads restriction defined in the child nodes of a restriction element
     * 
     * Parameters:
     * node - {DOMElement} the node to parse
     * obj - {Object} the object that receives the read result
     */
    readRestriction: function(node, obj) {
        var children = node.childNodes;
        var child, nodeName, value;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                nodeName = child.nodeName.split(":").pop();
                value = child.getAttribute("value");
                if(!obj[nodeName]) {
                    obj[nodeName] = value;
                } else {
                    if(typeof obj[nodeName] == "string") {
                        obj[nodeName] = [obj[nodeName]];
                    }
                    obj[nodeName].push(value);
                }
            }
        }
    },
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement|String} A WFS DescribeFeatureType document.
     *
     * Returns:
     * {Object} An object representing the WFS DescribeFeatureType response.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var schema = {};
        if (data.nodeName.split(":").pop() === 'ExceptionReport') {
            // an exception must have occurred, so parse it
            var parser = new GeoGlobe.Format.OGCExceptionReport();
            schema.error = parser.read(data);
        } else {
            this.readNode(data, schema);
        }
        return schema;
    },
    
    CLASS_NAME: "GeoGlobe.Format.WFSDescribeFeatureType"

});
/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format.js
 * @requires GeoGlobe/Feature.js
 * @requires GeoGlobe/Geometry/Point.js
 * @requires GeoGlobe/Geometry/MultiPoint.js
 * @requires GeoGlobe/Geometry/LineString.js
 * @requires GeoGlobe/Geometry/MultiLineString.js
 * @requires GeoGlobe/Geometry/Polygon.js
 * @requires GeoGlobe/Geometry/MultiPolygon.js
 */

/**
 * Class: GeoGlobe.Format.WKT
 * Class for reading and writing Well-Known Text.  Create a new instance
 * with the <GeoGlobe.Format.WKT> constructor.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format>
 */
GeoGlobe.Format.WKT = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     * Constructor: GeoGlobe.Format.WKT
     * Create a new parser for WKT
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *           this instance
     *
     * Returns:
     * {<GeoGlobe.Format.WKT>} A new WKT parser.
     */
    initialize: function(options) {
        this.regExes = {
            'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            'spaces': /\s+/,
            'parenComma': /\)\s*,\s*\(/,
            'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/,  // can't use {2} here
            'trimParens': /^\s*\(?(.*?)\)?\s*$/
        };
        GeoGlobe.Format.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Deserialize a WKT string and return a vector feature or an
     * array of vector features.  Supports WKT for POINT, MULTIPOINT,
     * LINESTRING, MULTILINESTRING, POLYGON, MULTIPOLYGON, and
     * GEOMETRYCOLLECTION.
     *
     * Parameters:
     * wkt - {String} A WKT string
     *
     * Returns:
     * {<GeoGlobe.Feature>|Array} A feature or array of features for
     * GEOMETRYCOLLECTION WKT.
     */
    read: function(wkt) {
        var features, type, str;
        wkt = wkt.replace(/[\n\r]/g, " ");
        var matches = this.regExes.typeStr.exec(wkt);
        if(matches) {
            type = matches[1].toLowerCase();
            str = matches[2];
            if(this.parse[type]) {
                features = this.parse[type].apply(this, [str]);
            }
            if (this.internalProjection && this.externalProjection) {
                if (features && 
                    features.CLASS_NAME == "GeoGlobe.Feature") {
                    features.geometry.transform(this.externalProjection,
                                                this.internalProjection);
                } else if (features &&
                           type != "geometrycollection" &&
                           typeof features == "object") {
                    for (var i=0, len=features.length; i<len; i++) {
                        var component = features[i];
                        component.geometry.transform(this.externalProjection,
                                                     this.internalProjection);
                    }
                }
            }
        }    
        return features;
    },

    /**
     * APIMethod: write
     * Serialize a feature or array of features into a WKT string.
     *
     * Parameters:
     * features - {<GeoGlobe.Feature>|Array} A feature or array of
     *            features
     *
     * Returns:
     * {String} The WKT string representation of the input geometries
     */
    write: function(features) {
        var collection, geometry, isCollection;
        if (features.constructor == Array) {
            collection = features;
            isCollection = true;
        } else {
            collection = [features];
            isCollection = false;
        }
        var pieces = [];
        if (isCollection) {
            pieces.push('GEOMETRYCOLLECTION(');
        }
        for (var i=0, len=collection.length; i<len; ++i) {
            if (isCollection && i>0) {
                pieces.push(',');
            }
            geometry = collection[i].geometry;
            pieces.push(this.extractGeometry(geometry));
        }
        if (isCollection) {
            pieces.push(')');
        }
        return pieces.join('');
    },

    /**
     * Method: extractGeometry
     * Entry point to construct the WKT for a single Geometry object.
     *
     * Parameters:
     * geometry - {<GeoGlobe.Geometry.Geometry>}
     *
     * Returns:
     * {String} A WKT string of representing the geometry
     */
    extractGeometry: function(geometry) {
        var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
        if (!this.extract[type]) {
            return null;
        }
        if (this.internalProjection && this.externalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, this.externalProjection);
        }                       
        var wktType = type == 'collection' ? 'GEOMETRYCOLLECTION' : type.toUpperCase();
        var data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
        return data;
    },
    
    /**
     * Object with properties corresponding to the geometry types.
     * Property values are functions that do the actual data extraction.
     */
    extract: {
        /**
         * Return a space delimited string of point coordinates.
         * @param {GeoGlobe.Geometry.Point} point
         * @returns {String} A string of coordinates representing the point
         */
        'point': function(point) {
            return point.x + ' ' + point.y;
        },

        /**
         * Return a comma delimited string of point coordinates from a multipoint.
         * @param {GeoGlobe.Geometry.MultiPoint} multipoint
         * @returns {String} A string of point coordinate strings representing
         *                  the multipoint
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.point.apply(this, [multipoint.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         * Return a comma delimited string of point coordinates from a line.
         * @param {GeoGlobe.Geometry.LineString} linestring
         * @returns {String} A string of point coordinate strings representing
         *                  the linestring
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array.join(',');
        },

        /**
         * Return a comma delimited string of linestring strings from a multilinestring.
         * @param {GeoGlobe.Geometry.MultiLineString} multilinestring
         * @returns {String} A string of of linestring strings representing
         *                  the multilinestring
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [multilinestring.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         * Return a comma delimited string of linear ring arrays from a polygon.
         * @param {GeoGlobe.Geometry.Polygon} polygon
         * @returns {String} An array of linear ring arrays representing the polygon
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [polygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return an array of polygon arrays from a multipolygon.
         * @param {GeoGlobe.Geometry.MultiPolygon} multipolygon
         * @returns {String} An array of polygon arrays representing
         *                  the multipolygon
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.polygon.apply(this, [multipolygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an <GeoGlobe.Geometry.Collection>
         * @param {GeoGlobe.Geometry.Collection} collection
         * @returns {String} internal WKT representation of the collection
         */
        'collection': function(collection) {
            var array = [];
            for(var i=0, len=collection.components.length; i<len; ++i) {
                array.push(this.extractGeometry.apply(this, [collection.components[i]]));
            }
            return array.join(',');
        }

    },

    /**
     * Object with properties corresponding to the geometry types.
     * Property values are functions that do the actual parsing.
     */
    parse: {
        /**
         * Return point feature given a point WKT fragment.
         * @param {String} str A WKT fragment representing the point
         * @returns {GeoGlobe.Feature} A point feature
         * @private
         */
        'point': function(str) {
            var coords = GeoGlobe.String.trim(str).split(this.regExes.spaces);
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.Point(coords[0], coords[1])
            );
        },

        /**
         * Return a multipoint feature given a multipoint WKT fragment.
         * @param {String} str A WKT fragment representing the multipoint
         * @returns {GeoGlobe.Feature} A multipoint feature
         * @private
         */
        'multipoint': function(str) {
            var point;
            var points = GeoGlobe.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                point = points[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.point.apply(this, [point]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiPoint(components)
            );
        },
        
        /**
         * Return a linestring feature given a linestring WKT fragment.
         * @param {String} str A WKT fragment representing the linestring
         * @returns {GeoGlobe.Feature} A linestring feature
         * @private
         */
        'linestring': function(str) {
            var points = GeoGlobe.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                components.push(this.parse.point.apply(this, [points[i]]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.LineString(components)
            );
        },

        /**
         * Return a multilinestring feature given a multilinestring WKT fragment.
         * @param {String} str A WKT fragment representing the multilinestring
         * @returns {GeoGlobe.Feature} A multilinestring feature
         * @private
         */
        'multilinestring': function(str) {
            var line;
            var lines = GeoGlobe.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=lines.length; i<len; ++i) {
                line = lines[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.linestring.apply(this, [line]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiLineString(components)
            );
        },
        
        /**
         * Return a polygon feature given a polygon WKT fragment.
         * @param {String} str A WKT fragment representing the polygon
         * @returns {GeoGlobe.Feature} A polygon feature
         * @private
         */
        'polygon': function(str) {
            var ring, linestring, linearring;
            var rings = GeoGlobe.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=rings.length; i<len; ++i) {
                ring = rings[i].replace(this.regExes.trimParens, '$1');
                linestring = this.parse.linestring.apply(this, [ring]).geometry;
                linearring = new GeoGlobe.Geometry.LinearRing(linestring.components);
                components.push(linearring);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.Polygon(components)
            );
        },

        /**
         * Return a multipolygon feature given a multipolygon WKT fragment.
         * @param {String} str A WKT fragment representing the multipolygon
         * @returns {GeoGlobe.Feature.Vector} A multipolygon feature
         * @private
         */
        'multipolygon': function(str) {
            var polygon;
            var polygons = GeoGlobe.String.trim(str).split(this.regExes.doubleParenComma);
            var components = [];
            for(var i=0, len=polygons.length; i<len; ++i) {
                polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.polygon.apply(this, [polygon]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiPolygon(components)
            );
        },

        /**
         * Return an array of features given a geometrycollection WKT fragment.
         * @param {String} str A WKT fragment representing the geometrycollection
         * @returns {Array} An array of GeoGlobe.Feature.
         * @private
         */
        'geometrycollection': function(str) {
            // separate components of the collection with |
            str = str.replace(/,\s*([A-Za-z])/g, '|$1');
            var wktArray = GeoGlobe.String.trim(str).split('|');
            var components = [];
            for(var i=0, len=wktArray.length; i<len; ++i) {
                components.push(GeoGlobe.Format.WKT.prototype.read.apply(this,[wktArray[i]]));
            }
            return components;
        }

    },

    CLASS_NAME: "GeoGlobe.Format.WKT" 
});     
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/WKT.js
 * @requires View2D/Filter/Comparison.js
 * @requires View2D/Filter/Logical.js
 * @requires View2D/Filter/Spatial.js
 */

/**
 * Class: GeoGlobe.Format.CQL
 * Read CQL strings to get <GeoGlobe.Filter> objects.  Write 
 *     <GeoGlobe.Filter> objects to get CQL strings. Create a new parser with 
 *     the <GeoGlobe.Format.CQL> constructor.
 *
 * Inherits from:
 *  - <GeoGlobe.Format>
 */
GeoGlobe.Format.CQL = (function() {
    
    var tokens = [
        "PROPERTY", "COMPARISON", "VALUE", "LOGICAL"
    ],

    patterns = {
        PROPERTY: /^[_a-zA-Z]\w*/,
        COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
        IS_NULL: /^IS NULL/i,
        COMMA: /^,/,
        LOGICAL: /^(AND|OR)/i,
        VALUE: /^('([^']|'')*'|\d+(\.\d*)?|\.\d+)/,
        LPAREN: /^\(/,
        RPAREN: /^\)/,
        SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
        NOT: /^NOT/i,
        BETWEEN: /^BETWEEN/i,
        GEOMETRY: function(text) {
            var type = /^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)/.exec(text);
            if (type) {
                var len = text.length;
                var idx = text.indexOf("(", type[0].length);
                if (idx > -1) {
                    var depth = 1;
                    while (idx < len && depth > 0) {
                        idx++;
                        switch(text.charAt(idx)) {
                            case '(':
                                depth++;
                                break;
                            case ')':
                                depth--;
                                break;
                            default:
                                // in default case, do nothing
                        }
                    }
                }
                return [text.substr(0, idx+1)];
            }
        },
        END: /^$/
    },

    follows = {
        LPAREN: ['GEOMETRY', 'SPATIAL', 'PROPERTY', 'VALUE', 'LPAREN'],
        RPAREN: ['NOT', 'LOGICAL', 'END', 'RPAREN'],
        PROPERTY: ['COMPARISON', 'BETWEEN', 'COMMA', 'IS_NULL'],
        BETWEEN: ['VALUE'],
        IS_NULL: ['END'],
        COMPARISON: ['VALUE'],
        COMMA: ['GEOMETRY', 'VALUE', 'PROPERTY'],
        VALUE: ['LOGICAL', 'COMMA', 'RPAREN', 'END'],
        SPATIAL: ['LPAREN'],
        LOGICAL: ['NOT', 'VALUE', 'SPATIAL', 'PROPERTY', 'LPAREN'],
        NOT: ['PROPERTY', 'LPAREN'],
        GEOMETRY: ['COMMA', 'RPAREN']
    },

    operators = {
        '=': GeoGlobe.Filter.Comparison.EQUAL_TO,
        '<>': GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
        '<': GeoGlobe.Filter.Comparison.LESS_THAN,
        '<=': GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
        '>': GeoGlobe.Filter.Comparison.GREATER_THAN,
        '>=': GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
        'LIKE': GeoGlobe.Filter.Comparison.LIKE,
        'BETWEEN': GeoGlobe.Filter.Comparison.BETWEEN,
        'IS NULL': GeoGlobe.Filter.Comparison.IS_NULL
    },

    operatorReverse = {},

    logicals = {
        'AND': GeoGlobe.Filter.Logical.AND,
        'OR': GeoGlobe.Filter.Logical.OR
    },

    logicalReverse = {},

    precedence = {
        'RPAREN': 3,
        'LOGICAL': 2,
        'COMPARISON': 1
    };

    var i;
    for (i in operators) {
        if (operators.hasOwnProperty(i)) {
            operatorReverse[operators[i]] = i;
        }
    }

    for (i in logicals) {
        if (logicals.hasOwnProperty(i)) {
            logicalReverse[logicals[i]] = i;
        }
    }

    function tryToken(text, pattern) {
        if (pattern instanceof RegExp) {
            return pattern.exec(text);
        } else {
            return pattern(text);
        }
    }

    function nextToken(text, tokens) {
        var i, token, len = tokens.length;
        for (i=0; i<len; i++) {
            token = tokens[i];
            var pat = patterns[token];
            var matches = tryToken(text, pat);
            if (matches) {
                var match = matches[0];
                var remainder = text.substr(match.length).replace(/^\s*/, "");
                return {
                    type: token,
                    text: match,
                    remainder: remainder
                };
            }
        }

        var msg = "ERROR: In parsing: [" + text + "], expected one of: ";
        for (i=0; i<len; i++) {
            token = tokens[i];
            msg += "\n    " + token + ": " + patterns[token];
        }

        throw new Error(msg);
    }

    function tokenize(text) {
        var results = [];
        var token, expect = ["NOT", "GEOMETRY", "SPATIAL", "PROPERTY", "LPAREN"];

        do {
            token = nextToken(text, expect);
            text = token.remainder;
            expect = follows[token.type];
            if (token.type != "END" && !expect) {
                throw new Error("No follows list for " + token.type);
            }
            results.push(token);
        } while (token.type != "END");

        return results;
    }

    function buildAst(tokens) {
        var operatorStack = [],
            postfix = [];

        while (tokens.length) {
            var tok = tokens.shift();
            switch (tok.type) {
                case "PROPERTY":
                case "GEOMETRY":
                case "VALUE":
                    postfix.push(tok);
                    break;
                case "COMPARISON":
                case "BETWEEN":
                case "IS_NULL":
                case "LOGICAL":
                    var p = precedence[tok.type];

                    while (operatorStack.length > 0 &&
                        (precedence[operatorStack[operatorStack.length - 1].type] <= p)
                    ) {
                        postfix.push(operatorStack.pop());
                    }

                    operatorStack.push(tok);
                    break;
                case "SPATIAL":
                case "NOT":
                case "LPAREN":
                    operatorStack.push(tok);
                    break;
                case "RPAREN":
                    while (operatorStack.length > 0 &&
                        (operatorStack[operatorStack.length - 1].type != "LPAREN")
                    ) {
                        postfix.push(operatorStack.pop());
                    }
                    operatorStack.pop(); // toss out the LPAREN

                    if (operatorStack.length > 0 &&
                        operatorStack[operatorStack.length-1].type == "SPATIAL") {
                        postfix.push(operatorStack.pop());
                    }
                case "COMMA":
                case "END":
                    break;
                default:
                    throw new Error("Unknown token type " + tok.type);
            }
        }

        while (operatorStack.length > 0) {
            postfix.push(operatorStack.pop());
        }

        function buildTree() {
            var tok = postfix.pop();
            switch (tok.type) {
                case "LOGICAL":
                    var rhs = buildTree(),
                        lhs = buildTree();
                    return new GeoGlobe.Filter.Logical({
                        filters: [lhs, rhs],
                        type: logicals[tok.text.toUpperCase()]
                    });
                case "NOT":
                    var operand = buildTree();
                    return new GeoGlobe.Filter.Logical({
                        filters: [operand],
                        type: GeoGlobe.Filter.Logical.NOT
                    });
                case "BETWEEN":
                    var min, max, property;
                    postfix.pop(); // unneeded AND token here
                    max = buildTree();
                    min = buildTree();
                    property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        lowerBoundary: min,
                        upperBoundary: max,
                        type: GeoGlobe.Filter.Comparison.BETWEEN
                    });
                case "COMPARISON":
                    var value = buildTree(),
                        property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        value: value,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "IS_NULL":
                    var property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "VALUE":
                    var match = tok.text.match(/^'(.*)'$/);
                    if (match) {
                        return match[1].replace(/''/g, "'");
                    } else {
                        return Number(tok.text);
                    }
                case "SPATIAL":
                    switch(tok.text.toUpperCase()) {
                        case "BBOX":
                            var maxy = buildTree(),
                                maxx = buildTree(),
                                miny = buildTree(),
                                minx = buildTree(),
                                prop = buildTree();

                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.BBOX,
                                property: prop,
                                value: GeoGlobe.LngLatBounds.fromArray(
                                    [minx, miny, maxx, maxy]
                                )
                            });
                        case "INTERSECTS":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.INTERSECTS,
                                property: property,
                                value: value
                            });
                        case "WITHIN":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.WITHIN,
                                property: property,
                                value: value
                            });
                        case "CONTAINS":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.CONTAINS,
                                property: property,
                                value: value
                            });
                        case "DWITHIN":
                            var distance = buildTree(),
                                value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.DWITHIN,
                                value: value,
                                property: property,
                                distance: Number(distance)
                            });
                    }
                case "GEOMETRY":
                    return GeoGlobe.Geometry.fromWKT(tok.text);
                default:
                    return tok.text;
            }
        }

        var result = buildTree();
        if (postfix.length > 0) {
            var msg = "Remaining tokens after building AST: \n";
            for (var i = postfix.length - 1; i >= 0; i--) {
                msg += postfix[i].type + ": " + postfix[i].text + "\n";
            }
            throw new Error(msg);
        }

        return result;
    }

    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        /**
         * APIMethod: read
         * Generate a filter from a CQL string.

         * Parameters:
         * text - {String} The CQL text.
         *
         * Returns:
         * {<GeoGlobe.Filter>} A filter based on the CQL text.
         */
        read: function(text) { 
            var result = buildAst(tokenize(text));
            if (this.keepData) {
                this.data = result;
            }
            return result;
        },

        /**
         * APIMethod: write
         * Convert a filter into a CQL string.

         * Parameters:
         * filter - {<GeoGlobe.Filter>} The filter.
         *
         * Returns:
         * {String} A CQL string based on the filter.
         */
        write: function(filter) {
            if (filter instanceof GeoGlobe.Geometry) {
                return filter.toString();
            }
            switch (filter.CLASS_NAME) {
                case "GeoGlobe.Filter.Spatial":
                    switch(filter.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            return "BBOX(" +
                                filter.property + "," +
                                filter.value.toBBOX() +
                                ")";
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            return "DWITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ", " +
                                filter.distance + ")";
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            return "WITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case GeoGlobe.Filter.Spatial.INTERSECTS:
                            return "INTERSECTS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case GeoGlobe.Filter.Spatial.CONTAINS:
                            return "CONTAINS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        default:
                            throw new Error("Unknown spatial filter type: " + filter.type);
                    }
                case "GeoGlobe.Filter.Logical":
                    if (filter.type == GeoGlobe.Filter.Logical.NOT) {
                        // TODO: deal with precedence of logical operators to 
                        // avoid extra parentheses (not urgent)
                        return "NOT (" + this.write(filter.filters[0]) + ")";
                    } else {
                        var res = "(";
                        var first = true;
                        for (var i = 0; i < filter.filters.length; i++) {
                            if (first) {
                                first = false;
                            } else {
                                res += ") " + logicalReverse[filter.type] + " (";
                            }
                            res += this.write(filter.filters[i]);
                        }
                        return res + ")";
                    }
                case "GeoGlobe.Filter.Comparison":
                    if (filter.type == GeoGlobe.Filter.Comparison.BETWEEN) {
                        return filter.property + " BETWEEN " + 
                            this.write(filter.lowerBoundary) + " AND " + 
                            this.write(filter.upperBoundary);
                    } else {
                        return (filter.value !== null) ? filter.property +
                            " " + operatorReverse[filter.type] + " " + 
                            this.write(filter.value) : filter.property +
                            " " + operatorReverse[filter.type];
                    }
                case undefined:
                    if (typeof filter === "string") {
                        return "'" + filter.replace(/'/g, "''") + "'";
                    } else if (typeof filter === "number") {
                        return String(filter);
                    }
                default:
                    throw new Error("Can't encode: " + filter.CLASS_NAME + " " + filter);
            }
        },

        CLASS_NAME: "GeoGlobe.Format.CQL"

    });
})();

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/XML/VersionedOGC.js
 * @requires View2D/Filter/FeatureId.js
 * @requires View2D/Filter/Logical.js
 * @requires View2D/Filter/Comparison.js
 */

/**
 * Class: GeoGlobe.Format.Filter
 * Read/Write ogc:Filter. Create a new instance with the <GeoGlobe.Format.Filter>
 *     constructor.
 * 过滤器的格式化类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML.VersionedOGC>
 */
GeoGlobe.Format.Filter = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * APIMethod: write
     * Write an ogc:Filter given a filter object.
     *
     * Parameters:
     * filter - {<GeoGlobe.Filter>} An filter.
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {Elment} An ogc:Filter element node.
     */
    
    /**
     * APIMethod: read
     * Read and Filter doc and return an object representing the Filter.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     *
     * Returns:
     * {<GeoGlobe.Filter>} A filter object.
     */

    CLASS_NAME: "GeoGlobe.Format.Filter" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
/**
 * @requires View2D/Format/Filter.js
 * @requires View2D/Format/XML.js
 * @requires View2D/Filter/Function.js
 * @requires View2D/BaseTypes/Date.js
 */

/**
 * Class: GeoGlobe.Format.Filter.v1
 * Superclass for Filter version 1 parsers.
 * 过滤器的格式化超类。
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.Filter.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "ogc",

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: null,
    
    /**
     * Constructor: GeoGlobe.Format.Filter.v1
     * Instances of this class are not created directly.  Use the
     *     <GeoGlobe.Format.Filter> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} A Filter document element.
     *
     * Returns:
     * {<GeoGlobe.Filter>} A filter object.
     */
    read: function(data) {
        var obj = {};
        this.readers.ogc["Filter"].apply(this, [data, obj]);
        return obj.filter;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": {
            "_expression": function(node) {
                // only the simplest of ogc:expression handled
                // "some text and an <PropertyName>attribute</PropertyName>"}
                var obj, value = "";
                for(var child=node.firstChild; child; child=child.nextSibling) {
                    switch(child.nodeType) {
                        case 1:
                            obj = this.readNode(child);
                            if (obj.property) {
                                value += "${" + obj.property + "}";
                            } else if (obj.value !== undefined) {
                                value += obj.value;
                            }
                            break;
                        case 3: // text node
                        case 4: // cdata section
                            value += child.nodeValue;
                    }
                }
                return value;
            },
            "Filter": function(node, parent) {
                // Filters correspond to subclasses of GeoGlobe.Filter.
                // Since they contain information we don't persist, we
                // create a temporary object and then pass on the filter
                // (ogc:Filter) to the parent obj.
                var obj = {
                    fids: [],
                    filters: []
                };
                this.readChildNodes(node, obj);
                if(obj.fids.length > 0) {
                    parent.filter = new GeoGlobe.Filter.FeatureId({
                        fids: obj.fids
                    });
                } else if(obj.filters.length > 0) {
                    parent.filter = obj.filters[0];
                }
            },
            "FeatureId": function(node, obj) {
                var fid = node.getAttribute("fid");
                if(fid) {
                    obj.fids.push(fid);
                }
            },
            "And": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.AND
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Or": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.OR
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Not": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.NOT
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThan": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LESS_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThan": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.GREATER_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThanOrEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThanOrEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsBetween": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.BETWEEN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Literal": function(node, obj) {
                obj.value = GeoGlobe.String.numericIf(
                    this.getChildValue(node), true);
            },
            "PropertyName": function(node, filter) {
                filter.property = this.getChildValue(node);
            },
            "LowerBoundary": function(node, filter) {
                filter.lowerBoundary = GeoGlobe.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "UpperBoundary": function(node, filter) {
                filter.upperBoundary = GeoGlobe.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "Intersects": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.INTERSECTS);
            },
            "Within": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.WITHIN);
            },
            "Contains": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.CONTAINS);
            },
            "DWithin": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.DWITHIN);
            },
            "Distance": function(node, obj) {
                obj.distance = parseInt(this.getChildValue(node));
                obj.distanceUnits = node.getAttribute("units");
            },
            "Function": function(node, obj) {
                //TODO write decoder for it
                return;
            },
            "PropertyIsNull": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.IS_NULL
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            }
        }
    },
    
    /**
     * Method: readSpatial
     *
     * Read a {<GeoGlobe.Filter.Spatial>} filter.
     * 
     * Parameters:
     * node - {DOMElement} A DOM element that contains an ogc:expression.
     * obj - {Object} The target object.
     * type - {String} One of the GeoGlobe.Filter.Spatial.* constants.
     *
     * Returns:
     * {<GeoGlobe.Filter.Spatial>} The created filter.
     */
    readSpatial: function(node, obj, type) {
        var filter = new GeoGlobe.Filter.Spatial({
            type: type
        });
        this.readChildNodes(node, filter);
        filter.value = filter.components[0];
        delete filter.components;
        obj.filters.push(filter);
    },

    /**
     * APIMethod: encodeLiteral
     * Generates the string representation of a value for use in <Literal> 
     *     elements.  The default encoder writes Date values as ISO 8601 
     *     strings.
     *
     * Parameters:
     * value - {Object} Literal value to encode
     *
     * Returns:
     * {String} String representation of the provided value.
     */
    encodeLiteral: function(value) {
        if (value instanceof Date) {
            value = GeoGlobe.Date.toISOString(value);
        }
        return value;
    },

    /**
     * Method: writeOgcExpression
     * Limited support for writing OGC expressions. Currently it supports
     * (<GeoGlobe.Filter.Function> || String || Number)
     *
     * Parameters:
     * value - (<GeoGlobe.Filter.Function> || String || Number)
     * node - {DOMElement} A parent DOM element 
     *
     * Returns:
     * {DOMElement} Updated node element.
     */
    writeOgcExpression: function(value, node) {
        if (value instanceof GeoGlobe.Filter.Function){
            this.writeNode("Function", value, node);
        } else {
            this.writeNode("Literal", value, node);
        }
        return node;
    },    
    
    /**
     * Method: write
     *
     * Parameters:
     * filter - {<GeoGlobe.Filter>} A filter object.
     *
     * Returns:
     * {DOMElement} An ogc:Filter element.
     */
    write: function(filter) {
        return this.writers.ogc["Filter"].apply(this, [filter]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ogc": {
            "Filter": function(filter) {
                var node = this.createElementNSPlus("ogc:Filter");
                this.writeNode(this.getFilterType(filter), filter, node);
                return node;
            },
            "_featureIds": function(filter) {
                var node = this.createDocumentFragment();
                for (var i=0, ii=filter.fids.length; i<ii; ++i) {
                    this.writeNode("ogc:FeatureId", filter.fids[i], node);
                }
                return node;
            },
            "FeatureId": function(fid) {
                return this.createElementNSPlus("ogc:FeatureId", {
                    attributes: {fid: fid}
                });
            },
            "And": function(filter) {
                var node = this.createElementNSPlus("ogc:And");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Or": function(filter) {
                var node = this.createElementNSPlus("ogc:Or");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Not": function(filter) {
                var node = this.createElementNSPlus("ogc:Not");
                var childFilter = filter.filters[0];
                this.writeNode(
                    this.getFilterType(childFilter), childFilter, node
                );
                return node;
            },
            "PropertyIsLessThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLessThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsBetween": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsBetween");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                this.writeNode("LowerBoundary", filter, node);
                this.writeNode("UpperBoundary", filter, node);
                return node;
            },
            "PropertyName": function(filter) {
                // no ogc:expression handling for now
                return this.createElementNSPlus("ogc:PropertyName", {
                    value: filter.property
                });
            },
            "Literal": function(value) {
                var encode = this.encodeLiteral ||
                    GeoGlobe.Format.Filter.v1.prototype.encodeLiteral;
                return this.createElementNSPlus("ogc:Literal", {
                    value: encode(value)
                });
            },
            "LowerBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:LowerBoundary");
                this.writeOgcExpression(filter.lowerBoundary, node);
                return node;
            },
            "UpperBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:UpperBoundary");
                this.writeNode("Literal", filter.upperBoundary, node);
                return node;
            },
            "INTERSECTS": function(filter) {
                return this.writeSpatial(filter, "Intersects");
            },
            "WITHIN": function(filter) {
                return this.writeSpatial(filter, "Within");
            },
            "CONTAINS": function(filter) {
                return this.writeSpatial(filter, "Contains");
            },
            "DWITHIN": function(filter) {
                var node = this.writeSpatial(filter, "DWithin");
                this.writeNode("Distance", filter, node);
                return node;
            },
            "Distance": function(filter) {
                return this.createElementNSPlus("ogc:Distance", {
                    attributes: {
                        units: filter.distanceUnits
                    },
                    value: filter.distance
                });
            },
            "Function": function(filter) {
                var node = this.createElementNSPlus("ogc:Function", {
                    attributes: {
                        name: filter.name
                    }
                });
                var params = filter.params;
                for(var i=0, len=params.length; i<len; i++){
                    this.writeOgcExpression(params[i], node);
                }
                return node;
            },
            "PropertyIsNull": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNull");
                this.writeNode("PropertyName", filter, node);
                return node;
            },
			"SortBy": function(sortProperties) {
                var node = this.createElementNSPlus("ogc:SortBy");
                for (var i=0,l=sortProperties.length;i<l;i++) {
                    this.writeNode(
                        "ogc:SortProperty",
                        sortProperties[i],
                        node
                    );
                }
                return node;
            },
            "SortProperty": function(sortProperty) {
                var node = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode(
                    "ogc:PropertyName",
                    sortProperty,
                    node
                );
                this.writeNode(
                    "ogc:SortOrder",
                    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
                    node
                );
                return node;
            },
            "SortOrder": function(value) {
                var node = this.createElementNSPlus("ogc:SortOrder", {
                    value: value
                });
                return node;
            }
        }
    },

    /**
     * Method: getFilterType
     */
    getFilterType: function(filter) {
        var filterType = this.filterMap[filter.type];
        if(!filterType) {
            throw "Filter writing not supported for rule type: " + filter.type;
        }
        return filterType;
    },
    
    /**
     * Property: filterMap
     * {Object} Contains a member for each filter type.  Values are node names
     *     for corresponding OGC Filter child elements.
     */
    filterMap: {
        "&&": "And",
        "||": "Or",
        "!": "Not",
        "==": "PropertyIsEqualTo",
        "!=": "PropertyIsNotEqualTo",
        "<": "PropertyIsLessThan",
        ">": "PropertyIsGreaterThan",
        "<=": "PropertyIsLessThanOrEqualTo",
        ">=": "PropertyIsGreaterThanOrEqualTo",
        "..": "PropertyIsBetween",
        "~": "PropertyIsLike",
        "NULL": "PropertyIsNull",
        "BBOX": "BBOX",
        "DWITHIN": "DWITHIN",
        "WITHIN": "WITHIN",
        "CONTAINS": "CONTAINS",
        "INTERSECTS": "INTERSECTS",
        "FID": "_featureIds"
    },

    CLASS_NAME: "GeoGlobe.Format.Filter.v1" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/GML/v2.js
 * @requires View2D/Format/Filter/v1.js
 */

/**
 * Class: GeoGlobe.Format.Filter.v1_0_0
 * Write ogc:Filter version 1.0.0.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.GML.v2>
 *  - <GeoGlobe.Format.Filter.v1>
 */
GeoGlobe.Format.Filter.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.GML.v2, GeoGlobe.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.0.0/filter.xsd
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.0.0/filter.xsd",

    /**
     * Constructor: GeoGlobe.Format.Filter.v1_0_0
     * Instances of this class are not created directly.  Use the
     *     <GeoGlobe.Format.Filter> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.v2.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escape");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, GeoGlobe.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.readers["feature"]        
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        wildCard: "*", singleChar: ".", escape: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is mandatory in 1.0.0, but e.g. GeoServer also
                // accepts filters without it. When this is used with
                // GeoGlobe.Protocol.WFS, GeoGlobe.Format.WFST will set a
                // missing filter.property to the geometryName that is
                // configured with the protocol, which defaults to "the_geom".
                // So the only way to omit this mandatory property is to not
                // set the property on the filter and to set the geometryName
                // on the WFS protocol to null. The latter also happens when
                // the protocol is configured without a geometryName and a
                // featureNS.
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Box", filter.value, node);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                return node;
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.writers["feature"]
    },

    /**
     * Method: writeSpatial
     *
     * Read a {<GeoGlobe.Filter.Spatial>} filter and converts it into XML.
     *
     * Parameters:
     * filter - {<GeoGlobe.Filter.Spatial>} The filter.
     * name - {String} Name of the generated XML element.
     *
     * Returns:
     * {DOMElement} The created XML element.
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof GeoGlobe.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof GeoGlobe.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Box", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },


    CLASS_NAME: "GeoGlobe.Format.Filter.v1_0_0" 

});/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/Filter/v1.js
 * @requires View2D/Format/GML/v3.js
 */

/**
 * Class: GeoGlobe.Format.Filter.v1_1_0
 * Write ogc:Filter version 1.1.0.
 *
 * Differences from the v1.0.0 parser:
 *  - uses GML v3 instead of GML v2
 *  - reads matchCase attribute on ogc:PropertyIsEqual and
 *        ogc:PropertyIsNotEqual elements.
 *  - writes matchCase attribute from comparison filters of type EQUAL_TO,
 *        NOT_EQUAL_TO and LIKE.
 * 
 * Inherits from: 
 *  - <GeoGlobe.Format.GML.v3>
 *  - <GeoGlobe.Format.Filter.v1>
 */
GeoGlobe.Format.Filter.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.GML.v3, GeoGlobe.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.1.0
     */
    VERSION: "1.1.0",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.1.0/filter.xsd
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.1.0/filter.xsd",

    /**
     * Constructor: GeoGlobe.Format.Filter.v1_1_0
     * Instances of this class are not created directly.  Use the
     *     <GeoGlobe.Format.Filter> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.v3.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escapeChar");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, GeoGlobe.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.readers["feature"]        
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        matchCase: filter.matchCase,
                        wildCard: "*", singleChar: ".", escapeChar: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is optional in 1.1.0
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Envelope", filter.value);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                node.appendChild(box); 
                return node;
            },
            "SortBy": function(sortProperties) {
                var node = this.createElementNSPlus("ogc:SortBy");
                for (var i=0,l=sortProperties.length;i<l;i++) {
                    this.writeNode(
                        "ogc:SortProperty",
                        sortProperties[i],
                        node
                    );
                }
                return node;
            }, 
            "SortProperty": function(sortProperty) {
                var node = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode(
                    "ogc:PropertyName",
                    sortProperty,
                    node
                );
                this.writeNode(
                    "ogc:SortOrder",
                    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
                    node
                );
                return node;
            },
            "SortOrder": function(value) {
                var node = this.createElementNSPlus("ogc:SortOrder", {
                    value: value
                });
                return node;
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.writers["feature"]
    },

    /**
     * Method: writeSpatial
     *
     * Read a {<GeoGlobe.Filter.Spatial>} filter and converts it into XML.
     *
     * Parameters:
     * filter - {<GeoGlobe.Filter.Spatial>} The filter.
     * name - {String} Name of the generated XML element.
     *
     * Returns:
     * {DOMElement} The created XML element.
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof GeoGlobe.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof GeoGlobe.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Envelope", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },

    CLASS_NAME: "GeoGlobe.Format.Filter.v1_1_0" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/Format.js
 */

/**
 * Function: GeoGlobe.Format.WFST
 * WFST格式化类。
 *
 * Returns:
 * {<GeoGlobe.Format>} A WFST format of the given version.
 */
GeoGlobe.Format.WFST = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Format.WFST.DEFAULTS
    );
    var cls = GeoGlobe.Format.WFST["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFST version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: GeoGlobe.Format.WFST.DEFAULTS
 * {Object} Default properties for the WFST format.
 */
GeoGlobe.Format.WFST.DEFAULTS = {
    "version": "1.0.0"
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/XML.js
 * @requires View2D/Format/WFST.js
 * @requires View2D/Filter/Spatial.js
 * @requires View2D/Filter/FeatureId.js
 */

/**
 * Class: GeoGlobe.Format.WFST.v1
 * Superclass for WFST parsers.
 * WFST的格式化超类。
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.WFST.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs",
        gml: "http://www.opengis.net/gml",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows"
    },
    
    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wfs",

    /**
     * Property: version
     * {String} WFS version number.
     */
    version: null,

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocations: null,
    
    /**
     * APIProperty: srsName
     * {String} URI for spatial reference system.
     */
    srsName: null,

    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from GML.  Default is true.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */ 
    xy: true,

    /**
     * Property: stateName
     * {Object} Maps feature states to node names.
     */
    stateName: null,
    
    /**
     * Constructor: GeoGlobe.Format.WFST.v1
     * Instances of this class are not created directly.  Use the
     *     <GeoGlobe.Format.WFST.v1_0_0> or <GeoGlobe.Format.WFST.v1_1_0>
     *     constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        // set state name mapping
        this.stateName = {};
        this.stateName[GeoGlobe.State.INSERT] = "wfs:Insert";
        this.stateName[GeoGlobe.State.UPDATE] = "wfs:Update";
        this.stateName[GeoGlobe.State.DELETE] = "wfs:Delete";
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: getSrsName
     */
    getSrsName: function(feature, options) {
        var srsName = options && options.srsName;
        if(!srsName) {
            if(feature && feature.layer) {
                srsName = feature.layer.projection.getCode();
            } else {
                srsName = this.srsName;
            }
        }
        return srsName;
    },

    /**
     * APIMethod: read
     * Parse the response from a transaction.  Because WFS is split into
     *     Transaction requests (create, update, and delete) and GetFeature
     *     requests (read), this method handles parsing of both types of
     *     responses.
     *
     * Parameters:
     * data - {String | Document} The WFST document to read
     * options - {Object} Options for the reader
     *
     * Valid options properties:
     * output - {String} either "features" or "object". The default is
     *     "features", which means that the method will return an array of
     *     features. If set to "object", an object with a "features" property
     *     and other properties read by the parser will be returned.
     *
     * Returns:
     * {Array | Object} Output depending on the output option.
     */
    read: function(data, options) {
        options = options || {};
        GeoGlobe.Util.applyDefaults(options, {
            output: "features"
        });
        
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        if(data) {
            this.readNode(data, obj, true);
        }
        if(obj.features && options.output === "features") {
            obj = obj.features;
        }
        return obj;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": {
            "FeatureCollection": function(node, obj) {
                obj.features = [];
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**
     * Method: write
     * Given an array of features, write a WFS transaction.  This assumes
     *     the features have a state property that determines the operation
     *     type - insert, update, or delete.
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>)} A list of features. See
     *     below for a more detailed description of the influence of the
     *     feature's *modified* property.
     * options - {Object}
     *
     * feature.modified rules:
     * If a feature has a modified property set, the following checks will be
     * made before a feature's geometry or attribute is included in an Update
     * transaction:
     * - *modified* is not set at all: The geometry and all attributes will be
     *     included.
     * - *modified.geometry* is set (null or a geometry): The geometry will be
     *     included. If *modified.attributes* is not set, all attributes will
     *     be included.
     * - *modified.attributes* is set: Only the attributes set (i.e. to null or
     *     a value) in *modified.attributes* will be included. 
     *     If *modified.geometry* is not set, the geometry will not be included.
     *
     * Valid options include:
     * - *multi* {Boolean} If set to true, geometries will be casted to
     *   Multi geometries before writing.
     *
     * Returns:
     * {String} A serialized WFS transaction.
     */
    write: function(features, options) {
        var node = this.writeNode("wfs:Transaction", {
            features:features,
            options: options
        });
        var value = this.schemaLocationAttr();
        if(value) {
            this.setAttributeNS(
                node, this.namespaces["xsi"], "xsi:schemaLocation",  value
            );
        }
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wfs": {
            "GetFeature": function(options) {
				/*
                var node = this.createElementNSPlus("wfs:GetFeature", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options && options.handle,
                        outputFormat: options && options.outputFormat,
                        maxFeatures: options && options.maxFeatures,
                        "xsi:schemaLocation": this.schemaLocationAttr(options)
                    }
                });
                */
				var node = this.createElementNSPlus("wfs:GetFeature", {
			        attributes: {
			            service: "WFS",
			            version: this.version,
						//handle: options && options.handle,
			            outputFormat: options && options.outputFormat,
			            maxFeatures: options && options.maxFeatures,
			            resultType: options && options.resultType,//增加resultType属性
			            startPosition: options && options.startPosition,//增加startPosition属性
			            "xsi:schemaLocation": this.schemaLocationAttr(options)
			        }
			    });
                if (typeof this.featureType == "string") {
                    this.writeNode("Query", options, node);
                } else {
                    for (var i=0,len = this.featureType.length; i<len; i++) { 
                        options.featureType = this.featureType[i]; 
                        this.writeNode("Query", options, node); 
                    } 
                }
			    return node;
            },
            "Transaction": function(obj) {
                obj = obj || {};
                var options = obj.options || {};
                var node = this.createElementNSPlus("wfs:Transaction", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options.handle
                    }
                });
                var i, len;
                var features = obj.features;
                if(features) {
                    // temporarily re-assigning geometry types
                    if (options.multi === true) {
                        GeoGlobe.Util.extend(this.geometryTypes, {
                            "GeoGlobe.Geometry.Point": "MultiPoint",
                            "GeoGlobe.Geometry.LineString": (this.multiCurve === true) ? "MultiCurve": "MultiLineString",
                            "GeoGlobe.Geometry.Polygon": (this.multiSurface === true) ? "MultiSurface" : "MultiPolygon"
                        });
                    }
                    var name, feature;
                    for(i=0, len=features.length; i<len; ++i) {
                        feature = features[i];
                        name = this.stateName[feature.state];
                        if(name) {
                            this.writeNode(name, {
                                feature: feature, 
                                options: options
                            }, node);
                        }
                    }
                    // switch back to original geometry types assignment
                    if (options.multi === true) {
                        this.setGeometryTypes();
                    }
                }
                if (options.nativeElements) {
                    for (i=0, len=options.nativeElements.length; i<len; ++i) {
                        this.writeNode("wfs:Native", 
                            options.nativeElements[i], node);
                    }
                }
                return node;
            },
            "Native": function(nativeElement) {
                var node = this.createElementNSPlus("wfs:Native", {
                    attributes: {
                        vendorId: nativeElement.vendorId,
                        safeToIgnore: nativeElement.safeToIgnore
                    },
                    value: nativeElement.value
                });
                return node;
            },
            "Insert": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Insert", {
                    attributes: {
                        handle: options && options.handle
                    }
                });
                this.srsName = this.getSrsName(feature);
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "Update": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Update", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                
                // add in geometry
                var modified = feature.modified;
                if (this.geometryName !== null && (!modified || modified.geometry !== undefined)) {
                    this.srsName = this.getSrsName(feature);
                    this.writeNode(
                        "Property", {name: this.geometryName, value: feature.geometry}, node
                    );
                }
        
                // add in attributes
                for(var key in feature.attributes) {
                    if(feature.attributes[key] !== undefined &&
                                (!modified || !modified.attributes ||
                                (modified.attributes && modified.attributes[key] !== undefined))) {
                        this.writeNode(
                            "Property", {name: key, value: feature.attributes[key]}, node
                        );
                    }
                }
                
                // add feature id filter
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
        
                return node;
            },
            "Property": function(obj) {
                var node = this.createElementNSPlus("wfs:Property");
                this.writeNode("Name", obj.name, node);
                if(obj.value !== null) {
                    this.writeNode("Value", obj.value, node);
                }
                return node;
            },
            "Name": function(name) {
                return this.createElementNSPlus("wfs:Name", {value: name});
            },
            "Value": function(obj) {
                var node;
                if(obj instanceof GeoGlobe.Geometry) {
                    node = this.createElementNSPlus("wfs:Value");
                    var geom = this.writeNode("feature:_geometry", obj).firstChild;
                    node.appendChild(geom);
                } else {
                    node = this.createElementNSPlus("wfs:Value", {value: obj});                
                }
                return node;
            },
            "Delete": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Delete", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
                return node;
            }
        }
    },

    /**
     * Method: schemaLocationAttr
     * Generate the xsi:schemaLocation attribute value.
     *
     * Returns:
     * {String} The xsi:schemaLocation attribute or undefined if none.
     */
    schemaLocationAttr: function(options) {
        options = GeoGlobe.Util.extend({
            featurePrefix: this.featurePrefix,
            schema: this.schema
        }, options);
        var schemaLocations = GeoGlobe.Util.extend({}, this.schemaLocations);
        if(options.schema) {
            schemaLocations[options.featurePrefix] = options.schema;
        }
        var parts = [];
        var uri;
        for(var key in schemaLocations) {
            uri = this.namespaces[key];
            if(uri) {
                parts.push(uri + " " + schemaLocations[key]);
            }
        }
        var value = parts.join(" ") || undefined;
        return value;
    },
    
    /**
     * Method: setFilterProperty
     * Set the property of each spatial filter.
     *
     * Parameters:
     * filter - {<GeoGlobe.Filter>}
     */
    setFilterProperty: function(filter) {
        if(filter.filters) {
            for(var i=0, len=filter.filters.length; i<len; ++i) {
                GeoGlobe.Format.WFST.v1.prototype.setFilterProperty.call(this, filter.filters[i]);
            }
        } else {
            if(filter instanceof GeoGlobe.Filter.Spatial && !filter.property) {
                // got a spatial filter without property, so set it
                filter.property = this.geometryName;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WFST.v1" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/WFST/v1.js
 * @requires View2D/Format/Filter/v1_0_0.js
 */

/**
 * Class: GeoGlobe.Format.WFST.v1_0_0
 * A format for creating WFS v1.0.0 transactions.  Create a new instance with the
 *     <GeoGlobe.Format.WFST.v1_0_0> constructor.
 * WFST的格式化类。1.0.0版本。
 *
 * Inherits from:
 *  - <GeoGlobe.Format.Filter.v1_0_0>
 *  - <GeoGlobe.Format.WFST.v1>
 */
GeoGlobe.Format.WFST.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.Filter.v1_0_0, GeoGlobe.Format.WFST.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.0.0",

    /**
     * APIProperty: srsNameInQuery
     * {Boolean} If true the reference system is passed in Query requests
     *     via the "srsName" attribute to the "wfs:Query" element, this
     *     property defaults to false as it isn't WFS 1.0.0 compliant.
     */
    srsNameInQuery: false,
    
    /**
     * Property: schemaLocations
     * {Object} Properties are namespace aliases, values are schema locations.
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd"
    },

    /**
     * Constructor: GeoGlobe.Format.WFST.v1_0_0
     * A class for parsing and generating WFS v1.0.0 transactions.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     */
    initialize: function(options) {
        GeoGlobe.Format.Filter.v1_0_0.prototype.initialize.apply(this, [options]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     * first - {Boolean} Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v2. We need this because we don't want to get readNode
        // from the superclass's superclass, which is GeoGlobe.Format.XML.
        return GeoGlobe.Format.GML.v2.prototype.readNode.apply(this, arguments);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "WFS_TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "InsertResult": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds = container.insertIds.concat(obj.fids);
            },
            "TransactionResult": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Status": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SUCCESS": function(node, obj) {
                obj.success = true;
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.readers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_0_0.prototype.readers["ogc"]
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "Query": function(options) {
                options = GeoGlobe.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName,
                    srsNameInQuery: this.srsNameInQuery
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (options.featureNS ? prefix + ":" : "") +
                            options.featureType,
						time: options && options.time, //可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间
						userecent: options && options.userecent //可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
                    }
                });
                if(options.srsNameInQuery && options.srsName) {
                    node.setAttribute("srsName", options.srsName);
                }
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "ogc:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    this.setFilterProperty(options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
				if (options.sortBy) {
                    this.writeNode("ogc:SortBy", options.sortBy, node);
                }
				if (options.groupBy) {
	                this.writeNode("ogc:GroupBy", options.groupBy, node);
	            }
                return node;
            }
        }, GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.writers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_0_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "GeoGlobe.Format.WFST.v1_0_0" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/WFST/v1.js
 * @requires View2D/Format/Filter/v1_1_0.js
 * @requires View2D/Format/OWSCommon/v1_0_0.js
 */

/**
 * Class: GeoGlobe.Format.WFST.v1_1_0
 * A format for creating WFS v1.1.0 transactions.  Create a new instance with the
 *     <GeoGlobe.Format.WFST.v1_1_0> constructor.
 * WFST的格式化类。1.1.0版本。
 *
 * Inherits from:
 *  - <GeoGlobe.Format.Filter.v1_1_0>
 *  - <GeoGlobe.Format.WFST.v1>
 */
GeoGlobe.Format.WFST.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.Filter.v1_1_0, GeoGlobe.Format.WFST.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.1.0",
    
    /**
     * Property: schemaLocations
     * {Object} Properties are namespace aliases, values are schema locations.
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"
    },
    
    /**
     * Constructor: GeoGlobe.Format.WFST.v1_1_0
     * A class for parsing and generating WFS v1.1.0 transactions.
     *
     * To read additional information like hit count (numberOfFeatures) from
     * the  FeatureCollection, call the <GeoGlobe.Format.WFST.v1.read> method
     * with {output: "object"} as 2nd argument. Note that it is possible to
     * just request the hit count from a WFS 1.1.0 server with the
     * resultType="hits" request parameter.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     */
    initialize: function(options) {
        GeoGlobe.Format.Filter.v1_1_0.prototype.initialize.apply(this, [options]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     * first - {Boolean} Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v3. We need this because we don't want to get readNode
        // from the superclass's superclass, which is GeoGlobe.Format.XML.
        return GeoGlobe.Format.GML.v3.prototype.readNode.apply(this, arguments);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "FeatureCollection": function(node, obj) {
                obj.numberOfFeatures = parseInt(node.getAttribute(
                    "numberOfFeatures"));
                GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]["FeatureCollection"].apply(
                    this, arguments);
            },
            "TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "TransactionSummary": function(node, obj) {
                // this is a limited test of success
                obj.success = true;
            },
            "InsertResults": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Feature": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds.push(obj.fids[0]);
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.readers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.readers["ogc"],
        "ows": GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"]
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "GetFeature": function(options) {
                var node = GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]["GetFeature"].apply(this, arguments);
                options && this.setAttributes(node, {
                    resultType: options.resultType,
                    startIndex: options.startIndex,
                    count: options.count
                });
                return node;
            },
            "Query": function(options) {
                options = GeoGlobe.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (options.featureNS ? prefix + ":" : "") +
                            options.featureType,
                        srsName: options.srsName,
						time: options && options.time, //可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间
						userecent: options && options.userecent //可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
                    }
                });
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "wfs:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    GeoGlobe.Format.WFST.v1_1_0.prototype.setFilterProperty.call(this, options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
				if (options.sortBy) {
	                this.writeNode("ogc:SortBy", options.sortBy, node);
	            }
				if (options.groupBy) {
	                this.writeNode("ogc:GroupBy", options.groupBy, node);
	            }
                return node;
            },
            "PropertyName": function(obj) {
                return this.createElementNSPlus("wfs:PropertyName", {
                    value: obj.property
                });
            }            
        }, GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.writers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },

    CLASS_NAME: "GeoGlobe.Format.WFST.v1_1_0" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * Note:
 * This work draws heavily from the public domain JSON serializer/deserializer
 *     at http://www.json.org/json.js. Rewritten so that it doesn't modify
 *     basic data prototypes.
 */

/**
 * @requires View2D/Format/Format.js
 */

/**
 * Class: GeoGlobe.Format.JSON
 * A parser to read/write JSON safely.  Create a new instance with the
 *     <GeoGlobe.Format.JSON> constructor.
 * JSON格式化类。
 *
 * Inherits from:
 *  - <GeoGlobe.Format>
 */
GeoGlobe.Format.JSON = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     * APIProperty: indent
     * {String} For "pretty" printing, the indent string will be used once for
     *     each indentation level.
     */
    indent: "    ",
    
    /**
     * APIProperty: space
     * {String} For "pretty" printing, the space string will be used after
     *     the ":" separating a name/value pair.
     */
    space: " ",
    
    /**
     * APIProperty: newline
     * {String} For "pretty" printing, the newline string will be used at the
     *     end of each name/value pair or array item.
     */
    newline: "\n",
    
    /**
     * Property: level
     * {Integer} For "pretty" printing, this is incremented/decremented during
     *     serialization.
     */
    level: 0,

    /**
     * Property: pretty
     * {Boolean} Serialize with extra whitespace for structure.  This is set
     *     by the <write> method.
     */
    pretty: false,

    /**
     * Property: nativeJSON
     * {Boolean} Does the browser support native json?
     */
    nativeJSON: (function() {
        return !!(window.JSON && typeof JSON.parse == "function" && typeof JSON.stringify == "function");
    })(),

    /**
     * Constructor: GeoGlobe.Format.JSON
     * Create a new parser for JSON.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Deserialize a json string.
     *
     * Parameters:
     * json - {String} A JSON string
     * filter - {Function} A function which will be called for every key and
     *     value at every level of the final result. Each value will be
     *     replaced by the result of the filter function. This can be used to
     *     reform generic objects into instances of classes, or to transform
     *     date strings into Date objects.
     *     
     * Returns:
     * {Object} An object, array, string, or number .
     */
    read: function(json, filter) {
        var object;
        if (this.nativeJSON) {
            object = JSON.parse(json, filter);
        } else try {
            /**
             * Parsing happens in three stages. In the first stage, we run the
             *     text against a regular expression which looks for non-JSON
             *     characters. We are especially concerned with '()' and 'new'
             *     because they can cause invocation, and '=' because it can
             *     cause mutation. But just to be safe, we will reject all
             *     unexpected characters.
             */
            if (/^[\],:{}\s]*$/.test(json.replace(/\\["\\\/bfnrtu]/g, '@').
                                replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
                                replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

                /**
                 * In the second stage we use the eval function to compile the
                 *     text into a JavaScript structure. The '{' operator is
                 *     subject to a syntactic ambiguity in JavaScript - it can
                 *     begin a block or an object literal. We wrap the text in
                 *     parens to eliminate the ambiguity.
                 */
                object = eval('(' + json + ')');

                /**
                 * In the optional third stage, we recursively walk the new
                 *     structure, passing each name/value pair to a filter
                 *     function for possible transformation.
                 */
                if(typeof filter === 'function') {
                    function walk(k, v) {
                        if(v && typeof v === 'object') {
                            for(var i in v) {
                                if(v.hasOwnProperty(i)) {
                                    v[i] = walk(i, v[i]);
                                }
                            }
                        }
                        return filter(k, v);
                    }
                    object = walk('', object);
                }
            }
        } catch(e) {
            // Fall through if the regexp test fails.
        }

        if(this.keepData) {
            this.data = object;
        }

        return object;
    },

    /**
     * APIMethod: write
     * Serialize an object into a JSON string.
     *
     * Parameters:
     * value - {String} The object, array, string, number, boolean or date
     *     to be serialized.
     * pretty - {Boolean} Structure the output with newlines and indentation.
     *     Default is false.
     *
     * Returns:
     * {String} The JSON string representation of the input value.
     */
    write: function(value, pretty) {
        this.pretty = !!pretty;
        var json = null;
        var type = typeof value;
        if(this.serialize[type]) {
            try {
                json = (!this.pretty && this.nativeJSON) ?
                    JSON.stringify(value) :
                    this.serialize[type].apply(this, [value]);
            } catch(err) {
                GeoGlobe.Console.error("Trouble serializing: " + err);
            }
        }
        return json;
    },
    
    /**
     * Method: writeIndent
     * Output an indentation string depending on the indentation level.
     *
     * Returns:
     * {String} An appropriate indentation string.
     */
    writeIndent: function() {
        var pieces = [];
        if(this.pretty) {
            for(var i=0; i<this.level; ++i) {
                pieces.push(this.indent);
            }
        }
        return pieces.join('');
    },
    
    /**
     * Method: writeNewline
     * Output a string representing a newline if in pretty printing mode.
     *
     * Returns:
     * {String} A string representing a new line.
     */
    writeNewline: function() {
        return (this.pretty) ? this.newline : '';
    },
    
    /**
     * Method: writeSpace
     * Output a string representing a space if in pretty printing mode.
     *
     * Returns:
     * {String} A space.
     */
    writeSpace: function() {
        return (this.pretty) ? this.space : '';
    },

    /**
     * Property: serialize
     * Object with properties corresponding to the serializable data types.
     *     Property values are functions that do the actual serializing.
     */
    serialize: {
        /**
         * Method: serialize.object
         * Transform an object into a JSON string.
         *
         * Parameters:
         * object - {Object} The object to be serialized.
         * 
         * Returns:
         * {String} A JSON string representing the object.
         */
        'object': function(object) {
            // three special objects that we want to treat differently
            if(object == null) {
                return "null";
            }
            if(object.constructor == Date) {
                return this.serialize.date.apply(this, [object]);
            }
            if(object.constructor == Array) {
                return this.serialize.array.apply(this, [object]);
            }
            var pieces = ['{'];
            this.level += 1;
            var key, keyJSON, valueJSON;
            
            var addComma = false;
            for(key in object) {
                if(object.hasOwnProperty(key)) {
                    // recursive calls need to allow for sub-classing
                    keyJSON = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [key, this.pretty]);
                    valueJSON = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [object[key], this.pretty]);
                    if(keyJSON != null && valueJSON != null) {
                        if(addComma) {
                            pieces.push(',');
                        }
                        pieces.push(this.writeNewline(), this.writeIndent(),
                                    keyJSON, ':', this.writeSpace(), valueJSON);
                        addComma = true;
                    }
                }
            }
            
            this.level -= 1;
            pieces.push(this.writeNewline(), this.writeIndent(), '}');
            return pieces.join('');
        },
        
        /**
         * Method: serialize.array
         * Transform an array into a JSON string.
         *
         * Parameters:
         * array - {Array} The array to be serialized
         * 
         * Returns:
         * {String} A JSON string representing the array.
         */
        'array': function(array) {
            var json;
            var pieces = ['['];
            this.level += 1;
    
            for(var i=0, len=array.length; i<len; ++i) {
                // recursive calls need to allow for sub-classing
                json = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [array[i], this.pretty]);
                if(json != null) {
                    if(i > 0) {
                        pieces.push(',');
                    }
                    pieces.push(this.writeNewline(), this.writeIndent(), json);
                }
            }

            this.level -= 1;    
            pieces.push(this.writeNewline(), this.writeIndent(), ']');
            return pieces.join('');
        },
        
        /**
         * Method: serialize.string
         * Transform a string into a JSON string.
         *
         * Parameters:
         * string - {String} The string to be serialized
         * 
         * Returns:
         * {String} A JSON string representing the string.
         */
        'string': function(string) {
            // If the string contains no control characters, no quote characters, and no
            // backslash characters, then we can simply slap some quotes around it.
            // Otherwise we must also replace the offending characters with safe
            // sequences.    
            var m = {
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"' : '\\"',
                '\\': '\\\\'
            };
            if(/["\\\x00-\x1f]/.test(string)) {
                return '"' + string.replace(/([\x00-\x1f\\"])/g, function(a, b) {
                    var c = m[b];
                    if(c) {
                        return c;
                    }
                    c = b.charCodeAt();
                    return '\\u00' +
                        Math.floor(c / 16).toString(16) +
                        (c % 16).toString(16);
                }) + '"';
            }
            return '"' + string + '"';
        },

        /**
         * Method: serialize.number
         * Transform a number into a JSON string.
         *
         * Parameters:
         * number - {Number} The number to be serialized.
         *
         * Returns:
         * {String} A JSON string representing the number.
         */
        'number': function(number) {
            return isFinite(number) ? String(number) : "null";
        },
        
        /**
         * Method: serialize.boolean
         * Transform a boolean into a JSON string.
         *
         * Parameters:
         * bool - {Boolean} The boolean to be serialized.
         * 
         * Returns:
         * {String} A JSON string representing the boolean.
         */
        'boolean': function(bool) {
            return String(bool);
        },
        
        /**
         * Method: serialize.object
         * Transform a date into a JSON string.
         *
         * Parameters:
         * date - {Date} The date to be serialized.
         * 
         * Returns:
         * {String} A JSON string representing the date.
         */
        'date': function(date) {    
            function format(number) {
                // Format integers to have at least two digits.
                return (number < 10) ? '0' + number : number;
            }
            return '"' + date.getFullYear() + '-' +
                    format(date.getMonth() + 1) + '-' +
                    format(date.getDate()) + 'T' +
                    format(date.getHours()) + ':' +
                    format(date.getMinutes()) + ':' +
                    format(date.getSeconds()) + '"';
        }
    },

    CLASS_NAME: "GeoGlobe.Format.JSON" 

});     
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/JSON.js
 * @requires View2D/Feature/Vector.js
 * @requires View2D/Geometry/Point.js
 * @requires View2D/Geometry/MultiPoint.js
 * @requires View2D/Geometry/LineString.js
 * @requires View2D/Geometry/MultiLineString.js
 * @requires View2D/Geometry/Polygon.js
 * @requires View2D/Geometry/MultiPolygon.js
 * @requires View2D/Console.js
 */

/**
 * Class: GeoGlobe.Format.GeoJSON
 * Read and write GeoJSON. Create a new parser with the
 *     <GeoGlobe.Format.GeoJSON> constructor.
 * JSON格式化类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.JSON>
 */
GeoGlobe.Format.GeoJSON = GeoGlobe.Class4OL(GeoGlobe.Format.JSON, {

    /**
     * APIProperty: ignoreExtraDims
     * {Boolean} Ignore dimensions higher than 2 when reading geometry
     * coordinates.
     */ 
    ignoreExtraDims: false,
    
    /**
     * Constructor: GeoGlobe.Format.GeoJSON
     * Create a new parser for GeoJSON.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Deserialize a GeoJSON string.
     *
     * Parameters:
     * json - {String} A GeoJSON string
     * type - {String} Optional string that determines the structure of
     *     the output.  Supported values are "Geometry", "Feature", and
     *     "FeatureCollection".  If absent or null, a default of
     *     "FeatureCollection" is assumed.
     * filter - {Function} A function which will be called for every key and
     *     value at every level of the final result. Each value will be
     *     replaced by the result of the filter function. This can be used to
     *     reform generic objects into instances of classes, or to transform
     *     date strings into Date objects.
     *
     * Returns: 
     * {Object} The return depends on the value of the type argument. If type
     *     is "FeatureCollection" (the default), the return will be an array
     *     of <GeoGlobe.Feature>. If type is "Geometry", the input json
     *     must represent a single geometry, and the return will be an
     *     <GeoGlobe.Geometry>.  If type is "Feature", the input json must
     *     represent a single feature, and the return will be an
     *     <GeoGlobe.Feature>.
     */
    read: function(json, type, filter) {
        type = (type) ? type : "FeatureCollection";
        var results = null;
        var obj = null;
        if (typeof json == "string") {
            obj = GeoGlobe.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if(!obj) {
            GeoGlobe.Console.error("Bad JSON: " + json);
        } else if(typeof(obj.type) != "string") {
            GeoGlobe.Console.error("Bad GeoJSON - no type: " + json);
        } else if(this.isValidType(obj, type)) {
            switch(type) {
                case "Geometry":
                    try {
                        results = this.parseGeometry(obj);
                    } catch(err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case "Feature":
                    try {
                        results = this.parseFeature(obj);
                        results.type = "Feature";
                    } catch(err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case "FeatureCollection":
                    // for type FeatureCollection, we allow input to be any type
                    results = [];
                    switch(obj.type) {
                        case "Feature":
                            try {
                                results.push(this.parseFeature(obj));
                            } catch(err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                            break;
                        case "FeatureCollection":
                            for(var i=0, len=obj.features.length; i<len; ++i) {
                                try {
                                    results.push(this.parseFeature(obj.features[i]));
                                } catch(err) {
                                    results = null;
                                    GeoGlobe.Console.error(err);
                                }
                            }
                            break;
                        default:
                            try {
                                var geom = this.parseGeometry(obj);
                                results.push(new GeoGlobe.Feature(geom));
                            } catch(err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                    }
                break;
            }
        }
        return results;
    },
    
    /**
     * Method: isValidType
     * Check if a GeoJSON object is a valid representative of the given type.
     *
     * Returns:
     * {Boolean} The object is valid GeoJSON object of the given type.
     */
    isValidType: function(obj, type) {
        var valid = false;
        switch(type) {
            case "Geometry":
                if(GeoGlobe.Util.indexOf(
                    ["Point", "MultiPoint", "LineString", "MultiLineString",
                     "Polygon", "MultiPolygon", "Box", "GeometryCollection"],
                    obj.type) == -1) {
                    // unsupported geometry type
                    GeoGlobe.Console.error("Unsupported geometry type: " +
                                              obj.type);
                } else {
                    valid = true;
                }
                break;
            case "FeatureCollection":
                // allow for any type to be converted to a feature collection
                valid = true;
                break;
            default:
                // for Feature types must match
                if(obj.type == type) {
                    valid = true;
                } else {
                    GeoGlobe.Console.error("Cannot convert types from " +
                                              obj.type + " to " + type);
                }
        }
        return valid;
    },
    
    /**
     * Method: parseFeature
     * Convert a feature object from GeoJSON into an
     *     <GeoGlobe.Feature>.
     *
     * Parameters:
     * obj - {Object} An object created from a GeoJSON object
     *
     * Returns:
     * {<GeoGlobe.Feature>} A feature.
     */
    parseFeature: function(obj) {
        var feature, geometry, attributes, bbox;
        attributes = (obj.properties) ? obj.properties : {};
        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;
        try {
            geometry = this.parseGeometry(obj.geometry);
        } catch(err) {
            // deal with bad geometries
            throw err;
        }
        feature = new GeoGlobe.Feature(geometry, attributes);
        if(bbox) {
            feature.bounds = GeoGlobe.LngLatBounds.fromArray(bbox);
        }
        if(obj.id) {
            feature.fid = obj.id;
        }
        return feature;
    },
    
    /**
     * Method: parseGeometry
     * Convert a geometry object from GeoJSON into an <GeoGlobe.Geometry>.
     *
     * Parameters:
     * obj - {Object} An object created from a GeoJSON object
     *
     * Returns: 
     * {<GeoGlobe.Geometry>} A geometry.
     */
    parseGeometry: function(obj) {
        if (obj == null) {
            return null;
        }
        var geometry, collection = false;
        if(obj.type == "GeometryCollection") {
            if(!(GeoGlobe.Util.isArray(obj.geometries))) {
                throw "GeometryCollection must have geometries array: " + obj;
            }
            var numGeom = obj.geometries.length;
            var components = new Array(numGeom);
            for(var i=0; i<numGeom; ++i) {
                components[i] = this.parseGeometry.apply(
                    this, [obj.geometries[i]]
                );
            }
            geometry = new GeoGlobe.Geometry.Collection(components);
            collection = true;
        } else {
            if(!(GeoGlobe.Util.isArray(obj.coordinates))) {
                throw "Geometry must have coordinates array: " + obj;
            }
            if(!this.parseCoords[obj.type.toLowerCase()]) {
                throw "Unsupported geometry type: " + obj.type;
            }
            try {
                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
                    this, [obj.coordinates]
                );
            } catch(err) {
                // deal with bad coordinates
                throw err;
            }
        }
        // We don't reproject collections because the children are reprojected
        // for us when they are created.
        if (this.internalProjection && this.externalProjection && !collection) {
            geometry.transform(this.externalProjection, 
                               this.internalProjection); 
        }                       
        return geometry;
    },
    
    /**
     * Property: parseCoords
     * Object with properties corresponding to the GeoJSON geometry types.
     *     Property values are functions that do the actual parsing.
     */
    parseCoords: {
        /**
         * Method: parseCoords.point
         * Convert a coordinate array from GeoJSON into an
         *     <GeoGlobe.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<GeoGlobe.Geometry>} A geometry.
         */
        "point": function(array) {
            if (this.ignoreExtraDims == false && 
                  array.length != 2) {
                    throw "Only 2D points are supported: " + array;
            }
            return new GeoGlobe.Geometry.Point(array[0], array[1]);
        },
        
        /**
         * Method: parseCoords.multipoint
         * Convert a coordinate array from GeoJSON into an
         *     <GeoGlobe.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<GeoGlobe.Geometry>} A geometry.
         */
        "multipoint": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.MultiPoint(points);
        },

        /**
         * Method: parseCoords.linestring
         * Convert a coordinate array from GeoJSON into an
         *     <GeoGlobe.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<GeoGlobe.Geometry>} A geometry.
         */
        "linestring": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.LineString(points);
        },
        
        /**
         * Method: parseCoords.multilinestring
         * Convert a coordinate array from GeoJSON into an
         *     <GeoGlobe.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<GeoGlobe.Geometry>} A geometry.
         */
        "multilinestring": function(array) {
            var lines = [];
            var l = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                lines.push(l);
            }
            return new GeoGlobe.Geometry.MultiLineString(lines);
        },
        
        /**
         * Method: parseCoords.polygon
         * Convert a coordinate array from GeoJSON into an
         *     <GeoGlobe.Geometry>.
         *
         * Returns:
         * {<GeoGlobe.Geometry>} A geometry.
         */
        "polygon": function(array) {
            var rings = [];
            var r, l;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                r = new GeoGlobe.Geometry.LinearRing(l.components);
                rings.push(r);
            }
            return new GeoGlobe.Geometry.Polygon(rings);
        },

        /**
         * Method: parseCoords.multipolygon
         * Convert a coordinate array from GeoJSON into an
         *     <GeoGlobe.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<GeoGlobe.Geometry>} A geometry.
         */
        "multipolygon": function(array) {
            var polys = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["polygon"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                polys.push(p);
            }
            return new GeoGlobe.Geometry.MultiPolygon(polys);
        },

        /**
         * Method: parseCoords.box
         * Convert a coordinate array from GeoJSON into an
         *     <GeoGlobe.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<GeoGlobe.Geometry>} A geometry.
         */
        "box": function(array) {
            if(array.length != 2) {
                throw "GeoJSON box coordinates must have 2 elements";
            }
            return new GeoGlobe.Geometry.Polygon([
                new GeoGlobe.Geometry.LinearRing([
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1])
                ])
            ]);
        }

    },

    /**
     * APIMethod: write
     * Serialize a feature, geometry, array of features into a GeoJSON string.
     *
     * Parameters:
     * obj - {Object} An <GeoGlobe.Feature>, <GeoGlobe.Geometry>,
     *     or an array of features.
     * pretty - {Boolean} Structure the output with newlines and indentation.
     *     Default is false.
     *
     * Returns:
     * {String} The GeoJSON string representation of the input geometry,
     *     features, or array of features.
     */
    write: function(obj, pretty) {
        var geojson = {
            "type": null
        };
        if(GeoGlobe.Util.isArray(obj)) {
            geojson.type = "FeatureCollection";
            var numFeatures = obj.length;
            geojson.features = new Array(numFeatures);
            for(var i=0; i<numFeatures; ++i) {
                var element = obj[i];
                if(!element instanceof GeoGlobe.Feature) {
                    var msg = "FeatureCollection only supports collections " +
                              "of features: " + element;
                    throw msg;
                }
                geojson.features[i] = this.extract.feature.apply(
                    this, [element]
                );
            }
        } else if (obj.CLASS_NAME.indexOf("GeoGlobe.Geometry") == 0) {
            geojson = this.extract.geometry.apply(this, [obj]);
        } else if (obj instanceof GeoGlobe.Feature) {
            geojson = this.extract.feature.apply(this, [obj]);
            if(obj.layer && obj.layer.projection) {
                geojson.crs = this.createCRSObject(obj);
            }
        }
        return GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                            [geojson, pretty]);
    },

    /**
     * Method: createCRSObject
     * Create the CRS object for an object.
     *
     * Parameters:
     * object - {<GeoGlobe.Feature>} 
     *
     * Returns:
     * {Object} An object which can be assigned to the crs property
     * of a GeoJSON object.
     */
    createCRSObject: function(object) {
       var proj = object.layer.projection.toString();
       var crs = {};
       if (proj.match(/epsg:/i)) {
           var code = parseInt(proj.substring(proj.indexOf(":") + 1));
           if (code == 4326) {
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
                   }
               };
           } else {    
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "EPSG:" + code
                   }
               };
           }    
       }
       return crs;
    },
    
    /**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: {
        /**
         * Method: extract.feature
         * Return a partial GeoJSON object representing a single feature.
         *
         * Parameters:
         * feature - {<GeoGlobe.Feature>}
         *
         * Returns:
         * {Object} An object representing the point.
         */
        'feature': function(feature) {
            var geom = this.extract.geometry.apply(this, [feature.geometry]);
            var json = {
                "type": "Feature",
                "properties": feature.attributes,
                "geometry": geom
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },
        
        /**
         * Method: extract.geometry
         * Return a GeoJSON object representing a single geometry.
         *
         * Parameters:
         * geometry - {<GeoGlobe.Geometry>}
         *
         * Returns:
         * {Object} An object representing the geometry.
         */
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            if(geometryType == "Collection") {
                json = {
                    "type": "GeometryCollection",
                    "geometries": data
                };
            } else {
                json = {
                    "type": geometryType,
                    "coordinates": data
                };
            }
            
            return json;
        },

        /**
         * Method: extract.point
         * Return an array of coordinates from a point.
         *
         * Parameters:
         * point - {<GeoGlobe.Geometry.Point>}
         *
         * Returns: 
         * {Array} An array of coordinates representing the point.
         */
        'point': function(point) {
            return [point.x, point.y];
        },

        /**
         * Method: extract.multipoint
         * Return an array of point coordinates from a multipoint.
         *
         * Parameters:
         * multipoint - {<GeoGlobe.Geometry.MultiPoint>}
         *
         * Returns:
         * {Array} An array of point coordinate arrays representing
         *     the multipoint.
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.linestring
         * Return an array of coordinate arrays from a linestring.
         *
         * Parameters:
         * linestring - {<GeoGlobe.Geometry.LineString>}
         *
         * Returns:
         * {Array} An array of coordinate arrays representing
         *     the linestring.
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multilinestring
         * Return an array of linestring arrays from a linestring.
         * 
         * Parameters:
         * multilinestring - {<GeoGlobe.Geometry.MultiLineString>}
         * 
         * Returns:
         * {Array} An array of linestring arrays representing
         *     the multilinestring.
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.polygon
         * Return an array of linear ring arrays from a polygon.
         *
         * Parameters:
         * polygon - {<GeoGlobe.Geometry.Polygon>}
         * 
         * Returns:
         * {Array} An array of linear ring arrays representing the polygon.
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multipolygon
         * Return an array of polygon arrays from a multipolygon.
         * 
         * Parameters:
         * multipolygon - {<GeoGlobe.Geometry.MultiPolygon>}
         * 
         * Returns:
         * {Array} An array of polygon arrays representing
         *     the multipolygon
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.collection
         * Return an array of geometries from a geometry collection.
         * 
         * Parameters:
         * collection - {<GeoGlobe.Geometry.Collection>}
         * 
         * Returns:
         * {Array} An array of geometry objects representing the geometry
         *     collection.
         */
        'collection': function(collection) {
            var len = collection.components.length;
            var array = new Array(len);
            for(var i=0; i<len; ++i) {
                array[i] = this.extract.geometry.apply(
                    this, [collection.components[i]]
                );
            }
            return array;
        }
        

    },

    CLASS_NAME: "GeoGlobe.Format.GeoJSON" 

});     
﻿
/**
 * Class: GeoGlobe.Format.VTS
 * 根据VTS的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建VTS数据源source和图层layer。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.VTS = GeoGlobe.Class4OL({

    /**
     * Constructor: GeoGlobe.Format.VTS
     * GeoGlobe.Format.VTS构造函数。
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },

    getVTSCapabilities: function(url){
        this.url = url;
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.VTSCapabilities.v1_0_0();
                capabilities = format.read(data);
            },
            function(){
                alert("VTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //VTSLayer = new OpenLayers.Layer.VTS({url:url});
            });
        return capabilities;
    },

    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("VTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    //test
    createLayerOption: function(url, capabilities, config){
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;
        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }
        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                        ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }
        var styleName =[];
        if(config.styleName && config.styleName !=""){
            styleName[0] = config.styleName;
        }else{
            this.GetStyleName(function(result){
                styleName = result
            });
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                        (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
            (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink,
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
        /*
         var url;
         if (requestEncoding === "REST" && layerDef.resourceUrls) {
         url = [];
         var resourceUrls = layerDef.resourceUrls,
         resourceUrl;
         for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
         resourceUrl = layerDef.resourceUrls[t];
         if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
         url.push(resourceUrl.template);
         }
         }
         } else {
         var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
         url = [];
         var constraint;
         for (var i = 0, ii = httpGet.length; i < ii; i++) {
         constraint = httpGet[i].constraints;
         if (!constraint || (constraint && constraint.
         GetEncoding.allowedValues[requestEncoding])) {
         url.push(httpGet[i].url);
         }
         }
         }
         */
        resolutions.sort(function(a,b){
            return b-a;
        });

        var vts_url = "";
        var layerOption = {
            "layers":[],
            "source":{},
            "source_id":"",
            "url":"",
            "url_tmpl":"",
            "layerType":"VTS"
        };
        //var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        var param = this.getParameterString({
            "SERVICE": "WMTS",
            "REQUEST": "GetTile",
            "VERSION": capabilities.version,
            "LAYER": layerDef.identifier,
            //"STYLE": style.identifier,
            "TILEMATRIXSET": matrixSet.identifier,
            "FORMAT": "protobuf",
            "TILEMATRIX": "{z}",
            "TILEROW": "{y}",
            "TILECOL": "{x}"
        });
        layerOption.url =url;

        if(url.endsWith("?")){
            vts_url = GeoGlobe.ProxyHost + url + param;
        }else{
            vts_url = GeoGlobe.ProxyHost + url + "?" + param;
        }
        layerOption.url_tmpl =vts_url;
        //vts_url = GeoGlobe.Request.makeSameOrigin(vts_url, GeoGlobe.ProxyHost);
        /*
         var options= GeoGlobe.Util.applyDefaults(config, {
         id:layerDef.identifier,
         url:[vts_url]
         });
         var vtsLayer = new GeoGlobe.Layer.VTS(options);
         vtsLayer.matrixSet = matrixSet;
         */

        var randomNum = GeoGlobe.Util.randomStr(10);
        /*
         var layerOption = {
         source:{
         "id": "source_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "tiles": [vts_url],
         "tileSize": 256
         },
         layers:[{
         "id": "layer_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "source": "source_" + layerDef.identifier + "_" + randomNum,
         "paint": {
         "raster-opacity": 1
         }
         }]
         };
         */

        if(layerDef.bounds){
            var bbox = [layerDef.bounds._sw.lng,layerDef.bounds._sw.lat,layerDef.bounds._ne.lng,layerDef.bounds._ne.lat];
        }else if(layerDef.BoundingBox){
            var bbox = layerDef.BoundingBox[0].bounds.toBBOX();
        }
        var link = layerDef.tileMatrixSetLinks[0].tileMatrixSet;
        var zoomoffset =contents.tileMatrixSets[link].matrixIds[0].identifier;

        this.GetStyle(styleName[0], function(result){
                if(result.sprite){
                    var sprite = GeoGlobe.ProxyHost+result.sprite;
                }else{
                    var sprite = "";
                }
                if(result.glyphs){
                    var glyphs = GeoGlobe.ProxyHost+result.glyphs;
                }else{
                    var glyphs = "";
                }
                //扩展图层的字段
                var metadata = {
                    "name": layerDef.identifier,
                    "sprite":sprite,
                    "glyphs":glyphs,
                    "styleName":result.styleName,
                    "srs": projection,
                    "bbox": bbox,
                    "format":layerDef.formats,
                    "zoomoffset":zoomoffset
                };
                var source_id = "source_vts_"+GeoGlobe.Util.randomStr(6);
                layerOption.source_id = source_id;
                layerOption.source ={
                    "type": "vector",
                    "tiles": [vts_url]
                };
                if(result.styleData){
                    for(var i=0;i<result.styleData.layers.length;i++){
                        result.styleData.layers[i].metadata = metadata;
                        result.styleData.layers[i].source =source_id;
                        layerOption.layers[i] =  result.styleData.layers[i];
                    }
                }else{
                    for(var i=0;i<result.layers.length;i++){
                        result.layers[i].metadata = metadata;
                        result.layers[i].source =source_id;
                        layerOption.layers[i] =  result.layers[i];
                    }
                }

            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });
        //var layerOption = {
        //    "id": "layer_" + layerDef.identifier + "_" + randomNum,
        //    "type": "raster",
        //    "source": {
        //        "type": "raster",
        //        "tiles": [vts_url],
        //        "tileSize": 256
        //    },
        //    "metadata":metadata,
        //    "paint": {
        //        "raster-opacity": 1
        //    }
        //};
        return layerOption;
    },
    /*
     //test
     createLayerOptions: function(url){
     var cap = this.getVTSCapabilities(url);
     var layers = cap.contents.layers;
     var layerOptions = [];
     for(var i = 0; i < layers.length; i++){
     var config = {layer: layers[i].identifier};
     var vtsOpt = this.createLayerOption(url, cap, config);
     layerOptions.push(vtsOpt);
     }
     return layerOptions;
     },
     */
    /**
     * APIMethod: createLayer
     * 获取多个图层信息。
     *
     * Parameters:
     * url - {string} 服务的请求串。
     * options - {object}放置请求的图层名称和样式名称
     * layer - {string}图层名称，若不填，默认第一个
     * styleName - {string} 样式名称，若不填，默认第一个
     */
    createLayer: function(url,options){
        var cap = this.getVTSCapabilities(url);
        options = options ? options : {};
        options.layer = options.layer ? options.layer : cap.contents.layers[0].identifier;
        options.styleName = options.styleName ? options.styleName : "";
        var layerOption = this.createLayerOption(url, cap, options);
        return layerOption;
    },
    /**
     * APIMethod: createLayers
     * 获取多个图层信息。
     *
     * Parameters:
     * url - {string} 服务的请求串。
     */
    createLayers: function(url){
        var cap = this.getVTSCapabilities(url);
        var layers = cap.contents.layers;
        var layerOptions = [];
        for(var i = 0; i < layers.length; i++){
            var config = {layer: layers[i].identifier};
            var vtsOpt = this.createLayerOption(url, cap, config);
            layerOptions.push(vtsOpt);
        }
        return layerOptions;
    },

    /**
     * APIMethod: GetStyleName
     * 获取样式名称。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    GetStyleName: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                var styleName =[];
                if(geojson.style){
                    for(var n =0;n <geojson.style.length;n++){
                        styleName.push(geojson.style[n].styleName);
                    }
                }else if(geojson.styleName){
                    for(var s = 0; s < geojson.styleName.length;s++){
                        styleName.push(geojson.styleName[s]);
                    }
                }

                //var style = geojson.style[0];
                successFn(styleName);
            },
            failure: failFn
        });
    },
    /**
     * APIMethod: GetStyle
     * 获取样式数据（用json描述）。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    GetStyle: function(styleName,successFn, failFn){
        var url = this.url;
        if(styleName =="" || styleName == undefined){
            alert("请查看样式名称是否存在");
            return ;
        }
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0",
            STYLENAME:styleName
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var style = jformat.read(obj);
                //var style = geojson.style[0];
                successFn(style);
            },
            failure: failFn
        });
    },

    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },

    CLASS_NAME: "GeoGlobe.Format.VTS"
});
/**
 * Class: GeoGlobe.Format.WMTS
 * 根据wmts的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMTS数据源source和图层layer。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.WMTS = GeoGlobe.Class4OL({

    /**
     * Constructor: GeoGlobe.Format.WMTS
     * GeoGlobe.Format.WMTS构造函数。
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },

    getWMTSCapabilities: function(url){
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.WMTSCapabilities.v1_0_0();
                capabilities = format.read(data);
            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });
        return capabilities;
    },

    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    //test
    createLayerOption: function(url, capabilities, config){
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;
        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
			for (var i = 0; i<layerDef.formats.length; i++) {
				if(layerDef.formats[i] == "image/png"){
					format = layerDef.formats[i];
					break;
				}
			}
            format = format ? format: layerDef.formats[0];
        }
        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                        ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                        (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
            (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
        /*
         var url;
         if (requestEncoding === "REST" && layerDef.resourceUrls) {
         url = [];
         var resourceUrls = layerDef.resourceUrls,
         resourceUrl;
         for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
         resourceUrl = layerDef.resourceUrls[t];
         if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
         url.push(resourceUrl.template);
         }
         }
         } else {
         var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
         url = [];
         var constraint;
         for (var i = 0, ii = httpGet.length; i < ii; i++) {
         constraint = httpGet[i].constraints;
         if (!constraint || (constraint && constraint.
         GetEncoding.allowedValues[requestEncoding])) {
         url.push(httpGet[i].url);
         }
         }
         }
         */
        resolutions.sort(function(a,b){
            return b-a;
        });

        var wmts_url = "";
        //var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        var param = this.getParameterString({
            "SERVICE": "WMTS",
            "REQUEST": "GetTile",
            "VERSION": capabilities.version,
            "LAYER": layerDef.identifier,
            "STYLE": style.identifier,
            "TILEMATRIXSET": matrixSet.identifier,
            "FORMAT": format,
            "TILEMATRIX": "{z}",
            "TILEROW": "{y}",
            "TILECOL": "{x}"
        });
        if(url.endsWith("?")){
            wmts_url = GeoGlobe.ProxyHost + url + param;
        }else{
            wmts_url = GeoGlobe.ProxyHost + url + "?" + param;
        }
        //wmts_url = GeoGlobe.Request.makeSameOrigin(wmts_url, GeoGlobe.ProxyHost);
        /*
         var options= GeoGlobe.Util.applyDefaults(config, {
         id:layerDef.identifier,
         url:[wmts_url]
         });
         var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
         wmtsLayer.matrixSet = matrixSet;
         */

        var randomNum = GeoGlobe.Util.randomStr(10);
        /*
         var layerOption = {
         source:{
         "id": "source_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "tiles": [wmts_url],
         "tileSize": 256
         },
         layers:[{
         "id": "layer_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "source": "source_" + layerDef.identifier + "_" + randomNum,
         "paint": {
         "raster-opacity": 1
         }
         }]
         };
         */
/**
        if(layerDef.bounds){
            var bbox = [layerDef.bounds._sw.lng,layerDef.bounds._sw.lat,layerDef.bounds._ne.lng,layerDef.bounds._ne.lat];

        }
		*/
		   if(layerDef.bounds){
            var bbox = [layerDef.bounds._sw.lng,layerDef.bounds._sw.lat,layerDef.bounds._ne.lng,layerDef.bounds._ne.lat];
        }else if(layerDef.BoundingBox){
            var bbox = layerDef.BoundingBox[0].bounds.toBBOX();
        }
        var link = layerDef.tileMatrixSetLinks[0].tileMatrixSet;
        var zoomoffset =contents.tileMatrixSets[link].matrixIds[0].identifier;
        //扩展图层的字段
        var metadata = {
            "name": layerDef.identifier,
            "srs": projection,
            "bbox": bbox,
            "format":layerDef.formats,
            "zoomoffset":zoomoffset
        };
        var layerOption = {
            "id": "layer_" + layerDef.identifier + "_" + randomNum,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [wmts_url],
                "tileSize": 256
            },
            "metadata":metadata,
            "paint": {
                "raster-opacity": 1
            }
        };
        return layerOption;
    },
    /*
     //test
     createLayerOptions: function(url){
     var cap = this.getWMTSCapabilities(url);
     var layers = cap.contents.layers;
     var layerOptions = [];
     for(var i = 0; i < layers.length; i++){
     var config = {layer: layers[i].identifier};
     var wmtsOpt = this.createLayerOption(url, cap, config);
     layerOptions.push(wmtsOpt);
     }
     return layerOptions;
     },
     */
    //test
    createLayer: function(url,options){
        var cap = this.getWMTSCapabilities(url);
		options = options ? options : {};
        options.layer = options.layer ? options.layer : cap.contents.layers[0].identifier;
        var layerOption = this.createLayerOption(url, cap, options);
        return layerOption;
    },
    createLayers: function(url){
        var cap = this.getWMTSCapabilities(url);
        var layers = cap.contents.layers;
        var layerOptions = [];
        for(var i = 0; i < layers.length; i++){
            var config = {layer: layers[i].identifier};
            var wmtsOpt = this.createLayerOption(url, cap, config);
            layerOptions.push(wmtsOpt);
        }
        return layerOptions;
    },


    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },

    CLASS_NAME: "GeoGlobe.Format.WMTS"
});
﻿/**
 * Class: GeoGlobe.Format.WMS
 * 根据wms的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMS数据源source和图层layer。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.WMS = GeoGlobe.Class4OL({

    /**
     * Constructor: GeoGlobe.Format.WMS
     * GeoGlobe.Format.WMS构造函数。
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },

    getWMSCapabilities: function(url){
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.WMSCapabilities.v1_1_1();
                capabilities = format.read(data);
            },
            function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmsLayer = new OpenLayers.Layer.WMS({url:url});
            });
        return capabilities;
    },

    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMS",
            VERSION:"1.1.1"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
    //test
    createLayerOption: function(url, capabilities, config){
        var layer;
        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }
        var contents = capabilities.capability;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].name === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            for(var f = 0; f < layerDef.formats.length; f++){
                if(layerDef.formats[f] == "image/png"){
                    format = layerDef.formats[f];
                }
            }
            if(format !="image/png"){
                format = layerDef.formats[0];
            }
        }

        var styles = config.styles;
        if (!styles && layerDef.styles && layerDef.styles.length) {
            styles = layerDef.styles[0].name;
        }

        var srs = eval(layerDef.srs);
        var SRS;
        for(var o in srs){
            SRS = o;
        }

        var wms_url = "";
        //var param = "SERVICE=WMS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        if(config.isTile){
            var param = this.getParameterString({
                "SERVICE": "WMS",
                "REQUEST": "GetMap",
                "VERSION": "1.1.1",
                "LAYERS": layerDef.name,
                "styles":styles,
                "FORMAT": format,
 		"TRANSPARENT":true,
                "BBOX": "{bbox-epsg-3857}",
                "WIDTH": "256",
                "HEIGHT": "256",
                "SRS":SRS
            });
            if(url.endsWith("?")){
                wms_url = url + param;
            }else{
                wms_url = url + "?" + param;
            }
            wms_url = GeoGlobe.appendToProxy(wms_url);
            //wms_url = GeoGlobe.Request.makeSameOrigin(wms_url, GeoGlobe.ProxyHost);
            /*
             var options= GeoGlobe.Util.applyDefaults(config, {
             id:layerDef.identifier,
             url:[wms_url]
             });
             var wmsLayer = new GeoGlobe.Layer.WMS(options);
             wmsLayer.matrixSet = matrixSet;
             */

            var randomNum = GeoGlobe.Util.randomStr(10);
            /*
             var layerOption = {
             source:{
             "id": "source_" + layerDef.identifier + "_" + randomNum,
             "type": "raster",
             "tiles": [wms_url],
             "tileSize": 256
             },
             layers:[{
             "id": "layer_" + layerDef.identifier + "_" + randomNum,
             "type": "raster",
             "source": "source_" + layerDef.identifier + "_" + randomNum,
             "paint": {
             "raster-opacity": 1
             }
             }]
             };
             */
            //扩展图层的字段
            var metadata = {
                "name": layerDef.name,
                "srs": SRS,
                "bbox": layerDef.bbox,
                "format":format
            };
            var layerOption = {
                "id": "layer_" + layerDef.name + "_" + randomNum,
                "type": "raster",
                "source": {
                    "type": "raster",
                    "tiles": [wms_url],
                    "tileSize": 256
                },
                "metadata":metadata,
                "paint": {
                    "raster-opacity": 1
                }
            };
            return layerOption;
        }else{

            //根据参数添加wmts图层
             layerOption = new GeoGlobe.Layer.WMS({
                url: url,//地址
                layer: layerDef.name,//图层标识
                format: format,//格式
                version:"1.1.1",
//        tileSize: 256,
                SRS:SRS,
                 styles:styles,
                bbox:layerDef.bbox ,//图层范围
                isTile:false
            });
            return layerOption;

        }

    },
    /*
     //test
     createLayerOptions: function(url){
     var cap = this.getWMSCapabilities(url);
     var layers = cap.contents.layers;
     var layerOptions = [];
     for(var i = 0; i < layers.length; i++){
     var config = {layer: layers[i].identifier};
     var wmsOpt = this.createLayerOption(url, cap, config);
     layerOptions.push(wmsOpt);
     }
     return layerOptions;
     },
     */
    //test
    createLayer: function(url,options,isTile){
        this.url = url;
        isTile = (isTile === undefined || isTile) ? true : false;
        var cap = this.getWMSCapabilities(url);
        var layer = (options && options.layer) ? options.layer : cap.capability.layers[0].name;
        var config = {layer: layer,isTile:isTile};
        var layerOption = this.createLayerOption(url, cap, config);
        return layerOption;


    },
    createLayers: function(url, options){
        isTile = (isTile === undefined || isTile) ? true : false;
        if(isTile){
            var cap = this.getWMSCapabilities(url);
            var layers = cap.capability.layers;
            var layerOptions = [];
            for(var i = 0; i < layers.length; i++){
                var config = {
					layer: layers[i].name,
					transparent: options.transparent === false ? options.transparent : true
				};
                var wmsOpt = this.createLayerOption(url, cap, config);
                layerOptions.push(wmsOpt);
            }
            return layerOptions;
        }
    },

    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },

    CLASS_NAME: "GeoGlobe.Format.WMS"
});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML/VersionedOGC.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities
 * Read WMS Capabilities.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML.VersionedOGC>
 */
GeoGlobe.Format.WMSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.1".
     */
    defaultVersion: "1.1.1",
    
    /**
     * APIProperty: profile
     * {String} If provided, use a custom profile.
     *
     * Currently supported profiles:
     * - WMSC - parses vendor specific capabilities for WMS-C.
     */
    profile: null,
    
    /**
     * Constructor: GeoGlobe.Format.WMSCapabilities
     * Create a new parser for WMS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMSCapabilities.js
 * @requires GeoGlobe/Format/OGCExceptionReport.js
 * @requires GeoGlobe/Format/XML.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities.v1
 * Abstract class not to be instantiated directly. Creates
 * the common parts for both WMS 1.1.X and WMS 1.3.X.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.WMSCapabilities.v1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        wms: "http://www.opengis.net/wms",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wms",
    
    /**
     * Constructor: GeoGlobe.Format.WMSCapabilities.v1
     * Create an instance of one of the subclasses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        if (capabilities.service === undefined) {
            // an exception must have occurred, so parse it
            var parser = new GeoGlobe.Format.OGCExceptionReport();
            capabilities.error = parser.read(raw);
        }
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": {
            "Service": function(node, obj) {
                obj.service = {};
                this.readChildNodes(node, obj.service);
            },
            "Name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, obj) {
                obj["abstract"] = this.getChildValue(node);
            },
            "BoundingBox": function(node, obj) {
                var bbox = {};
                bbox.bbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
                var res = {
                    x: parseFloat(node.getAttribute("resx")),
                    y: parseFloat(node.getAttribute("resy"))
                };

                if (! (isNaN(res.x) && isNaN(res.y))) {
                    bbox.res = res;
                }
                // return the bbox so that descendant classes can set the
                // CRS and SRS and add it to the obj
                return bbox;
            },
            "OnlineResource": function(node, obj) {
                obj.href = this.getAttributeNS(node, this.namespaces.xlink, 
                    "href");
            },
            "ContactInformation": function(node, obj) {
                obj.contactInformation = {};
                this.readChildNodes(node, obj.contactInformation);
            },
            "ContactPersonPrimary": function(node, obj) {
                obj.personPrimary = {};
                this.readChildNodes(node, obj.personPrimary);
            },
            "ContactPerson": function(node, obj) {
                obj.person = this.getChildValue(node);
            },
            "ContactOrganization": function(node, obj) {
                obj.organization = this.getChildValue(node);
            },
            "ContactPosition": function(node, obj) {
                obj.position = this.getChildValue(node);
            },
            "ContactAddress": function(node, obj) {
                obj.contactAddress = {};
                this.readChildNodes(node, obj.contactAddress);
            },
            "AddressType": function(node, obj) {
                obj.type = this.getChildValue(node);
            },
            "Address": function(node, obj) {
                obj.address = this.getChildValue(node);
            },
            "City": function(node, obj) {
                obj.city = this.getChildValue(node);
            },
            "StateOrProvince": function(node, obj) {
                obj.stateOrProvince = this.getChildValue(node);
            },
            "PostCode": function(node, obj) {
                obj.postcode = this.getChildValue(node);
            },
            "Country": function(node, obj) {
                obj.country = this.getChildValue(node);
            },
            "ContactVoiceTelephone": function(node, obj) {
                obj.phone = this.getChildValue(node);
            },
            "ContactFacsimileTelephone": function(node, obj) {
                obj.fax = this.getChildValue(node);
            },
            "ContactElectronicMailAddress": function(node, obj) {
                obj.email = this.getChildValue(node);
            },
            "Fees": function(node, obj) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    obj.fees = fees;
                }
            },
            "AccessConstraints": function(node, obj) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    obj.accessConstraints = constraints;
                }
            },
            "Capability": function(node, obj) {
                obj.capability = {
                    nestedLayers: [],
                    layers: []
                };
                this.readChildNodes(node, obj.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetCapabilities": function(node, obj) {
                obj.getcapabilities = {formats: []};
                this.readChildNodes(node, obj.getcapabilities);
            },
            "Format": function(node, obj) {
                if (GeoGlobe.Util.isArray(obj.formats)) {
                    obj.formats.push(this.getChildValue(node));
                } else {
                    obj.format = this.getChildValue(node);
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Get": function(node, obj) {
                obj.get = {};
                this.readChildNodes(node, obj.get);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "Post": function(node, obj) {
                obj.post = {};
                this.readChildNodes(node, obj.post);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "GetMap": function(node, obj) {
                obj.getmap = {formats: []};
                this.readChildNodes(node, obj.getmap);
            },
            "GetFeatureInfo": function(node, obj) {
                obj.getfeatureinfo = {formats: []};
                this.readChildNodes(node, obj.getfeatureinfo);
            },
            "Exception": function(node, obj) {
                obj.exception = {formats: []};
                this.readChildNodes(node, obj.exception);
            },
            "Layer": function(node, obj) {
                var parentLayer, capability;
                if (obj.capability) {
                    capability = obj.capability;
                    parentLayer = obj;
                } else {
                    capability = obj;
                }
                var attrNode = node.getAttributeNode("queryable");
                var queryable = (attrNode && attrNode.specified) ? 
                    node.getAttribute("queryable") : null;
                attrNode = node.getAttributeNode("cascaded");
                var cascaded = (attrNode && attrNode.specified) ?
                    node.getAttribute("cascaded") : null;
                attrNode = node.getAttributeNode("opaque");
                var opaque = (attrNode && attrNode.specified) ?
                    node.getAttribute('opaque') : null;
                var noSubsets = node.getAttribute('noSubsets');
                var fixedWidth = node.getAttribute('fixedWidth');
                var fixedHeight = node.getAttribute('fixedHeight');
                var parent = parentLayer || {},
                    extend = GeoGlobe.Util.extend;
                var layer = {
                    nestedLayers: [],
                    styles: parentLayer ? [].concat(parentLayer.styles) : [],
                    srs: parentLayer ? extend({}, parent.srs) : {}, 
                    metadataURLs: [],
                    bbox: parentLayer ? extend({}, parent.bbox) : {},
                    llbbox: parent.llbbox,
                    dimensions: parentLayer ? extend({}, parent.dimensions) : {},
                    authorityURLs: parentLayer ? extend({}, parent.authorityURLs) : {},
                    identifiers: {},
                    keywords: [],
                    queryable: (queryable && queryable !== "") ? 
                        (queryable === "1" || queryable === "true" ) :
                        (parent.queryable || false),
                    cascaded: (cascaded !== null) ? parseInt(cascaded) :
                        (parent.cascaded || 0),
                    opaque: opaque ? 
                        (opaque === "1" || opaque === "true" ) :
                        (parent.opaque || false),
                    noSubsets: (noSubsets !== null) ? 
                        (noSubsets === "1" || noSubsets === "true" ) :
                        (parent.noSubsets || false),
                    fixedWidth: (fixedWidth != null) ? 
                        parseInt(fixedWidth) : (parent.fixedWidth || 0),
                    fixedHeight: (fixedHeight != null) ? 
                        parseInt(fixedHeight) : (parent.fixedHeight || 0),
                    minScale: parent.minScale,
                    maxScale: parent.maxScale,
                    attribution: parent.attribution
                };
                obj.nestedLayers.push(layer);
                layer.capability = capability;
                this.readChildNodes(node, layer);
                delete layer.capability;
                if(layer.name) {
                    var parts = layer.name.split(":"),
                        request = capability.request,
                        gfi = request.getfeatureinfo;
                    if(parts.length > 0) {
                        layer.prefix = parts[0];
                    }
                    capability.layers.push(layer);
                    if (layer.formats === undefined) {
                        layer.formats = request.getmap.formats;
                    }
                    if (layer.infoFormats === undefined && gfi) {
                        layer.infoFormats = gfi.formats;
                    }
                }
            },
            "Attribution": function(node, obj) {
                obj.attribution = {};
                this.readChildNodes(node, obj.attribution);
            },
            "LogoURL": function(node, obj) {
                obj.logo = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                this.readChildNodes(node, obj.logo);
            },
            "Style": function(node, obj) {
                var style = {};
                obj.styles.push(style);
                this.readChildNodes(node, style);
            },
            "LegendURL": function(node, obj) {
                var legend = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                obj.legend = legend;
                this.readChildNodes(node, legend);
            },
            "MetadataURL": function(node, obj) {
                var metadataURL = {type: node.getAttribute("type")};
                obj.metadataURLs.push(metadataURL);
                this.readChildNodes(node, metadataURL);
            },
            "DataURL": function(node, obj) {
                obj.dataURL = {};
                this.readChildNodes(node, obj.dataURL);
            },
            "FeatureListURL": function(node, obj) {
                obj.featureListURL = {};
                this.readChildNodes(node, obj.featureListURL);
            },
            "AuthorityURL": function(node, obj) {
                var name = node.getAttribute("name");
                var authority = {};
                this.readChildNodes(node, authority);
                obj.authorityURLs[name] = authority.href;
            },
            "Identifier": function(node, obj) {
                var authority = node.getAttribute("authority");
                obj.identifiers[authority] = this.getChildValue(node);
            },
            "KeywordList": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMSCapabilities/v1.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities.v1_1
 * Abstract class not to be instantiated directly.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WMSCapabilities.v1>
 */
GeoGlobe.Format.WMSCapabilities.v1_1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1, {
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "WMT_MS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Keyword": function(node, obj) {
                if (obj.keywords) {
                    obj.keywords.push(this.getChildValue(node));
                }
            },
            "DescribeLayer": function(node, obj) {
                obj.describelayer = {formats: []};
                this.readChildNodes(node, obj.describelayer);
            },
            "GetLegendGraphic": function(node, obj) {
                obj.getlegendgraphic = {formats: []};
                this.readChildNodes(node, obj.getlegendgraphic);
            },
            "GetStyles": function(node, obj) {
                obj.getstyles = {formats: []};
                this.readChildNodes(node, obj.getstyles);
            },
            "PutStyles": function(node, obj) {
                obj.putstyles = {formats: []};
                this.readChildNodes(node, obj.putstyles);
            },
            "UserDefinedSymbolization": function(node, obj) {
                var userSymbols = {
                    supportSLD: parseInt(node.getAttribute("SupportSLD")) == 1,
                    userLayer: parseInt(node.getAttribute("UserLayer")) == 1,
                    userStyle: parseInt(node.getAttribute("UserStyle")) == 1,
                    remoteWFS: parseInt(node.getAttribute("RemoteWFS")) == 1
                };
                obj.userSymbols = userSymbols;
            },
            "LatLonBoundingBox": function(node, obj) {
                obj.llbbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
            },
            "BoundingBox": function(node, obj) {
                var bbox = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("SRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "ScaleHint": function(node, obj) {
                var min = node.getAttribute("min");
                var max = node.getAttribute("max");
                var rad2 = Math.pow(2, 0.5);
                var ipm = GeoGlobe.INCHES_PER_UNIT["m"];
                if (min != 0) {
                    obj.maxScale = parseFloat(
                        ((min / rad2) * ipm * 
                            GeoGlobe.DOTS_PER_INCH).toPrecision(13)
                    );
                }
                if (max != Number.POSITIVE_INFINITY) {
                    obj.minScale = parseFloat(
                        ((max / rad2) * ipm * 
                            GeoGlobe.DOTS_PER_INCH).toPrecision(13)
                    );
                }
            },
            "Dimension": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol")
                };
                obj.dimensions[dim.name] = dim;
            },
            "Extent": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                if (name in obj["dimensions"]) {
                    var extent = obj.dimensions[name];
                    extent.nearestVal = 
                        node.getAttribute("nearestValue") === "1";
                    extent.multipleVal = 
                        node.getAttribute("multipleValues") === "1";
                    extent.current = node.getAttribute("current") === "1";
                    extent["default"] = node.getAttribute("default") || "";
                    var values = this.getChildValue(node);
                    extent.values = values.split(",");
                }
                }
        }, GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMSCapabilities/v1_1.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities/v1_1_0
 * Read WMS Capabilities version 1.1.0.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WMSCapabilities.v1_1>
 */
GeoGlobe.Format.WMSCapabilities.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.1.0",
    
    /**
     * Constructor: GeoGlobe.Format.WMSCapabilities.v1_1_0
     * Create a new parser for WMS capabilities version 1.1.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                var values = srs.split(/ +/);
                for (var i=0, len=values.length; i<len; i++) {
                    obj.srs[values[i]] = true;
                }
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_0" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMSCapabilities/v1_1.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities/v1_1_1
 * Read WMS Capabilities version 1.1.1.
 *
 * Note on <ScaleHint> parsing: If the 'min' attribute is set to "0", no
 * maxScale will be set on the layer object. If the 'max' attribute is set to
 * "Infinity", no minScale will be set. This makes it easy to create proper
 * {<GeoGlobe.Layer.WMS>} configurations directly from the layer object
 * literals returned by this format, because no minScale/maxScale modifications
 * need to be made.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WMSCapabilities.v1_1>
 */
GeoGlobe.Format.WMSCapabilities.v1_1_1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.1.1",
    
    /**
     * Constructor: GeoGlobe.Format.WMSCapabilities.v1_1_1
     * Create a new parser for WMS capabilities version 1.1.1.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMSCapabilities/v1_1_1.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities/v1_1_1_WMSC
 * Read WMS-C Capabilities version 1.1.1.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WMSCapabilities.v1_1_1>
 */
GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1_1, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.1.1",
    
    /**
     * Property: profile
     * {String} The specific profile
     */
    profile: "WMSC",
    
    /**
     * Constructor: GeoGlobe.Format.WMSCapabilities.v1_1_1
     * Create a new parser for WMS-C capabilities version 1.1.1.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "VendorSpecificCapabilities": function(node, obj) {
                obj.vendorSpecific = {tileSets: []};
                this.readChildNodes(node, obj.vendorSpecific);
            },
            "TileSet": function(node, vendorSpecific) {
                var tileset = {srs: {}, bbox: {}, resolutions: []};
                this.readChildNodes(node, tileset);
                vendorSpecific.tileSets.push(tileset);
            },
            "Resolutions": function(node, tileset) {
                var res = this.getChildValue(node).split(" ");
                for (var i=0, len=res.length; i<len; i++) {
                    if (res[i] != "") {
                        tileset.resolutions.push(parseFloat(res[i]));
                    }
                }
            },
            "Width": function(node, tileset) {
                tileset.width = parseInt(this.getChildValue(node));
            },
            "Height": function(node, tileset) {
                tileset.height = parseInt(this.getChildValue(node));
            },
            "Layers": function(node, tileset) {
                tileset.layers = this.getChildValue(node);
            },
            "Styles": function(node, tileset) {
                tileset.styles = this.getChildValue(node);
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMSCapabilities/v1.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities/v1_3
 * Abstract base class for WMS Capabilities version 1.3.X. 
 * SLD 1.1.0 adds in the extra operations DescribeLayer and GetLegendGraphic, 
 * see: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WMSCapabilities.v1>
 */
GeoGlobe.Format.WMSCapabilities.v1_3 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1, {
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "WMS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LayerLimit": function(node, obj) {
                obj.layerLimit = parseInt(this.getChildValue(node));
            },
            "MaxWidth": function(node, obj) {
                obj.maxWidth = parseInt(this.getChildValue(node));
            },
            "MaxHeight": function(node, obj) {
                obj.maxHeight = parseInt(this.getChildValue(node));
            },
            "BoundingBox": function(node, obj) {
                var bbox = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("CRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "CRS": function(node, obj) {
                // CRS is the synonym of SRS
                this.readers.wms.SRS.apply(this, [node, obj]); 
            },
            "EX_GeographicBoundingBox": function(node, obj) {
                // replacement of LatLonBoundingBox
                obj.llbbox = [];
                this.readChildNodes(node, obj.llbbox);
                
            },
            "westBoundLongitude": function(node, obj) {
                obj[0] = this.getChildValue(node);
            },
            "eastBoundLongitude": function(node, obj) {
                obj[2] = this.getChildValue(node);
            },
            "southBoundLatitude": function(node, obj) {
                obj[1] = this.getChildValue(node);
            },
            "northBoundLatitude": function(node, obj) {
                obj[3] = this.getChildValue(node);
            },
            "MinScaleDenominator": function(node, obj) {
                obj.maxScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "MaxScaleDenominator": function(node, obj) {
                obj.minScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "Dimension": function(node, obj) {
                // dimension has extra attributes: default, multipleValues, 
                // nearestValue, current which used to be part of Extent. It now
                // also contains the values.
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol"),
                    nearestVal: node.getAttribute("nearestValue") === "1",
                    multipleVal: node.getAttribute("multipleValues") === "1",
                    "default": node.getAttribute("default") || "",
                    current: node.getAttribute("current") === "1",
                    values: this.getChildValue(node).split(",")
                    
                };
                // Theoretically there can be more dimensions with the same
                // name, but with a different unit. Until we meet such a case,
                // let's just keep the same structure as the WMS 1.1 
                // GetCapabilities parser uses. We will store the last
                // one encountered.
                obj.dimensions[dim.name] = dim;
            },
            "Keyword": function(node, obj) {
                // TODO: should we change the structure of keyword in v1.js?
                // Make it an object with a value instead of a string?
                var keyword = {value: this.getChildValue(node), 
                    vocabulary: node.getAttribute("vocabulary")};
                if (obj.keywords) {
                    obj.keywords.push(keyword);
                }
            }
        }, GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"]),
        "sld": {
            "UserDefinedSymbolization": function(node, obj) {
                this.readers.wms.UserDefinedSymbolization.apply(this, [node, obj]);
                // add the two extra attributes
                obj.userSymbols.inlineFeature = parseInt(node.getAttribute("InlineFeature")) == 1;
                obj.userSymbols.remoteWCS = parseInt(node.getAttribute("RemoteWCS")) == 1;
            },
            "DescribeLayer": function(node, obj) {
                this.readers.wms.DescribeLayer.apply(this, [node, obj]);
            },
            "GetLegendGraphic": function(node, obj) {
                this.readers.wms.GetLegendGraphic.apply(this, [node, obj]);
            }
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3" 

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMSCapabilities/v1_3.js
 */

/**
 * Class: GeoGlobe.Format.WMSCapabilities/v1_3_0
 * Read WMS Capabilities version 1.3.0. 
 * SLD 1.1.0 adds in the extra operations DescribeLayer and GetLegendGraphic, 
 * see: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WMSCapabilities.v1_3>
 */
GeoGlobe.Format.WMSCapabilities.v1_3_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_3, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.3.0",
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3_0" 

});
/**
 * Class: GeoGlobe.Format.WMSUtil
 * 根据wms的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMS图层。
 */
GeoGlobe.Format.WMSUtil = GeoGlobe.Class4OL({

    /**
     * Constructor: GeoGlobe.Format.WMSUtil
     * GeoGlobe.Format.WMSUtil构造函数。
     */
    initialize: function(options){
		GeoGlobe.Util.extend(this, options);
    },
    
    getWMSCapabilities: function(url, config){
        var flag = true;
		var capabilities = null;
        this.getCapabilities(url, config,
		GeoGlobe.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
			if(data == null || data == ""){
            	this.failFn(url);
            	flag = false;
            	return;
            }
            var format = new GeoGlobe.Format.WMSCapabilities();
            capabilities = format.read(data);
        }, this),
		function(){
            alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        if(flag){
        	return capabilities;
        }
    },
    
    /**
     * APIMethod: createLayer
     * 根据url创建WMS图层对象。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得图层配置参数，最后生成WMS图层对象。
     * 如果wms服务中含有多个图层配置信息，可设置config中属性layer为对应图层name的值，即取该图层的配置参数，生成WMS图层对象。
     * 如不设置config中属性layer，则默认取第一个图层的配置参数生成WMS图层对象。
     * 
     * Parameters:
     * url - {String} WMS服务地址。
     * config - {Object} 可选。图层的配置参数。
     * 
     * Returns:
     * {<Geo.View2D.Layer.WMS>} 一个WMS图层对象。
     */
    createLayer: function(url, config){
        var flag = true;
		var wmsLayer = null;
        this.getCapabilities(url, config,
		GeoGlobe.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
			if(data == null || data == ""){
            	this.failFn(url);
            	flag = false;
            	return;
            }
            var format = new GeoGlobe.Format.WMSCapabilities();
            var capabilities = format.read(data);
            wmsLayer = this._createLayer(url,capabilities, config, "2D");
        }, this),
		function(){
            alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        if(flag){
        	return wmsLayer;
        }
    },
    
	failFn: function(url){
        alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
    },
	
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(url, config, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMS",
            VERSION: (config ? config.version : null) ? config.version : "1.1.1"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n版本号：" + params[VERSION] + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
    /**
     * Method: _createLayer
     * 根据capabilities信息创建WMS图层对象。
     *
     * Parameters:
     * capabilities - {Object} capabilities信息。可用GeoGlobe.Format.WMSCapabilities.v1_0_0解析器调用<read>方法返回capabilities信息。
     * config - {Object} 可选。图层的配置参数。
     *
     * Returns:
     * {<Geo.View2D.Layer.WMS>} 一个WMS图层对象。
     */
    _createLayer: function(url, capabilities, config, mapType){
		//config不存在，则赋值为空的对象
		if(!config){
			config = {};
		}
		if(!mapType){
			mapType = "2D";
		}
		
		var capability = capabilities.capability;
		
		// find the layer definition with the given identifier
        var layers = capability.layers;
        var layerDef;
		//默认取第一个图层
		layerDef = capability.layers[0];
		//如果有设置图层名，则取图层名对应的图层数据
        for (var i = 0, ii = capability.layers.length; i < ii; ++i) {
			if (capability.layers[i].name === config.layer) {
				layerDef = capability.layers[i];
				break;
			}
		}
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        // format 例如tiles
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length>0) {
            format = layerDef.formats[0];
        }

        // transparent
        var transparent = config.transparent;
        if(!transparent || transparent==""){
        	transparent = true;
        }
        
		// name
        var name;;
        if (layerDef.name) {
            name = layerDef.name;
        }
        
        // version
        var version = config.version;
        if (!version && capabilities.version) {
        	version = capabilities.version;
        }
        
        // projection
        var projection = config.srs;
        if (!projection && layerDef.srs) {
        	for(var k in layerDef.srs){
        		projection = k;
        	}
        }
        if(projection == "EPSG:-9999"){
        	projection = "EPSG:4326";
        }
        // maxExtent
        var maxExtent = config.llbbox;
        if (!maxExtent && layerDef.llbbox && layerDef.llbbox.length>0) {
            maxExtent = layerDef.llbbox[0]+","+layerDef.llbbox[1]+","+layerDef.llbbox[2]+","+layerDef.llbbox[3];
        }
		var bounds = GeoGlobe.LngLatBounds.fromArray(layerDef.llbbox);
		
        var param = "SERVICE=WMS&REQUEST=GetMap&VERSION="+version+"&LAYERS="+name+"&styles=default&CRS=EPSG:3857&BBOX={bbox-epsg-3857}&WIDTH=256&HEIGHT=256&SRS="+projection+"&FORMAT="+format+"&TRANSPARENT="+transparent;
        var wmsUrl = null;
        if(url.endsWith("?")){
			wmts_url = url + param;
		}else{
			wmts_url = url + "?" + param;
		}
		return {
			url: wmts_url,
			version: version,
			name: name,
			projection: projection,
			format: format,
			bounds: bounds,
			transparent: transparent
		};
        /*
		switch(mapType){
			case "2D":
				var wmsLayer = new Geo.View2D.Layer.WMS(
		             "WMS",//服务名称   
		             url,//服务地址
		             {   
		             	//服务版本
			            version: version,
			            //图层标识，从服务的getCapabilities描述信息获取
			            layers: name,  
			            //数据格式
			            format: format, 
			            //图层背景是否透明，true表示透明   
			            transparent: transparent  
		             },   
		             {   
		                //图层最大范围   
		                maxExtent: Geo.Bounds.fromString(maxExtent),
		                //投影
		                projection: projection,  
		                //坐标轴顺序,false表示经度、纬度的顺序，true表示纬度、经度的顺序   
		                isReverse: true
		             }   
		         );   
		        return wmsLayer;
				break;
			case "3D":
				var serviceObj = new Geo.Service.WMS("wms", url);
				var wms3dlayer;
            	var wms3dlayer = new Geo.View3D.Layer.WMS(
				"wms", //服务名称 
				url,//服务地址
          		{
            		//服务版本
	           		version: version,
            		//图层标识，从服务的getCapabilities描述信息获取
	            	layers: name, 
				    //数据格式
	            	format: format,
	            	//请求的瓦片背景区域是否透明,默认：TRUE	
				    transparent: transparent            		
            	},
            	{
            		//图层透明度设置，可以设置：0-1，默认：1
            		opacity : 1,
            		//当前图层使用的投影
            		projection: projection,
            		//瓦片宽度，瓦片高度，默认：256，256
            		//tileSize: new Geo.Size(256,256),
					//图层最大范围   
                	maxExtent: Geo.Bounds.fromString(maxExtent)	
				});
				return wms3dlayer;
				break;
		}
		*/
    },
    
    CLASS_NAME: "GeoGlobe.Format.WMSUtil"
});
/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML/VersionedOGC.js
 */

/**
 * Class: GeoGlobe.Format.VTSCapabilities
 * Read VTS Capabilities.
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML.VersionedOGC>
 */
GeoGlobe.Format.VTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",

    /**
     * APIProperty: yx
     * {Object} Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  By default, the following CRS URN are
     *     assumed to correspond to a CRS with y,x axis order:
     *
     * * urn:ogc:def:crs:EPSG::4326
     */
    yx: {
        "urn:ogc:def:crs:EPSG::4326": true
    },

    /**
     * Constructor: GeoGlobe.Format.VTSCapabilities
     * Create a new parser for VTS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return information about
     * the service (offering and observedProperty mostly).
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Info about the VTS Capabilities
     */

    /**
     * APIMethod: createLayer
     * Create a VTS layer given a capabilities object.
     *
     * Parameters:
     * capabilities - {Object} The object returned from a <read> call to this
     *     format.
     * config - {Object} Configuration properties for the layer.  Defaults for
     *     the layer will apply if not provided.
     *
     * Required config properties:
     * layer - {String} The layer identifier.
     *
     * Optional config properties:
     * matrixSet - {String} The matrix set identifier, required if there is 
     *      more than one matrix set in the layer capabilities.
     * projection - {String} The desired CRS when no matrixSet is specified.
     *     eg: "EPSG:3857". If the desired projection is not available, 
     *     an error is thrown.
     * style - {String} The name of the style
     * format - {String} Image format for the layer. Default is the first
     *     format returned in the GetCapabilities response.
     * param - {Object} The dimensions values eg: {"Year": "2012"}
     *
     * Returns:
     * {<GeoGlobe.Layer.VTS>} A properly configured VTS layer.  Throws an
     *     error if an incomplete config is provided.  Returns undefined if no
     *     layer could be created with the provided config.
     */
    createLayer: function(capabilities, config) {
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }

        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }

        resolutions.sort(function(a,b){
            return b-a;
        });
        
        /*var options = GeoGlobe.Util.applyDefaults(config, {
            url: url,
            requestEncoding: requestEncoding,
            name: layerDef.title,
            style: style && style.identifier || "",
            format: format,
            matrixIds: reducedMatrixIds.length ? 
                reducedMatrixIds : matrixSet.matrixIds,
            matrixSet: matrixSet.identifier,
            projection: projection,
            units: units,
            tileFullExtent: matrixSet.bounds,
            dimensions: dimensions,
            params: params,
            resolutions: config.isBaseLayer === false ? undefined :
                resolutions,
            serverResolutions: resolutions,
            minScale: 1/Math.ceil(maxScaleDenominator),
            maxScale: 1/Math.floor(minScaleDenominator)
        });*/
		var VTS_url = "";
		var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		if(url[0].endsWith("?")){
            VTS_url = url[0] + param;
		}else{
            VTS_url = url[0] + "?" + param;
		}
        //var wmts_url = url+"?SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layers[0].identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format; 
        var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[VTS_url]
        });
        var VTSLayer = new GeoGlobe.Layer.VTS(options);
        VTSLayer.matrixSet = matrixSet;
        VTSLayer.identifier = layerDef.identifier;
        VTSLayer.bounds = layerDef.bounds;
        return VTSLayer;
    },

    CLASS_NAME: "GeoGlobe.Format.VTSCapabilities"
});
/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/VTSCapabilities.js
 * @requires GeoGlobe/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: GeoGlobe.Format.VTSCapabilities.v1_0_0
 * Read VTS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.VTSCapabilities>
 */
GeoGlobe.Format.VTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.OWSCommon.v1_1_0, {
        
    /**
     * Property: version
     * {String} The parser version ("1.0.0").
     */
    version: "1.0.0",

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Property: yx
     * {Object} Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  Defaults come from the 
     *     <GeoGlobe.Format.VTSCapabilities> prototype.
     */
    yx: null,

    /**
     * Property: defaultPrefix
     * {String} The default namespace alias for creating element nodes.
     */
    defaultPrefix: "wmts",

    /**
     * Constructor: GeoGlobe.Format.VTSCapabilities.v1_0_0
     * Create a new parser for VTS capabilities version 1.0.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
        var yx = GeoGlobe.Util.extend(
            {}, GeoGlobe.Format.VTSCapabilities.prototype.yx
        );
        this.yx = GeoGlobe.Util.extend(yx, this.yx);
    },

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return info about the VTS.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the SOS service.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        capabilities.version = this.version;
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    dimensions: [],
                    tileMatrixSetLinks: []
                };
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of VTS:Contents or VTS:TileMatrixSetLink
                // duck type VTS:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrixSetLimits": function(node, obj) {
                obj.tileMatrixSetLimits = [];
                this.readChildNodes(node, obj);
            },
            "TileMatrixLimits": function(node, obj) {
                var tileMatrixLimits = {};
                this.readChildNodes(node, tileMatrixLimits);
                obj.tileMatrixSetLimits.push(tileMatrixLimits);
            },
            "MinTileRow": function(node, obj) {
                obj.minTileRow = parseInt(this.getChildValue(node)); 
            },
            "MaxTileRow": function(node, obj) {
                obj.maxTileRow = parseInt(this.getChildValue(node)); 
            },
            "MinTileCol": function(node, obj) {
                obj.minTileCol = parseInt(this.getChildValue(node)); 
            },
            "MaxTileCol": function(node, obj) {
                obj.maxTileCol = parseInt(this.getChildValue(node)); 
            },
            "TileMatrix": function(node, obj) {
                // node could be child of VTS:TileMatrixSet or VTS:TileMatrixLimits
                if (obj.identifier) {
                    // node is child of VTS:TileMatrixSet
                    var tileMatrix = {
                        supportedCRS: obj.supportedCRS
                    };
                    this.readChildNodes(node, tileMatrix);
                    obj.matrixIds.push(tileMatrix);
                } else {
                    obj.tileMatrix = this.getChildValue(node);
                }
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },
            "ResourceURL": function(node, obj) {
                obj.resourceUrl = obj.resourceUrl || {};
                var resourceType = node.getAttribute("resourceType");
                if (!obj.resourceUrls) {
                    obj.resourceUrls = [];
                }
                var resourceUrl = obj.resourceUrl[resourceType] = {
                    format: node.getAttribute("format"),
                    template: node.getAttribute("template"),
                    resourceType: resourceType
                };
                obj.resourceUrls.push(resourceUrl);
            },
            "LegendURL": function(node, obj) {
                obj.legends = obj.legends || [];
                var legend = {
                    format: node.getAttribute("format"),
                    href: node.getAttribute("xlink:href")
                };
                var width = node.getAttribute("width"),
                    height = node.getAttribute("height"),
                    minScaleDenominator = node.getAttribute("minScaleDenominator"),
                    maxScaleDenominator = node.getAttribute("maxScaleDenominator");
                if (width !== null) {
                    legend.width = parseInt(width);
                }
                if (height !== null) {
                    legend.height = parseInt(height);
                }
                if (minScaleDenominator !== null) {
                    legend.minScaleDenominator = parseInt(minScaleDenominator);
                }
                if (maxScaleDenominator !== null) {
                    legend.maxScaleDenominator = parseInt(maxScaleDenominator);
                }
                obj.legends.push(legend);
            },
            "InfoFormat": function(node, obj) {
                obj.infoFormats = obj.infoFormats || [];
                obj.infoFormats.push(this.getChildValue(node));
            },
            // not used for now, can be added in the future though
            /*"Themes": function(node, obj) {
                obj.themes = [];
                this.readChildNodes(node, obj.themes);
            },
            "Theme": function(node, obj) {
                var theme = {};                
                this.readChildNodes(node, theme);
                obj.push(theme);
            },*/
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <WSDL> element                
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <ServiceMetadataURL> element                
            },
            "Dimension": function(node, obj) {
                var dimension = {values: []};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
            "Default": function(node, obj) {
                obj["default"] = this.getChildValue(node);
            },
            "Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.VTSCapabilities.v1_0_0"

});
/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML/VersionedOGC.js
 */

/**
 * Class: GeoGlobe.Format.WMTSCapabilities
 * Read WMTS Capabilities.
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML.VersionedOGC>
 */
GeoGlobe.Format.WMTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",

    /**
     * APIProperty: yx
     * {Object} Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  By default, the following CRS URN are
     *     assumed to correspond to a CRS with y,x axis order:
     *
     * * urn:ogc:def:crs:EPSG::4326
     */
    yx: {
        "urn:ogc:def:crs:EPSG::4326": true
    },

    /**
     * Constructor: GeoGlobe.Format.WMTSCapabilities
     * Create a new parser for WMTS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return information about
     * the service (offering and observedProperty mostly).
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Info about the WMTS Capabilities
     */

    /**
     * APIMethod: createLayer
     * Create a WMTS layer given a capabilities object.
     *
     * Parameters:
     * capabilities - {Object} The object returned from a <read> call to this
     *     format.
     * config - {Object} Configuration properties for the layer.  Defaults for
     *     the layer will apply if not provided.
     *
     * Required config properties:
     * layer - {String} The layer identifier.
     *
     * Optional config properties:
     * matrixSet - {String} The matrix set identifier, required if there is 
     *      more than one matrix set in the layer capabilities.
     * projection - {String} The desired CRS when no matrixSet is specified.
     *     eg: "EPSG:3857". If the desired projection is not available, 
     *     an error is thrown.
     * style - {String} The name of the style
     * format - {String} Image format for the layer. Default is the first
     *     format returned in the GetCapabilities response.
     * param - {Object} The dimensions values eg: {"Year": "2012"}
     *
     * Returns:
     * {<GeoGlobe.Layer.WMTS>} A properly configured WMTS layer.  Throws an
     *     error if an incomplete config is provided.  Returns undefined if no
     *     layer could be created with the provided config.
     */
    createLayer: function(capabilities, config) {
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }

        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }

        resolutions.sort(function(a,b){
            return b-a;
        });
        
        /*var options = GeoGlobe.Util.applyDefaults(config, {
            url: url,
            requestEncoding: requestEncoding,
            name: layerDef.title,
            style: style && style.identifier || "",
            format: format,
            matrixIds: reducedMatrixIds.length ? 
                reducedMatrixIds : matrixSet.matrixIds,
            matrixSet: matrixSet.identifier,
            projection: projection,
            units: units,
            tileFullExtent: matrixSet.bounds,
            dimensions: dimensions,
            params: params,
            resolutions: config.isBaseLayer === false ? undefined :
                resolutions,
            serverResolutions: resolutions,
            minScale: 1/Math.ceil(maxScaleDenominator),
            maxScale: 1/Math.floor(minScaleDenominator)
        });*/
		var wmts_url = "";
		var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		if(url[0].endsWith("?")){
			wmts_url = url[0] + param;
		}else{
			wmts_url = url[0] + "?" + param;
		}
        //var wmts_url = url+"?SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layers[0].identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format; 
        var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[wmts_url]
        });
        //var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
		var wmtsLayer = {
            id:options.id,
            layer:{
                "id": options.id,
                "type": "raster",
                "source":options.id
            },
            source:{
                "type": "raster",
                "tiles": options.url,
                "tileSize": 256
            }
        };
        wmtsLayer.matrixSet = matrixSet;
        wmtsLayer.identifier = layerDef.identifier;
        wmtsLayer.boundingBox = layerDef.BoundingBox;
        return wmtsLayer;
    },

    CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities"
});
/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/WMTSCapabilities.js
 * @requires GeoGlobe/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: GeoGlobe.Format.WMTSCapabilities.v1_0_0
 * Read WMTS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.WMTSCapabilities>
 */
GeoGlobe.Format.WMTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.OWSCommon.v1_1_0, {
        
    /**
     * Property: version
     * {String} The parser version ("1.0.0").
     */
    version: "1.0.0",

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Property: yx
     * {Object} Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  Defaults come from the 
     *     <GeoGlobe.Format.WMTSCapabilities> prototype.
     */
    yx: null,

    /**
     * Property: defaultPrefix
     * {String} The default namespace alias for creating element nodes.
     */
    defaultPrefix: "wmts",

    /**
     * Constructor: GeoGlobe.Format.WMTSCapabilities.v1_0_0
     * Create a new parser for WMTS capabilities version 1.0.0. 
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
        var yx = GeoGlobe.Util.extend(
            {}, GeoGlobe.Format.WMTSCapabilities.prototype.yx
        );
        this.yx = GeoGlobe.Util.extend(yx, this.yx);
    },

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return info about the WMTS.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the SOS service.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        capabilities.version = this.version;
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    dimensions: [],
                    tileMatrixSetLinks: []
                };
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of wmts:Contents or wmts:TileMatrixSetLink
                // duck type wmts:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrixSetLimits": function(node, obj) {
                obj.tileMatrixSetLimits = [];
                this.readChildNodes(node, obj);
            },
            "TileMatrixLimits": function(node, obj) {
                var tileMatrixLimits = {};
                this.readChildNodes(node, tileMatrixLimits);
                obj.tileMatrixSetLimits.push(tileMatrixLimits);
            },
            "MinTileRow": function(node, obj) {
                obj.minTileRow = parseInt(this.getChildValue(node)); 
            },
            "MaxTileRow": function(node, obj) {
                obj.maxTileRow = parseInt(this.getChildValue(node)); 
            },
            "MinTileCol": function(node, obj) {
                obj.minTileCol = parseInt(this.getChildValue(node)); 
            },
            "MaxTileCol": function(node, obj) {
                obj.maxTileCol = parseInt(this.getChildValue(node)); 
            },
            "TileMatrix": function(node, obj) {
                // node could be child of wmts:TileMatrixSet or wmts:TileMatrixLimits
                if (obj.identifier) {
                    // node is child of wmts:TileMatrixSet
                    var tileMatrix = {
                        supportedCRS: obj.supportedCRS
                    };
                    this.readChildNodes(node, tileMatrix);
                    obj.matrixIds.push(tileMatrix);
                } else {
                    obj.tileMatrix = this.getChildValue(node);
                }
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },
            "ResourceURL": function(node, obj) {
                obj.resourceUrl = obj.resourceUrl || {};
                var resourceType = node.getAttribute("resourceType");
                if (!obj.resourceUrls) {
                    obj.resourceUrls = [];
                }
                var resourceUrl = obj.resourceUrl[resourceType] = {
                    format: node.getAttribute("format"),
                    template: node.getAttribute("template"),
                    resourceType: resourceType
                };
                obj.resourceUrls.push(resourceUrl);
            },
            "LegendURL": function(node, obj) {
                obj.legends = obj.legends || [];
                var legend = {
                    format: node.getAttribute("format"),
                    href: node.getAttribute("xlink:href")
                };
                var width = node.getAttribute("width"),
                    height = node.getAttribute("height"),
                    minScaleDenominator = node.getAttribute("minScaleDenominator"),
                    maxScaleDenominator = node.getAttribute("maxScaleDenominator");
                if (width !== null) {
                    legend.width = parseInt(width);
                }
                if (height !== null) {
                    legend.height = parseInt(height);
                }
                if (minScaleDenominator !== null) {
                    legend.minScaleDenominator = parseInt(minScaleDenominator);
                }
                if (maxScaleDenominator !== null) {
                    legend.maxScaleDenominator = parseInt(maxScaleDenominator);
                }
                obj.legends.push(legend);
            },
            "InfoFormat": function(node, obj) {
                obj.infoFormats = obj.infoFormats || [];
                obj.infoFormats.push(this.getChildValue(node));
            },
            // not used for now, can be added in the future though
            /*"Themes": function(node, obj) {
                obj.themes = [];
                this.readChildNodes(node, obj.themes);
            },
            "Theme": function(node, obj) {
                var theme = {};                
                this.readChildNodes(node, theme);
                obj.push(theme);
            },*/
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <WSDL> element                
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <ServiceMetadataURL> element                
            },
            "Dimension": function(node, obj) {
                var dimension = {values: []};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
            "Default": function(node, obj) {
                obj["default"] = this.getChildValue(node);
            },
            "Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities.v1_0_0" 

});
/**
 * Class: GeoGlobe.Format.WMTSUtil
 * 根据wmts的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMTS数据源source和图层layer。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.WMTSUtil = GeoGlobe.Class4OL({

    /**
     * Constructor: GeoGlobe.Format.WMTSUtil
     * GeoGlobe.Format.WMTSUtil构造函数。
     */
    initialize: function(options){
		GeoGlobe.Util.extend(this, options);
    },
    
	getWMTSCapabilities: function(url){
		var capabilities = null;
		this.getCapabilities(url, function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new GeoGlobe.Format.WMTSCapabilities.v1_0_0();
            capabilities = format.read(data);
        },
		function(){
            alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
			//wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
        });
        return capabilities;
	},
	
	getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
    
    //test
    createLayerOption: function(url, capabilities, config){
    	var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
		/*
        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }
		*/
        resolutions.sort(function(a,b){
            return b-a;
        });
        
		var wmts_url = "";
		//var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		//GeoGlobe.Util.getParameterString(param);
		var param = this.getParameterString({
			"SERVICE": "WMTS",
			"REQUEST": "GetTile",
			"VERSION": capabilities.version,
			"LAYER": layerDef.identifier,
			"STYLE": style.identifier,
			"TILEMATRIXSET": matrixSet.identifier,
			"FORMAT": format,
			"TILEMATRIX": "{z}",
			"TILEROW": "{y}",
			"TILECOL": "{x}"
		});
		if(url.endsWith("?")){
			wmts_url = GeoGlobe.ProxyHost + url + param;
		}else{
			wmts_url = GeoGlobe.ProxyHost + url + "?" + param;
		}
		//wmts_url = GeoGlobe.Request.makeSameOrigin(wmts_url, GeoGlobe.ProxyHost);
        /*
		var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[wmts_url]
        });
        var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
        wmtsLayer.matrixSet = matrixSet;
		*/
		
		var randomNum = GeoGlobe.Util.randomStr(10);
		/*
		var layerOption = {
			source:{
		        "id": "source_" + layerDef.identifier + "_" + randomNum,
		        "type": "raster",
		        "tiles": [wmts_url],
		        "tileSize": 256
		    },
			layers:[{
		        "id": "layer_" + layerDef.identifier + "_" + randomNum,
		        "type": "raster",
		        "source": "source_" + layerDef.identifier + "_" + randomNum,
		        "paint": {
					"raster-opacity": 1
				}
		    }]
		};
		*/
		var layerOption = {
	        "id": "layer_" + layerDef.identifier + "_" + randomNum,
	        "type": "raster",
	        "source": {
                "type": "raster",
                "tiles": [wmts_url],
                "tileSize": 256
            },
	        "paint": {
				"raster-opacity": 1
			}
	    };
        return layerOption;
    },
	/*
    //test
    createLayerOptions: function(url){
		var cap = this.getWMTSCapabilities(url);
		var layers = cap.contents.layers;
		var layerOptions = [];
    	for(var i = 0; i < layers.length; i++){
			var config = {layer: layers[i].identifier};
			var wmtsOpt = this.createLayerOption(url, cap, config);
			layerOptions.push(wmtsOpt);
		}
		return layerOptions;
    },
	*/
    //test
    createLayer: function(url){
		var cap = this.getWMTSCapabilities(url);
		var config = {layer: cap.contents.layers[0].identifier};
		var layerOption = this.createLayerOption(url, cap, config);
		return layerOption;
    },
    createLayers: function(url){
		var cap = this.getWMTSCapabilities(url);
		var layers = cap.contents.layers;
		var layerOptions = [];
    	for(var i = 0; i < layers.length; i++){
			var config = {layer: layers[i].identifier};
			var wmtsOpt = this.createLayerOption(url, cap, config);
			layerOptions.push(wmtsOpt);
		}
		return layerOptions;
    },
	
	
	getParameterString: function(params) {
		var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
	    return paramsArray.join("&");
	},
    
    CLASS_NAME: "GeoGlobe.Format.WMTSUtil"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML/VersionedOGC.js
 */
 
/**
 * Class: GeoGlobe.Format.WPSCapabilities
 * Read WPS Capabilities.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML.VersionedOGC>
 */
GeoGlobe.Format.WPSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * Constructor: GeoGlobe.Format.WPSCapabilities
     * Create a new parser for WPS Capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return information about
     * the service.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Info about the WPS
     */
    
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/WPSCapabilities.js
 * @requires View2D/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: GeoGlobe.Format.WPSCapabilities.v1_0_0
 * Read WPS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.WPSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wps: "http://www.opengis.net/wps/1.0.0",
        xlink: "http://www.w3.org/1999/xlink"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Constructor: GeoGlobe.Format.WPSCapabilities.v1_0_0
     * Create a new parser for WPS capabilities version 1.0.0. 
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return info about the WPS.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the WPS service.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wps": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "ProcessOfferings": function(node, obj) {
                obj.processOfferings = {};
                this.readChildNodes(node, obj.processOfferings);
            },
            "Process": function(node, processOfferings) {
                var processVersion = this.getAttributeNS(node, this.namespaces.wps, "processVersion");
                var process = {processVersion: processVersion};
                this.readChildNodes(node, process);
                processOfferings[process.identifier] = process;
            },
            "Languages": function(node, obj) {
                obj.languages = [];
                this.readChildNodes(node, obj.languages);
            },
            "Default": function(node, languages) {
                var language = {isDefault: true};
                this.readChildNodes(node, language);
                languages.push(language);
            },
            "Supported": function(node, languages) {
                var language = {};
                this.readChildNodes(node, language);     
                languages.push(language);
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities.v1_0_0" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML.js
 * @requires GeoGlobe/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: GeoGlobe.Format.WCSGetCoverage version 1.1.0
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.WCSGetCoverage = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wcs: "http://www.opengis.net/wcs/1.1",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Constant: VERSION
     * {String} 1.1.2
     */
    VERSION: "1.1.2",

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/wcs/1.1 http://schemas.opengis.net/wcs/1.1/wcsGetCoverage.xsd",

    /**
     * Constructor: GeoGlobe.Format.WCSGetCoverage
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Method: write
     *
     * Parameters:
     * options - {Object} Optional object.
     *
     * Returns:
     * {String} A WCS GetCoverage request XML string.
     */
    write: function(options) {
        var node = this.writeNode("wcs:GetCoverage", options);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wcs": {
            "GetCoverage": function(options) {
                var node = this.createElementNSPlus("wcs:GetCoverage", {
                    attributes: {
                        version: options.version || this.VERSION,
                        service: 'WCS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wcs:DomainSubset", options.domainSubset, node);
                this.writeNode("wcs:Output", options.output, node);
                return node; 
            },
            "DomainSubset": function(domainSubset) {
                var node = this.createElementNSPlus("wcs:DomainSubset", {});
                this.writeNode("ows:BoundingBox", domainSubset.boundingBox, node);
                if (domainSubset.temporalSubset) {
                    this.writeNode("wcs:TemporalSubset", domainSubset.temporalSubset, node);
                }
                return node;
            },
            "TemporalSubset": function(temporalSubset) {
                var node = this.createElementNSPlus("wcs:TemporalSubset", {});
                for (var i=0, len=temporalSubset.timePeriods.length; i<len; ++i) {
                    this.writeNode("wcs:TimePeriod", temporalSubset.timePeriods[i], node);
                }
                return node;
            },
            "TimePeriod": function(timePeriod) {
                var node = this.createElementNSPlus("wcs:TimePeriod", {});
                this.writeNode("wcs:BeginPosition", timePeriod.begin, node);
                this.writeNode("wcs:EndPosition", timePeriod.end, node);
                if (timePeriod.resolution) {
                    this.writeNode("wcs:TimeResolution", timePeriod.resolution, node);
                }
                return node;
            },
            "BeginPosition": function(begin) {
                var node = this.createElementNSPlus("wcs:BeginPosition", {
                    value: begin
                });
                return node;
            },
            "EndPosition": function(end) {
                var node = this.createElementNSPlus("wcs:EndPosition", {
                    value: end
                });
                return node;
            },
            "TimeResolution": function(resolution) {
                var node = this.createElementNSPlus("wcs:TimeResolution", {
                    value: resolution
                });
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wcs:Output", {
                    attributes: {
                        format: output.format,
                        store: output.store
                    }
                });
                if (output.gridCRS) {
                    this.writeNode("wcs:GridCRS", output.gridCRS, node);
                }
                return node;
            },
            "GridCRS": function(gridCRS) {
                var node = this.createElementNSPlus("wcs:GridCRS", {});
                this.writeNode("wcs:GridBaseCRS", gridCRS.baseCRS, node);
                if (gridCRS.type) {
                    this.writeNode("wcs:GridType", gridCRS.type, node);
                }
                if (gridCRS.origin) {
                    this.writeNode("wcs:GridOrigin", gridCRS.origin, node);
                }
                this.writeNode("wcs:GridOffsets", gridCRS.offsets, node);
                if (gridCRS.CS) {
                    this.writeNode("wcs:GridCS", gridCRS.CS, node);
                }
                return node;
            },
            "GridBaseCRS": function(baseCRS) {
                return this.createElementNSPlus("wcs:GridBaseCRS", {
                    value: baseCRS
                });
            },
            "GridOrigin": function(origin) {
                return this.createElementNSPlus("wcs:GridOrigin", {
                    value: origin
                });
            },
            "GridType": function(type) {
                return this.createElementNSPlus("wcs:GridType", {
                    value: type
                });
            },
            "GridOffsets": function(offsets) {
                return this.createElementNSPlus("wcs:GridOffsets", {
                    value: offsets
                });
            },
            "GridCS": function(CS) {
                return this.createElementNSPlus("wcs:GridCS", {
                    value: CS
                });
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    
    CLASS_NAME: "GeoGlobe.Format.WCSGetCoverage" 

});
/* Copyright (c) 2006-2015 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML.js
 * @requires GeoGlobe/Format/OWSCommon/v1_1_0.js
 * @requires GeoGlobe/Format/WCSGetCoverage.js
 * @requires GeoGlobe/Format/WFST/v1_1_0.js
 */

/**
 * Class: GeoGlobe.Format.WPSExecute version 1.0.0
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.WPSExecute = GeoGlobe.Class4OL(GeoGlobe.Format.XML,
                                            GeoGlobe.Format.Filter.v1_1_0, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        gml: "http://www.opengis.net/gml",
        wps: "http://www.opengis.net/wps/1.0.0",
        wfs: "http://www.opengis.net/wfs",
        ogc: "http://www.opengis.net/ogc",
        wcs: "http://www.opengis.net/wcs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",

    schemaLocationAttr: function(options) {
        return undefined;
    },

    /**
     * Constructor: GeoGlobe.Format.WPSExecute
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Method: write
     *
     * Parameters:
     * options - {Object} Optional object.
     *
     * Returns:
     * {String} An WPS Execute request XML string.
     */
    write: function(options) {
        var doc;
        if (GeoGlobe.Format.XML.supportActiveX) {
            doc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmldom = doc;
        } else {
            doc = document.implementation.createDocument("", "", null);
        }
        var node = this.writeNode("wps:Execute", options, doc);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     * APIMethod: read
     * Parse a WPS Execute and return an object with its information.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object}
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var info = {};
        this.readNode(data, info);
        return info;
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wps": {
            "Execute": function(options) {
                var node = this.createElementNSPlus("wps:Execute", {
                    attributes: {
                        version: this.VERSION,
                        service: 'WPS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wps:DataInputs", options.dataInputs, node);
                this.writeNode("wps:ResponseForm", options.responseForm, node);
                return node; 
            },
            "ResponseForm": function(responseForm) {
                var node = this.createElementNSPlus("wps:ResponseForm", {});
                if (responseForm.rawDataOutput) {
                    this.writeNode("wps:RawDataOutput", responseForm.rawDataOutput, node);
                }
                if (responseForm.responseDocument) {
                    this.writeNode("wps:ResponseDocument", responseForm.responseDocument, node);
                }
                return node;
            },
            "ResponseDocument": function(responseDocument) {
                var node = this.createElementNSPlus("wps:ResponseDocument", {
                    attributes: {
                        storeExecuteResponse: responseDocument.storeExecuteResponse,
                        lineage: responseDocument.lineage,
                        status: responseDocument.status
                    }
                });
                if (responseDocument.outputs) {
                    for (var i = 0, len = responseDocument.outputs.length; i < len; i++) {
                        this.writeNode("wps:Output", responseDocument.outputs[i], node);
                    }
                }
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wps:Output", {
                    attributes: {
                        asReference: output.asReference,
                        mimeType: output.mimeType,
                        encoding: output.encoding,
                        schema: output.schema
                    }
                });
                this.writeNode("ows:Identifier", output.identifier, node);
                this.writeNode("ows:Title", output.title, node);
                this.writeNode("ows:Abstract", output["abstract"], node);
                return node;
            },
            "RawDataOutput": function(rawDataOutput) {
                var node = this.createElementNSPlus("wps:RawDataOutput", {
                    attributes: {
                        mimeType: rawDataOutput.mimeType,
                        encoding: rawDataOutput.encoding,
                        schema: rawDataOutput.schema
                    }
                });
                this.writeNode("ows:Identifier", rawDataOutput.identifier, node);
                return node;
            },
            "DataInputs": function(dataInputs) {
                var node = this.createElementNSPlus("wps:DataInputs", {});
                for (var i=0, ii=dataInputs.length; i<ii; ++i) {
                    this.writeNode("wps:Input", dataInputs[i], node);
                }
                return node;
            },
            "Input": function(input) {
                var node = this.createElementNSPlus("wps:Input", {});
                this.writeNode("ows:Identifier", input.identifier, node);
                if (input.title) {
                    this.writeNode("ows:Title", input.title, node);
                }
                if (input.data) {
                    this.writeNode("wps:Data", input.data, node);
                }
                if (input.reference) {
                    this.writeNode("wps:Reference", input.reference, node);
                }
                if (input.boundingBoxData) {
                    this.writeNode("wps:BoundingBoxData", input.boundingBoxData, node);
                }
                return node;
            },
            "Data": function(data) {
                var node = this.createElementNSPlus("wps:Data", {});
                if (data.literalData) {
                    this.writeNode("wps:LiteralData", data.literalData, node);
                } else if (data.complexData) {
                    this.writeNode("wps:ComplexData", data.complexData, node);
                } else if (data.boundingBoxData) {
                    this.writeNode("ows:BoundingBox", data.boundingBoxData, node);
                }
                return node;
            },
            "LiteralData": function(literalData) {
                var node = this.createElementNSPlus("wps:LiteralData", {
                    attributes: {
                        uom: literalData.uom
                    },
                    value: literalData.value
                });
                return node;
            },
            "ComplexData": function(complexData) {
                var node = this.createElementNSPlus("wps:ComplexData", {
                    attributes: {
                        mimeType: complexData.mimeType,
                        encoding: complexData.encoding,
                        schema: complexData.schema
                    } 
                });
                var data = complexData.value;
                if (typeof data === "string") {
                    node.appendChild(
                        this.getXMLDoc().createCDATASection(complexData.value)
                    );
                } else {
                    node.appendChild(data);
                }
                return node;
            },
            "Reference": function(reference) {
                var node = this.createElementNSPlus("wps:Reference", {
                    attributes: {
                        mimeType: reference.mimeType,
                        "xlink:href": reference.href,
                        method: reference.method,
                        encoding: reference.encoding,
                        schema: reference.schema
                    }
                });
                if (reference.body) {
                    this.writeNode("wps:Body", reference.body, node);
                }
                return node;
            },
            "BoundingBoxData": function(node, obj) {
                this.writers['ows']['BoundingBox'].apply(this, [node, obj, "wps:BoundingBoxData"]);
            },
            "Body": function(body) {
                var node = this.createElementNSPlus("wps:Body", {});
                if (body.wcs) {
                    this.writeNode("wcs:GetCoverage", body.wcs, node);
                }
                else if (body.wfs) {
                    // GeoGlobe.Format.WFST expects these to be on the 
                    // instance and not in the options
                    this.featureType = body.wfs.featureType;
                    this.version = body.wfs.version;
                    this.writeNode("wfs:GetFeature", body.wfs, node);
                } else {
                    this.writeNode("wps:Execute", body, node);
                }
                return node;                
            }
        },
        "wcs": GeoGlobe.Format.WCSGetCoverage.prototype.writers.wcs,
        "wfs": GeoGlobe.Format.WFST.v1_1_0.prototype.writers.wfs,
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers.ogc,
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wps": {
            "ExecuteResponse": function(node, obj) {
                obj.executeResponse = {
                    lang: node.getAttribute("lang"),
                    statusLocation: node.getAttribute("statusLocation"),
                    serviceInstance: node.getAttribute("serviceInstance"),
                    service: node.getAttribute("service")
                };
                this.readChildNodes(node, obj.executeResponse);
            },
            "Process":function(node,obj) {
                obj.process = {};
                this.readChildNodes(node, obj.process);
            },
            "Status":function(node,obj) {
                obj.status = {
                    creationTime: node.getAttribute("creationTime")
                };
                this.readChildNodes(node, obj.status);
            },
            "ProcessSucceeded": function(node,obj) {
                obj.processSucceeded = true;
            },
            "ProcessOutputs": function(node, processDescription) {
                processDescription.processOutputs = [];
                this.readChildNodes(node, processDescription.processOutputs);
            },
            "Output": function(node, processOutputs) {
                var output = {};
                this.readChildNodes(node, output);
                processOutputs.push(output);
            },
            "Reference": function(node, output) {
                output.reference = {
                    href: node.getAttribute("href"),
                    mimeType: node.getAttribute("mimeType"),
                    encoding: node.getAttribute("encoding"),
                    schema: node.getAttribute("schema")
                };
            },
            "Data": function(node, output) {
                output.data = {};
                this.readChildNodes(node, output);
            },
            "LiteralData": function(node, output) {
                output.literalData = {
                    dataType: node.getAttribute("dataType"),
                    uom: node.getAttribute("uom"),
                    value: this.getChildValue(node)
                };
            },
            "ComplexData": function(node, output) {
                output.complexData = {
                    mimeType: node.getAttribute("mimeType"),
                    schema: node.getAttribute("schema"),
                    encoding: node.getAttribute("encoding"),
                    value: ""
                };
                
                // try to get *some* value, ignore the empty text values
                if (this.isSimpleContent(node)) {
                    var child;
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        switch(child.nodeType) {
                            case 3: // text node
                            case 4: // cdata section
                                output.complexData.value += child.nodeValue;
                        }
                    }
                }
                else {
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        if (child.nodeType == 1) {
                            output.complexData.value = child;
                        }
                    }
                }

            },
            "BoundingBox": function(node, output) {
                output.boundingBoxData = {
                    dimensions: node.getAttribute("dimensions"),
                    crs: node.getAttribute("crs")
                };
                this.readChildNodes(node, output.boundingBoxData);
            }
        },

        // TODO: we should add Exception parsing here
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },
    
    CLASS_NAME: "GeoGlobe.Format.WPSExecute" 

});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/Format/XML.js
 */

/**
 * Class: GeoGlobe.Format.OGCExceptionReport
 * Class to read exception reports for various OGC services and versions.
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.OGCExceptionReport = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "ogc",

    /**
     * Constructor: GeoGlobe.Format.OGCExceptionReport
     * Create a new parser for OGC exception reports.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read OGC exception report data from a string, and return an object with
     * information about the exceptions.
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the exceptions that occurred.
     */
    read: function(data) {
        var result;
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var exceptionInfo = {exceptionReport: null}; 
        if (root) {
            this.readChildNodes(data, exceptionInfo);
            if (exceptionInfo.exceptionReport === null) {
                // fall-back to OWSCommon since this is a common output format for exceptions
                // we cannot easily use the ows readers directly since they differ for 1.0 and 1.1
                exceptionInfo = new GeoGlobe.Format.OWSCommon().read(data);
            }
        }
        return exceptionInfo;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": {
            "ServiceExceptionReport": function(node, obj) {
                obj.exceptionReport = {exceptions: []};
                this.readChildNodes(node, obj.exceptionReport);
            },
            "ServiceException": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute("code"),
                    locator: node.getAttribute("locator"),
                    text: this.getChildValue(node)
                };
                exceptionReport.exceptions.push(exception);
            }
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.OGCExceptionReport"
    
});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/tool/Console.js
 * @requires GeoGlobe/Format.js
 * @requires GeoGlobe/Filter/Spatial.js
 * @requires GeoGlobe/Filter/Comparison.js
 * @requires GeoGlobe/Filter/Logical.js
 */

/**
 * Class: GeoGlobe.Format.QueryStringFilter
 * Parser for reading a query string and creating a simple filter.
 *
 * Inherits from:
 *  - <GeoGlobe.Format>
 */
GeoGlobe.Format.QueryStringFilter = (function() {

    /** 
     * Map the GeoGlobe.Filter.Comparison types to the operation strings of 
     * the protocol.
     */
    var cmpToStr = {};
    cmpToStr[GeoGlobe.Filter.Comparison.EQUAL_TO] = "eq";
    cmpToStr[GeoGlobe.Filter.Comparison.NOT_EQUAL_TO] = "ne";
    cmpToStr[GeoGlobe.Filter.Comparison.LESS_THAN] = "lt";
    cmpToStr[GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO] = "lte";
    cmpToStr[GeoGlobe.Filter.Comparison.GREATER_THAN] = "gt";
    cmpToStr[GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO] = "gte";
    cmpToStr[GeoGlobe.Filter.Comparison.LIKE] = "ilike";

    /**
     * Function: regex2value
     * Convert the value from a regular expression string to a LIKE/ILIKE
     * string known to the web service.
     *
     * Parameters:
     * value - {String} The regex string.
     *
     * Returns:
     * {String} The converted string.
     */
    function regex2value(value) {

        // highly sensitive!! Do not change this without running the
        // Protocol/HTTP.html unit tests

        // convert % to \%
        value = value.replace(/%/g, "\\%");

        // convert \\. to \\_ (\\.* occurences converted later)
        value = value.replace(/\\\\\.(\*)?/g, function($0, $1) {
            return $1 ? $0 : "\\\\_";
        });

        // convert \\.* to \\%
        value = value.replace(/\\\\\.\*/g, "\\\\%");

        // convert . to _ (\. and .* occurences converted later)
        value = value.replace(/(\\)?\.(\*)?/g, function($0, $1, $2) {
            return $1 || $2 ? $0 : "_";
        });

        // convert .* to % (\.* occurnces converted later)
        value = value.replace(/(\\)?\.\*/g, function($0, $1) {
            return $1 ? $0 : "%";
        });

        // convert \. to .
        value = value.replace(/\\\./g, ".");

        // replace \* with * (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "*";
        });

        return value;
    }
    
    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        
        /**
         * Property: wildcarded.
         * {Boolean} If true percent signs are added around values
         *     read from LIKE filters, for example if the protocol
         *     read method is passed a LIKE filter whose property
         *     is "foo" and whose value is "bar" the string
         *     "foo__ilike=%bar%" will be sent in the query string;
         *     defaults to false.
         */
        wildcarded: false,

        /**
         * APIProperty: srsInBBOX
         * {Boolean} Include the SRS identifier in BBOX query string parameter.  
         *     Default is false.  If true and the layer has a projection object set,
         *     any BBOX filter will be serialized with a fifth item identifying the
         *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
         */
        srsInBBOX: false,

        /**
         * APIMethod: write
         * Serialize an <GeoGlobe.Filter> objects using the "simple" filter syntax for 
         *     query string parameters.  This function must be called as a method of
         *     a protocol instance.
         *
         * Parameters:
         * filter - {<GeoGlobe.Filter>} filter to convert.
         * params - {Object} The parameters object.
         *
         * Returns:
         * {Object} The resulting parameters object.
         */
        write: function(filter, params) {
            params = params || {};
            var className = filter.CLASS_NAME;
            var filterType = className.substring(className.lastIndexOf(".") + 1);
            switch (filterType) {
                case "Spatial":
                    switch (filter.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            params.bbox = filter.value.toArray();
                            if (this.srsInBBOX && filter.projection) {
                                params.bbox.push(filter.projection.getCode());
                            }
                            break;
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            params.tolerance = filter.distance;
                            // no break here
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            params.lon = filter.value.x;
                            params.lat = filter.value.y;
                            break;
                        default:
                            GeoGlobe.Console.warn(
                                "Unknown spatial filter type " + filter.type);
                    }
                    break;
                case "Comparison":
                    var op = cmpToStr[filter.type];
                    if (op !== undefined) {
                        var value = filter.value;
                        if (filter.type == GeoGlobe.Filter.Comparison.LIKE) {
                            value = regex2value(value);
                            if (this.wildcarded) {
                                value = "%" + value + "%";
                            }
                        }
                        params[filter.property + "__" + op] = value;
                        params.queryable = params.queryable || [];
                        params.queryable.push(filter.property);
                    } else {
                        GeoGlobe.Console.warn(
                            "Unknown comparison filter type " + filter.type);
                    }
                    break;
                case "Logical":
                    if (filter.type === GeoGlobe.Filter.Logical.AND) {
                        for (var i=0,len=filter.filters.length; i<len; i++) {
                            params = this.write(filter.filters[i], params);
                        }
                    } else {
                        GeoGlobe.Console.warn(
                            "Unsupported logical filter type " + filter.type);
                    }
                    break;
                default:
                    GeoGlobe.Console.warn("Unknown filter type " + filterType);
            }
            return params;
        },
        
        CLASS_NAME: "GeoGolobe.Format.QueryStringFilter"
        
    });


})();
/**
 * Class: GeoGlobe.Format.BusCapabilities
 * 公交换乘服务Capabilities操作解析类，继承自GeoGlobe.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.BusCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML,{
	
    /**
     * APIProperty: tagName
     * {String} 常量"NETWORK_Capabilities" ,根据该服务的getCapabilities请求返回而定。
     */
	tagName: "NETWORK_Capabilities",

	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * ｛Object｝- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = {};
		if(capabilitiesNode.length > 0){
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0]);
		}
		return capabilitiesObj;
	},

	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     * parentPath - {String}解析方法拼去，这里使用"capabilities"。
     * 
     */	
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
				if(parentPath){
					processor = this["read_" + parentPath + "_" + childNode.nodeName];
				} else{
					processor = this["read_" + childNode.nodeName];
				}
                
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },

	/**
     * Method: read_Service
     * 解析节点Service的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service: function(capabilitiesObj, node){
		var serviceObj = {};
		this.runChildNodes(serviceObj, node, "Service");
		capabilitiesObj.service = serviceObj;
	},

	/**
     * Method: read_Service_Name
     * 解析节点为Name的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Name: function(servcieObj,node){
		var name = this.getChildValue(node);
		if(name) {
            servcieObj.name = name;
        }
	},

	/**
     * Method: read_Service_Title
     * 解析节点为Title的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象
     * node - ｛DOMElement｝ 需要解析的节点对象
     */		
	read_Service_Title: function(servcieObj,node){
		var title = this.getChildValue(node);
		if(title) {
            servcieObj.title = title;
        }
	},

	/**
     * Method: read_Service_Abstract
     * 解析节点为Abstract的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Abstract: function(servcieObj,node){
		var serviceAbstract = this.getChildValue(node);
		if(serviceAbstract) {
            servcieObj.serviceAbstract = serviceAbstract;
        }
	},

	/**
     * Method: read_Service_KeywordList
     * 解析节点为KeywordList的节点。
     *
     * Parameters:
     * userScenarioObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Service_KeywordList: function(userScenarioObj,node){
	},

	/**
     * Method: read_Service_OnlineResource
     * 解析节点为OnlineResource的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_OnlineResource: function(servcieObj,node){
		var onlineResource = this.getChildValue(node);
		if(servcieObj) {
            servcieObj.onlineResource = onlineResource;
        }
	},

	/**
     * Method: read_Capability
     * 解析节点为Capability的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability: function(capabilitiesObj,node){
		var capaObj = {};
		this.runChildNodes(capaObj, node, "Capability");
		capabilitiesObj.capability = capaObj;
	},

	/**
     * Method: read_Capability_Request
     * 解析节点为Request的节点。
     *
     * Parameters:
     * capaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request: function(capaObj,node){
		var requestObj = {};
		this.runChildNodes(requestObj, node, "Capability_Request");
		capaObj.request = requestObj;
	},

	/**
     * Method: read_Capability_Request_GetCapabilities
     * 解析节点为GetCapabilities的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_GetCapabilities: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var getCapaObj ={};
		if(httpNode[0]){
			this.runChildNodes(getCapaObj, httpNode[0], "Capability_Request_GetCapabilities_DCPType_HTTP");
		}
		requestObj.getCapabilities = getCapaObj;
		
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Get: function(getCapaObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            getCapaObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Post: function(getCapaObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            getCapaObj.postUrl = postUrl;
        }
	},
	
	/**
     * Method: read_Capability_Request_queryStation
     * 解析节点为queryStation的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryStation: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryStationObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryStationObj, httpNode[0], "Capability_Request_queryStation_DCPType_HTTP");
		}
		requestObj.queryStation = queryStationObj;
		
	},

	/**
     * Method: read_Capability_Request_queryStation_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryStationObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_queryStation_DCPType_HTTP_Get: function(queryStationObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryStationObj.getUrl = getUrl;
        }
	},
	
	read_Capability_Request_queryStation_DCPType_HTTP_Post: function(queryStationObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryStationObj.postUrl = postUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine
     * 解析节点为queryLine的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryLineObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryLineObj, httpNode[0], "Capability_Request_queryLine_DCPType_HTTP");
		}
		requestObj.queryLine = queryLineObj;
		
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */			
	read_Capability_Request_queryLine_DCPType_HTTP_Get: function(queryLineObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryLineObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine_DCPType_HTTP_Post: function(queryLineObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryLineObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Request_queryChange
     * 解析节点为queryChange的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryChangeObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryChangeObj, httpNode[0], "Capability_Request_queryChange_DCPType_HTTP");
		}
		
	},

	/**
     * Method: read_Capability_Request_queryChange_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Get: function(queryChangeObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryChangeObj.getUrl = getUrl;
        }
	},

	/**
     * Parameters: read_Capability_Request_queryChange_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Method:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Post: function(queryChangeObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryChangeObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Networks
     * 解析节点为Networks的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Networks: function(capabilitiesObj,node){		
		var networkNodes = node.getElementsByTagName("Name");
		var networks = [];
		for(var i=0; i<networkNodes.length; i++){
			var network = this.getChildValue(networkNodes[i]);
			if(network){
				networks.push(network);
			}			
		}
		capabilitiesObj.networks = networks;
	},
	
	CLASS_NAME:"GeoGlobe.Format.BusCapabilities"
});/**
 * Class: GeoGlobe.Format.XML2JSON
 * 将XML文件解析成Javascript对象。
 */
GeoGlobe.Format.XML2JSON = GeoGlobe.Class4OL({
	
	/**
	 * Constructor: GeoGlobe.Format.XML2JSON
	 * GeoGlobe.Format.XML2JSON构造函数。
	 */
	initialize: function(){
		
	},
	
    /**
	 * APIMethod: read
	 * 将传入的XML字符串解析成Javascript对象并返回。
	 *
	 * Parameters: 
	 * xmlcode - {String} XML字符串。
	 */	
	read: function(xmlcode,ignoretags,debug){
		if(!ignoretags){ignoretags=""};
		xmlcode=xmlcode.replace(/\s*\/>/g,'/>');
		xmlcode=xmlcode.replace(/<\?[^>]*>/g,"").replace(/<\![^>]*>/g,"");
		if (!ignoretags.sort){ignoretags=ignoretags.split(",")};
		var x=this.no_fast_endings(xmlcode);
		x=this.attris_to_tags(x);
		x=escape(x);
		x=x.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join("\"");
		for (var i=0;i<ignoretags.length;i++){
			x=x.replace(new RegExp("<"+ignoretags[i]+">","g"),"*$**"+ignoretags[i]+"**$*");
			x=x.replace(new RegExp("</"+ignoretags[i]+">","g"),"*$***"+ignoretags[i]+"**$*")
		};
		x='<JSONTAGWRAPPER>'+x+'</JSONTAGWRAPPER>';
		this.xmlobject={};
		
		//---------------------修正禁止属性小写后,出现jsontagwrapper变成数组
		var y=this.xml_to_object(x).JSONTAGWRAPPER;
		//var y=this.xml_to_object(x).jsontagwrapper;
		
		if(debug){y=this.show_json_structure(y,debug)};
		return y
	},
	
	xml_to_object:function(xmlcode){
		var x=xmlcode.replace(/<\//g,"?");
		x=x.split("<");
		var y=[];
		var level=0;
		var opentags=[];
		for (var i=1;i<x.length;i++){
			var tagname=x[i].split(">")[0];
			opentags.push(tagname);
			level++
			y.push(level+"<"+x[i].split("?")[0]);
			while(x[i].indexOf("?"+opentags[opentags.length-1]+">")>=0){level--;opentags.pop()}
		};
		var oldniva=-1;
		var objname="this.xmlobject";
		for (var i=0;i<y.length;i++){
			var preeval="";
			var niva=y[i].split("<")[0];
			var tagnamn=y[i].split("<")[1].split(">")[0];
			
			//---------------------修正:禁止将属性和标签统一成小写,并将命名空间的冒号转成下划线
			tagnamn = tagnamn.replace(/%3A/,"_");
			//tagnamn=tagnamn.toLowerCase();
			
			var rest=y[i].split(">")[1];
			if(niva<=oldniva){
				var tabort=oldniva-niva+1;
				for (var j=0;j<tabort;j++){objname=objname.substring(0,objname.lastIndexOf("."))}
			};
			objname+="."+tagnamn;
			var pobject=objname.substring(0,objname.lastIndexOf("."));
			if (eval("typeof "+pobject) != "object"){preeval+=pobject+"={value:"+pobject+"};\n"};
			var objlast=objname.substring(objname.lastIndexOf(".")+1);
			var already=false;
			for (k in eval(pobject)){if(k==objlast){already=true}};
			var onlywhites=true;
			for(var s=0;s<rest.length;s+=3){
				if(rest.charAt(s)!="%"){onlywhites=false}
			};
			if (rest!="" && !onlywhites){
				if(rest/1!=rest){
					rest="'"+rest.replace(/\'/g,"\\'")+"'";
					rest=rest.replace(/\*\$\*\*\*/g,"</");
					rest=rest.replace(/\*\$\*\*/g,"<");
					rest=rest.replace(/\*\*\$\*/g,">")
				}
			} 
			else {rest="{}"};
			if(rest.charAt(0)=="'"){rest='unescape('+rest+')'};
			if (already && !eval(objname+".sort")){preeval+=objname+"=["+objname+"];\n"};
			var before="=";after="";
			if (already){before=".push(";after=")"};
			var toeval=preeval+objname+before+rest+after;
			eval(toeval);
			if(eval(objname+".sort")){objname+="["+eval(objname+".length-1")+"]"};
			oldniva=niva
		};
		return this.xmlobject
	},
	show_json_structure:function(obj,debug,l){
		var x='';
		if (obj.sort){x+="[\n"} else {x+="{\n"};
		for (var i in obj){
			if (!obj.sort){x+=i+":"};
			if (typeof obj[i] == "object"){
				x+=this.show_json_structure(obj[i],false,1)
			}
			else {
				if(typeof obj[i]=="function"){
					var v=obj[i]+"";
					//v=v.replace(/\t/g,"");
					x+=v
				}
				else if(typeof obj[i]!="string"){x+=obj[i]+",\n"}
				else {x+="'"+obj[i].replace(/\'/g,"\\'").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")+"',\n"}
			}
		};
		if (obj.sort){x+="],\n"} else {x+="},\n"};
		if (!l){
			x=x.substring(0,x.lastIndexOf(","));
			x=x.replace(new RegExp(",\n}","g"),"\n}");
			x=x.replace(new RegExp(",\n]","g"),"\n]");
			var y=x.split("\n");x="";
			var lvl=0;
			for (var i=0;i<y.length;i++){
				if(y[i].indexOf("}")>=0 || y[i].indexOf("]")>=0){lvl--};
				tabs="";for(var j=0;j<lvl;j++){tabs+="\t"};
				x+=tabs+y[i]+"\n";
				if(y[i].indexOf("{")>=0 || y[i].indexOf("[")>=0){lvl++}
			};
			if(debug=="html"){
				x=x.replace(/</g,"&lt;").replace(/>/g,"&gt;");
				x=x.replace(/\n/g,"<BR>").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;")
			};
			if (debug=="compact"){x=x.replace(/\n/g,"").replace(/\t/g,"")}
		};
		return x
	},
	no_fast_endings:function(x){
		x=x.split("/>");
		for (var i=1;i<x.length;i++){
			var t=x[i-1].substring(x[i-1].lastIndexOf("<")+1).split(" ")[0];
			x[i]="></"+t+">"+x[i]
		}	;
		x=x.join("");
		return x
	},
	attris_to_tags: function(x){
		var d=' ="\''.split("");
		x=x.split(">");
		for (var i=0;i<x.length;i++){
			var temp=x[i].split("<");
			for (var r=0;r<4;r++){temp[0]=temp[0].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")};
			if(temp[1]){
				temp[1]=temp[1].replace(/'/g,'"');
				temp[1]=temp[1].split('"');
				for (var j=1;j<temp[1].length;j+=2){
					for (var r=0;r<4;r++){temp[1][j]=temp[1][j].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")}
				};
				temp[1]=temp[1].join('"')
			};
			x[i]=temp.join("<")
		};
		x=x.join(">");
		x=x.replace(/ ([^=]*)=([^ |>]*)/g,"><$1>$2</$1");
		x=x.replace(/>"/g,">").replace(/"</g,"<");
		for (var r=0;r<4;r++){x=x.replace(new RegExp("_jsonconvtemp"+r+"_","g"),d[r])}	;
		return x
	},
	
    CLASS_NAME: "GeoGlobe.Format.XML2JSON"
});/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format.js
 */

/**
 * Class: GeoGlobe.Format.CSWGetRecords
 * Default version is 2.0.2.
 *
 * Returns:
 * {<GeoGlobe.Format>} A CSWGetRecords format of the given version.
 */
GeoGlobe.Format.CSWGetRecords = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Format.CSWGetRecords.DEFAULTS
    );
    var cls = GeoGlobe.Format.CSWGetRecords["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSWGetRecords version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: DEFAULTS
 * {Object} Default properties for the CSWGetRecords format.
 */
GeoGlobe.Format.CSWGetRecords.DEFAULTS = {
    "version": "2.0.2"
};
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @requires GeoGlobe/Format/XML.js
 * @requires GeoGlobe/Format/CSWGetRecords.js
 * @requires GeoGlobe/Format/Filter/v1_0_0.js
 * @requires GeoGlobe/Format/Filter/v1_1_0.js
 * @requires GeoGlobe/Format/OWSCommon/v1_0_0.js
 */

/**
 * Class: GeoGlobe.Format.CSWGetRecords.v2_0_2
 *     A format for creating CSWGetRecords v2.0.2 transactions. 
 *     Create a new instance with the
 *     <GeoGlobe.Format.CSWGetRecords.v2_0_2> constructor.
 *
 * Inherits from:
 *  - <GeoGlobe.Format.XML>
 */
GeoGlobe.Format.CSWGetRecords.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        csw: "http://www.opengis.net/cat/csw/2.0.2",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        gmd: "http://www.isotc211.org/2005/gmd",
        geonet: "http://www.fao.org/geonetwork",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    
    /**
     * Property: defaultPrefix
     * {String} The default prefix (used by Format.XML).
     */
    defaultPrefix: "csw",
    
    /**
     * Property: version
     * {String} CSW version number.
     */
    version: "2.0.2",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/cat/csw/2.0.2
     *   http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd
     */
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",

    /**
     * APIProperty: requestId
     * {String} Value of the requestId attribute of the GetRecords element.
     */
    requestId: null,

    /**
     * APIProperty: resultType
     * {String} Value of the resultType attribute of the GetRecords element,
     *     specifies the result type in the GetRecords response, "hits" is
     *     the default.
     */
    resultType: null,

    /**
     * APIProperty: outputFormat
     * {String} Value of the outputFormat attribute of the GetRecords element,
     *     specifies the format of the GetRecords response,
     *     "application/xml" is the default.
     */
    outputFormat: null,

    /**
     * APIProperty: outputSchema
     * {String} Value of the outputSchema attribute of the GetRecords element,
     *     specifies the schema of the GetRecords response.
     */
    outputSchema: null,

    /**
     * APIProperty: startPosition
     * {String} Value of the startPosition attribute of the GetRecords element,
     *     specifies the start position (offset+1) for the GetRecords response,
     *     1 is the default.
     */
    startPosition: null,

    /**
     * APIProperty: maxRecords
     * {String} Value of the maxRecords attribute of the GetRecords element,
     *     specifies the maximum number of records in the GetRecords response,
     *     10 is the default.
     */
    maxRecords: null,

    /**
     * APIProperty: DistributedSearch
     * {String} Value of the csw:DistributedSearch element, used when writing
     *     a csw:GetRecords document.
     */
    DistributedSearch: null,

    /**
     * APIProperty: ResponseHandler
     * {Array({String})} Values of the csw:ResponseHandler elements, used when
     *     writting a csw:GetRecords document.
     */
    ResponseHandler: null,

    /**
     * APIProperty: Query
     * {String} Value of the csw:Query element, used when writing a csw:GetRecords
     *     document.
     */
    Query: null,

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Constructor: GeoGlobe.Format.CSWGetRecords.v2_0_2
     * A class for parsing and generating CSWGetRecords v2.0.2 transactions.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties (documented as class properties):
     * - requestId
     * - resultType
     * - outputFormat
     * - outputSchema
     * - startPosition
     * - maxRecords
     * - DistributedSearch
     * - ResponseHandler
     * - Query
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Parse the response from a GetRecords request.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        this.readNode(data, obj);
        return obj;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "csw": {
            "GetRecordsResponse": function(node, obj) {
                obj.records = [];
                this.readChildNodes(node, obj);
                var version = this.getAttributeNS(node, "", 'version');
                if (version != "") {
                    obj.version = version;
                }
            },
            "RequestId": function(node, obj) {
                obj.RequestId = this.getChildValue(node);
            },
            "SearchStatus": function(node, obj) {
                obj.SearchStatus = {};
                var timestamp = this.getAttributeNS(node, "", 'timestamp');
                if (timestamp != "") {
                    obj.SearchStatus.timestamp = timestamp;
                }
            },
            "SearchResults": function(node, obj) {
                this.readChildNodes(node, obj);
                var attrs = node.attributes;
                var SearchResults = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    if ((attrs[i].name == "numberOfRecordsMatched") ||
                        (attrs[i].name == "numberOfRecordsReturned") ||
                        (attrs[i].name == "nextRecord")) {
                        SearchResults[attrs[i].name] = parseInt(attrs[i].nodeValue);
                    } else {
                        SearchResults[attrs[i].name] = attrs[i].nodeValue;
                    }
                }
                obj.SearchResults = SearchResults;
            },
            "SummaryRecord": function(node, obj) {
                var record = {type: "SummaryRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "BriefRecord": function(node, obj) {
                var record = {type: "BriefRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "DCMIRecord": function(node, obj) {
                var record = {type: "DCMIRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "Record": function(node, obj) {
                var record = {type: "Record"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
            }
        },
        "geonet": {
            "info": function(node, obj) {
                var gninfo = {};
                this.readChildNodes(node, gninfo);
                obj.gninfo = gninfo;
            }
        },
        "dc": {
            // audience, contributor, coverage, creator, date, description, format,
            // identifier, language, provenance, publisher, relation, rights,
            // rightsHolder, source, subject, title, type, URI
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(GeoGlobe.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                var dc_element = {};
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    dc_element[attrs[i].name] = attrs[i].nodeValue;
                }
                dc_element.value = this.getChildValue(node);
                if (dc_element.value != "") {
                    obj[name].push(dc_element);
                }
            }
        },
        "dct": {
            // abstract, modified, spatial
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(GeoGlobe.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                obj[name].push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Util.applyDefaults({
            "BoundingBox": function(node, obj) {
                if (obj.bounds) {
                    obj.BoundingBox = [{crs: obj.projection, value: 
                        [
                            obj.bounds._sw.lng,
                            obj.bounds._sw.lat,
                            obj.bounds._ne.lng,
                            obj.bounds._ne.lat
                    ]
                    }];
                    delete obj.projection;
                    delete obj.bounds;
                }
                GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"]["BoundingBox"].apply(
                    this, arguments);
            }
        }, GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"])
    },
    
    /**
     * Method: write
     * Given an configuration js object, write a CSWGetRecords request. 
     *
     * Parameters:
     * options - {Object} A object mapping the request.
     *
     * Returns:
     * {String} A serialized CSWGetRecords request.
     */
    write: function(options) {
        var node = this.writeNode("csw:GetRecords", options);
        node.setAttribute("xmlns:gmd", this.namespaces.gmd);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "csw": {
            "GetRecords": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:GetRecords", {
                    attributes: {
                        service: "CSW",
                        version: this.version,
                        requestId: options.requestId || this.requestId,
                        resultType: options.resultType || this.resultType,
                        outputFormat: options.outputFormat || this.outputFormat,
                        outputSchema: options.outputSchema || this.outputSchema,
                        startPosition: options.startPosition || this.startPosition,
                        maxRecords: options.maxRecords || this.maxRecords
                    }
                });
                if (options.DistributedSearch || this.DistributedSearch) {
                    this.writeNode(
                        "csw:DistributedSearch",
                        options.DistributedSearch || this.DistributedSearch,
                        node
                    );
                }
                var ResponseHandler = options.ResponseHandler || this.ResponseHandler;
                if (GeoGlobe.Util.isArray(ResponseHandler) && ResponseHandler.length > 0) {
                    // ResponseHandler must be a non-empty array
                    for(var i=0, len=ResponseHandler.length; i<len; i++) {
                        this.writeNode(
                            "csw:ResponseHandler",
                            ResponseHandler[i],
                            node
                        );
                    }
                }
                this.writeNode("Query", options.Query || this.Query, node);
                return node;
            },
            "DistributedSearch": function(options) {
                var node = this.createElementNSPlus("csw:DistributedSearch", {
                    attributes: {
                        hopCount: options.hopCount
                    }
                });
                return node;
            },
            "ResponseHandler": function(options) {
                var node = this.createElementNSPlus("csw:ResponseHandler", {
                    value: options.value
                });
                return node;
            },
            "Query": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:Query", {
                    attributes: {
                        typeNames: options.typeNames || "csw:Record"
                    }
                });
                var ElementName = options.ElementName;
                if (GeoGlobe.Util.isArray(ElementName) && ElementName.length > 0) {
                    // ElementName must be a non-empty array
                    for(var i=0, len=ElementName.length; i<len; i++) {
                        this.writeNode(
                            "csw:ElementName",
                            ElementName[i],
                            node
                        );
                    }
                } else {
                    this.writeNode(
                        "csw:ElementSetName",
                        options.ElementSetName || {value: 'summary'},
                        node
                    );
                }
                if (options.Constraint) {
                    this.writeNode(
                        "csw:Constraint",
                        options.Constraint,
                        node
                    );
                }
                if (options.SortBy) {
                    this.writeNode(
                        "ogc:SortBy",
                        options.SortBy,
                        node
                    );
                }
                return node;
            },
            "ElementName": function(options) {
                var node = this.createElementNSPlus("csw:ElementName", {
                    value: options.value
                });
                return node;
            },
            "ElementSetName": function(options) {
                var node = this.createElementNSPlus("csw:ElementSetName", {
                    attributes: {
                        typeNames: options.typeNames
                    },
                    value: options.value
                });
                return node;
            },
            "Constraint": function(options) {
                var node = this.createElementNSPlus("csw:Constraint", {
                    attributes: {
                        version: options.version
                    }
                });
                if (options.Filter) {
                    var format = new GeoGlobe.Format.Filter({
                        version: options.version
                    });
                    node.appendChild(format.write(options.Filter));
                } else if (options.CqlText) {
                    var child = this.createElementNSPlus("CqlText", {
                        value: options.CqlText.value
                    });
                    node.appendChild(child);
                }
                return node;
            }
        },
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "GeoGlobe.Format.CSWGetRecords.v2_0_2"
});
/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

(function (root, factory) {
	/*//标签式引入，不需要这段判断代码
     if (typeof define === "function" && define.amd) {
         define([], factory);
     } else if (typeof exports === "object") {
         module.exports = factory();
     } else {
         root.X2JS = factory();
     }
	 */
	root.GeoGlobe.Format.X2JS = factory();
	root.GeoGlobe.Format.X2JS.CLASS_NAME = "GeoGlobe.Format.X2JS";
 }(this, function () {
	return function (config) {
		'use strict';
			
		var VERSION = "1.2.0";
		
		config = config || {};
		initConfigDefaults();
		initRequiredPolyfills();
		
		function initConfigDefaults() {
			if(config.escapeMode === undefined) {
				config.escapeMode = true;
			}
			
			config.attributePrefix = config.attributePrefix || "_";
			config.arrayAccessForm = config.arrayAccessForm || "none";
			config.emptyNodeForm = config.emptyNodeForm || "text";		
			
			if(config.enableToStringFunc === undefined) {
				config.enableToStringFunc = true; 
			}
			config.arrayAccessFormPaths = config.arrayAccessFormPaths || []; 
			if(config.skipEmptyTextNodesForObj === undefined) {
				config.skipEmptyTextNodesForObj = true;
			}
			if(config.stripWhitespaces === undefined) {
				config.stripWhitespaces = true;
			}
			config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];
	
			if(config.useDoubleQuotes === undefined) {
				config.useDoubleQuotes = false;
			}
			
			config.xmlElementsFilter = config.xmlElementsFilter || [];
			config.jsonPropertiesFilter = config.jsonPropertiesFilter || [];
			
			if(config.keepCData === undefined) {
				config.keepCData = false;
			}
		}
	
		var DOMNodeTypes = {
			ELEMENT_NODE 	   : 1,
			TEXT_NODE    	   : 3,
			CDATA_SECTION_NODE : 4,
			COMMENT_NODE	   : 8,
			DOCUMENT_NODE 	   : 9
		};
		
		function initRequiredPolyfills() {		
		}
		
		function getNodeLocalName( node ) {
			var nodeLocalName = node.localName;			
			if(nodeLocalName == null) // Yeah, this is IE!! 
				nodeLocalName = node.baseName;
			if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
				nodeLocalName = node.nodeName;
			return nodeLocalName;
		}
		
		function getNodePrefix(node) {
			return node.prefix;
		}
			
		function escapeXmlChars(str) {
			if(typeof(str) == "string")
				return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
			else
				return str;
		}
	
		function unescapeXmlChars(str) {
			return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, '&');
		}
		
		function checkInStdFiltersArrayForm(stdFiltersArrayForm, obj, name, path) {
			var idx = 0;
			for(; idx < stdFiltersArrayForm.length; idx++) {
				var filterPath = stdFiltersArrayForm[idx];
				if( typeof filterPath === "string" ) {
					if(filterPath == path)
						break;
				}
				else
				if( filterPath instanceof RegExp) {
					if(filterPath.test(path))
						break;
				}				
				else
				if( typeof filterPath === "function") {
					if(filterPath(obj, name, path))
						break;
				}
			}
			return idx!=stdFiltersArrayForm.length;
		}
		
		function toArrayAccessForm(obj, childName, path) {
			switch(config.arrayAccessForm) {
				case "property":
					if(!(obj[childName] instanceof Array))
						obj[childName+"_asArray"] = [obj[childName]];
					else
						obj[childName+"_asArray"] = obj[childName];
					break;
				/*case "none":
					break;*/
			}
			
			if(!(obj[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
				if(checkInStdFiltersArrayForm(config.arrayAccessFormPaths, obj, childName, path)) {
					obj[childName] = [obj[childName]];
				}			
			}
		}
		
		function fromXmlDateTime(prop) {
			// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
			// Improved to support full spec and optional parts
			var bits = prop.split(/[-T:+Z]/g);
			
			var d = new Date(bits[0], bits[1]-1, bits[2]);			
			var secondBits = bits[5].split("\.");
			d.setHours(bits[3], bits[4], secondBits[0]);
			if(secondBits.length>1)
				d.setMilliseconds(secondBits[1]);
	
			// Get supplied time zone offset in minutes
			if(bits[6] && bits[7]) {
				var offsetMinutes = bits[6] * 60 + Number(bits[7]);
				var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';
	
				// Apply the sign
				offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);
	
				// Apply offset and local timezone
				d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset())
			}
			else
				if(prop.indexOf("Z", prop.length - 1) !== -1) {
					d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));					
				}
	
			// d is now a local time equivalent to the supplied time
			return d;
		}
		
		function checkFromXmlDateTimePaths(value, childName, fullPath) {
			if(config.datetimeAccessFormPaths.length > 0) {
				var path = fullPath.split("\.#")[0];
				if(checkInStdFiltersArrayForm(config.datetimeAccessFormPaths, value, childName, path)) {
					return fromXmlDateTime(value);
				}
				else
					return value;			
			}
			else
				return value;
		}
		
		function checkXmlElementsFilter(obj, childType, childName, childPath) {
			if( childType == DOMNodeTypes.ELEMENT_NODE && config.xmlElementsFilter.length > 0) {
				return checkInStdFiltersArrayForm(config.xmlElementsFilter, obj, childName, childPath);	
			}
			else
				return true;
		}	
	
		function parseDOMChildren( node, path ) {
			if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
				var result = new Object;
				var nodeChildren = node.childNodes;
				// Alternative for firstElementChild which is not supported in some environments
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx);
					if(child.nodeType == DOMNodeTypes.ELEMENT_NODE) {
						var childName = getNodeLocalName(child);
						result[childName] = parseDOMChildren(child, childName);
					}
				}
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
				var result = new Object;
				result.__cnt=0;
				
				var nodeChildren = node.childNodes;
				
				// Children nodes
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx); // nodeChildren[cidx];
					var childName = getNodeLocalName(child);
					
					if(child.nodeType!= DOMNodeTypes.COMMENT_NODE) {
						var childPath = path+"."+childName;
						if (checkXmlElementsFilter(result,child.nodeType,childName,childPath)) {
							result.__cnt++;
							if(result[childName] == null) {
								result[childName] = parseDOMChildren(child, childPath);
								toArrayAccessForm(result, childName, childPath);					
							}
							else {
								if(result[childName] != null) {
									if( !(result[childName] instanceof Array)) {
										result[childName] = [result[childName]];
										toArrayAccessForm(result, childName, childPath);
									}
								}
								(result[childName])[result[childName].length] = parseDOMChildren(child, childPath);
							}
						}
					}								
				}
				
				// Attributes
				for(var aidx=0; aidx <node.attributes.length; aidx++) {
					var attr = node.attributes.item(aidx); // [aidx];
					result.__cnt++;
					result[config.attributePrefix+attr.name]=attr.value;
				}
				
				// Node namespace prefix
				var nodePrefix = getNodePrefix(node);
				if(nodePrefix!=null && nodePrefix!="") {
					result.__cnt++;
					result.__prefix=nodePrefix;
				}
				
				if(result["#text"]!=null) {				
					result.__text = result["#text"];
					if(result.__text instanceof Array) {
						result.__text = result.__text.join("\n");
					}
					//if(config.escapeMode)
					//	result.__text = unescapeXmlChars(result.__text);
					if(config.stripWhitespaces)
						result.__text = result.__text.trim();
					delete result["#text"];
					if(config.arrayAccessForm=="property")
						delete result["#text_asArray"];
					result.__text = checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
				}
				if(result["#cdata-section"]!=null) {
					result.__cdata = result["#cdata-section"];
					delete result["#cdata-section"];
					if(config.arrayAccessForm=="property")
						delete result["#cdata-section_asArray"];
				}
				
				if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
					result = '';
				}
				else
				if( result.__cnt == 1 && result.__text!=null  ) {
					result = result.__text;
				}
				else
				if( result.__cnt == 1 && result.__cdata!=null && !config.keepCData  ) {
					result = result.__cdata;
				}			
				else			
				if ( result.__cnt > 1 && result.__text!=null && config.skipEmptyTextNodesForObj) {
					if( (config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
						delete result.__text;
					}
				}
				delete result.__cnt;			
				
				if( config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
					result.toString = function() {
						return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
					};
				}
				
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
				return node.nodeValue;
			}	
		}
		
		function startTag(jsonObj, element, attrList, closed) {
			var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
			if(attrList!=null) {
				for(var aidx = 0; aidx < attrList.length; aidx++) {
					var attrName = attrList[aidx];
					var attrVal = jsonObj[attrName];
					if(config.escapeMode)
						attrVal=escapeXmlChars(attrVal);
					resultStr+=" "+attrName.substr(config.attributePrefix.length)+"=";
					if(config.useDoubleQuotes)
						resultStr+='"'+attrVal+'"';
					else
						resultStr+="'"+attrVal+"'";
				}
			}
			if(!closed)
				resultStr+=">";
			else
				resultStr+="/>";
			return resultStr;
		}
		
		function endTag(jsonObj,elementName) {
			return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
		}
		
		function endsWith(str, suffix) {
			return str.indexOf(suffix, str.length - suffix.length) !== -1;
		}
		
		function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
			if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray"))) 
					|| jsonObjField.toString().indexOf(config.attributePrefix)==0 
					|| jsonObjField.toString().indexOf("__")==0
					|| (jsonObj[jsonObjField] instanceof Function) )
				return true;
			else
				return false;
		}
		
		function jsonXmlElemCount ( jsonObj ) {
			var elementsCnt = 0;
			if(jsonObj instanceof Object ) {
				for( var it in jsonObj  ) {
					if(jsonXmlSpecialElem ( jsonObj, it) )
						continue;			
					elementsCnt++;
				}
			}
			return elementsCnt;
		}
		
		function checkJsonObjPropertiesFilter(jsonObj, propertyName, jsonObjPath) {
			return config.jsonPropertiesFilter.length == 0
				|| jsonObjPath==""
				|| checkInStdFiltersArrayForm(config.jsonPropertiesFilter, jsonObj, propertyName, jsonObjPath);	
		}
		
		function parseJSONAttributes ( jsonObj ) {
			var attrList = [];
			if(jsonObj instanceof Object ) {
				for( var ait in jsonObj  ) {
					if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
						attrList.push(ait);
					}
				}
			}
			return attrList;
		}
		
		function parseJSONTextAttrs ( jsonTxtObj ) {
			var result ="";
			
			if(jsonTxtObj.__cdata!=null) {										
				result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
			}
			
			if(jsonTxtObj.__text!=null) {			
				if(config.escapeMode)
					result+=escapeXmlChars(jsonTxtObj.__text);
				else
					result+=jsonTxtObj.__text;
			}
			return result;
		}
		
		function parseJSONTextObject ( jsonTxtObj ) {
			var result ="";
	
			if( jsonTxtObj instanceof Object ) {
				result+=parseJSONTextAttrs ( jsonTxtObj );
			}
			else
				if(jsonTxtObj!=null) {
					if(config.escapeMode)
						result+=escapeXmlChars(jsonTxtObj);
					else
						result+=jsonTxtObj;
				}
			
			return result;
		}
		
		function getJsonPropertyPath(jsonObjPath, jsonPropName) {
			if (jsonObjPath==="") {
				return jsonPropName;
			}
			else
				return jsonObjPath+"."+jsonPropName;
		}
		
		function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList, jsonObjPath ) {
			var result = ""; 
			if(jsonArrRoot.length == 0) {
				result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
			}
			else {
				for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
					result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
					result+=parseJSONObject(jsonArrRoot[arIdx], getJsonPropertyPath(jsonObjPath,jsonArrObj));
					result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
				}
			}
			return result;
		}
		
		function parseJSONObject ( jsonObj, jsonObjPath ) {
			var result = "";	
	
			var elementsCnt = jsonXmlElemCount ( jsonObj );
			
			if(elementsCnt > 0) {
				for( var it in jsonObj ) {
					
					if(jsonXmlSpecialElem ( jsonObj, it) || (jsonObjPath!="" && !checkJsonObjPropertiesFilter(jsonObj, it, getJsonPropertyPath(jsonObjPath,it))) )
						continue;			
					
					var subObj = jsonObj[it];						
					
					var attrList = parseJSONAttributes( subObj )
					
					if(subObj == null || subObj == undefined) {
						result+=startTag(subObj, it, attrList, true);
					}
					else
					if(subObj instanceof Object) {
						
						if(subObj instanceof Array) {					
							result+=parseJSONArray( subObj, it, attrList, jsonObjPath );					
						}
						else if(subObj instanceof Date) {
							result+=startTag(subObj, it, attrList, false);
							result+=subObj.toISOString();
							result+=endTag(subObj,it);
						}
						else {
							var subObjElementsCnt = jsonXmlElemCount ( subObj );
							if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
								result+=startTag(subObj, it, attrList, false);
								result+=parseJSONObject(subObj, getJsonPropertyPath(jsonObjPath,it));
								result+=endTag(subObj,it);
							}
							else {
								result+=startTag(subObj, it, attrList, true);
							}
						}
					}
					else {
						result+=startTag(subObj, it, attrList, false);
						result+=parseJSONTextObject(subObj);
						result+=endTag(subObj,it);
					}
				}
			}
			result+=parseJSONTextObject(jsonObj);
			
			return result;
		}
		
		this.parseXmlString = function(xmlDocStr) {
			var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
			if (xmlDocStr === undefined) {
				return null;
			}
			var xmlDoc;
			if (window.DOMParser) {
				var parser=new window.DOMParser();			
				var parsererrorNS = null;
				// IE9+ now is here
				if(!isIEParser) {
					try {
						parsererrorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI;
					}
					catch(err) {					
						parsererrorNS = null;
					}
				}
				try {
					xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
					if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
						//throw new Error('Error parsing XML: '+xmlDocStr);
						xmlDoc = null;
					}
				}
				catch(err) {
					xmlDoc = null;
				}
			}
			else {
				// IE :(
				if(xmlDocStr.indexOf("<?")==0) {
					xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
				}
				xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
				xmlDoc.async="false";
				xmlDoc.loadXML(xmlDocStr);
			}
			return xmlDoc;
		};
		
		this.asArray = function(prop) {
			if (prop === undefined || prop == null)
				return [];
			else
			if(prop instanceof Array)
				return prop;
			else
				return [prop];
		};
		
		this.toXmlDateTime = function(dt) {
			if(dt instanceof Date)
				return dt.toISOString();
			else
			if(typeof(dt) === 'number' )
				return new Date(dt).toISOString();
			else	
				return null;
		};
		
		this.asDateTime = function(prop) {
			if(typeof(prop) == "string") {
				return fromXmlDateTime(prop);
			}
			else
				return prop;
		};
	
		this.xml2json = function (xmlDoc) {
			return parseDOMChildren ( xmlDoc );
		};
		
		this.xml_str2json = function (xmlDocStr) {
			var xmlDoc = this.parseXmlString(xmlDocStr);
			if(xmlDoc!=null)
				return this.xml2json(xmlDoc);
			else
				return null;
		};
	
		this.json2xml_str = function (jsonObj) {
			return parseJSONObject ( jsonObj, "" );
		};
	
		this.json2xml = function (jsonObj) {
			var xmlDocStr = this.json2xml_str (jsonObj);
			return this.parseXmlString(xmlDocStr);
		};
		
		this.getVersion = function () {
			return VERSION;
		};	
	}
}));/**
 * Class: GeoGlobe.Analysis.BufferAnalysis
 * 缓冲区分析类。
 */
GeoGlobe.Analysis.BufferAnalysis = GeoGlobe.Class4OL({

	/**
     * APIProperty: url
     * {String} 缓冲分析操作所需要的WPS服务地址。
     */	
	url: null,

	/**
     * APIProperty: type
     * {Integer} 缓冲区的端点类型，默认值为GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND。
     * 可以为GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND、GeoGlobe.Analysis.BufferAnalysis.CAP_BUTT、
     * GeoGlobe.Analysis.BufferAnalysis.CAP_SQUARE三者之一。
     */
	type: 1,
	
	/**
     * APIProperty: accuracy
     * {Integer} 缓冲的拟合精度。默认值为32。
     */
	accuracy: 32,

	/**
	 * Constructor: GeoGlobe.Analysis.BufferAnalysis
	 * GeoGlobe.Analysis.BufferAnalysis类构造函数。
	 *
	 * Parameters:
	 * url - {String} WPS服务地址。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,options){
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},
	
    
    /**
     * 构造查询字串。将要缓冲的要素和缓冲半径来构造用于Post查询的字符串。
     * 参数:
     * features - 要执行缓冲分析的要素。
     * distance - 缓冲半径。
     */
	_buildPostXML: function(features,distance){
				
		var gmlParser = new GeoGlobe.Format.GML();
        var geoStr = gmlParser.write(features);
		var xmlstr = 
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + 
			    '<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' + 
			    '<ows:Identifier>Buffer</ows:Identifier>' +
			    '<wps:DataInputs><wps:Input><ows:Identifier>InputPolygon</ows:Identifier><wps:Data><wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' + 
			    geoStr + '</wps:ComplexData></wps:Data></wps:Input>' + 
			'<wps:Input><ows:Identifier>BufferDistance</ows:Identifier><wps:Data><wps:LiteralData>' + distance + '</wps:LiteralData></wps:Data>' + 
			'</wps:Input><wps:Input><ows:Identifier>BufferType</ows:Identifier><wps:Data><wps:LiteralData>' + this.type + '</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferAccuracy</ows:Identifier><wps:Data><wps:LiteralData>' + this.accuracy + '</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>BufferedPolygon</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>';
        return xmlstr;
	},

    /**
     * 获取所有要素范围之合的中心点。
     * 
     * 参数:
     * features - 要执行缓冲分析的要素。
     * 
     * 返回值:
     * {<GeoGlobe.LngLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * 获取要素数组范围之合。
	 *
	 * 参数:
	 * features - 要查看的要素数组。
	 * 
	 * 返回值:
	 * {<GeoGlobe.LngLatBounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(GeoGlobe.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new GeoGlobe.LngLatBounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	
	/**
	 * APIMethod: startAnalysis
	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *
	 * Parameters:
	 * geojson - {GeoJSON>}要分析的要素。
	 * distance - {Integer}缓冲半径。
	 * unit - {String} 长度计量单位。取值"m","km","degree"，可选，默认值为"m"。
	 * 
	 * Example:
	 * (code)
	 * //绘制一个被缓冲的中心点
	 * var point = {
     *     "type": "Feature",
     *     "geometry": {
     *           "type": "Point",
     *           "coordinates": [105,35]
     *      }
     * };
     * var geojsonPoint = {
	 *	   "type": "FeatureCollection",
	 *	   "features": [point]
	 * };
	 * //设置缓冲距离500米
     * var distance = 500;
     * 
     * //缓冲单位
     * var unit = "m";
     * 
     * //开始缓冲分析
     * ba.startAnalysis(geojsonPoint, distance, unit);
     * (end)
	 */
	startAnalysis: function(geojson,distance,unit){
		var unitList = ["m","km","degree"];
		//将geojson转化为feature
		var gj = new GeoGlobe.Format.GeoJSON();
		var feature = gj.read(geojson);
		
		var lnglat = this._getFeaturesCenter(feature);
		
		//距离单位默认为米
		if(!unit || (GeoGlobe.Util.indexOf(unitList,unit) == -1)){
			unit = "m";
		}
		
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lnglat);				
		}
		var postStr = this._buildPostXML(feature,distance);
		var xhr = new GeoGlobe.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var feature = this._parserResult(result);
                //将feature转化为geojson数据
                var gj = new GeoGlobe.Format.GeoJSON();
                var geojsonStr = gj.write(feature);
                var j = new GeoGlobe.Format.JSON();
                var geojsonPloygon = j.read(geojsonStr);
                this.successFn(geojsonPloygon);
            },
			failure:this.failFn
			
		});
	},
	
	/**
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * 参数:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(GeoGlobe.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: successFn
	 * 缓冲分析操作成功的回调函数，由用户使用自己定义的方法替代。
	 *
	 * Parameters:
	 * features - {Array(<GeoGlobe.Feature>)} 结果要素数组。
	 */	
	successFn:function(features){
	},

	/**
	 * APIMethod: failFn
	 * 缓冲分析操作失败回调函数，默认提示"缓冲分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法覆写。
	 */		
	failFn:function(){
		alert("缓冲分析操作失败，请检测服务是否正常运行。");
	},
	
    /**
     * 解析缓冲分析操作返回结果
     */
	_parserResult: function(result){
		var feature = null;
		var xmlParser = new GeoGlobe.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlParser = new GeoGlobe.Format.GML();		
			feature = gmlParser.read(result.responseXML);
		return feature;
	},

	CLASS_NAME: "GeoGlobe.Analysis.BufferAnalysis"
});

/**
 * Constant: GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 圆形缓冲区端点。
 */
GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND = 1;

/**
 * Constant: GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 平角缓冲区端点。
 */
GeoGlobe.Analysis.BufferAnalysis.CAP_BUTT = 2;


/**
 * Constant: GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 矩形缓冲区端点。
 */
GeoGlobe.Analysis.BufferAnalysis.CAP_SQUARE = 3;﻿/**
 * Class: GeoGlobe.Analysis.GetFeature
 * 叠置分析类。
 */
GeoGlobe.Analysis.GetFeature = GeoGlobe.Class4OL({

    /**
     * APIProperty: url
     * {String} 叠置分析操作所需要的WPS服务地址。
     */
    url: null,

    /**
     * APIProperty: type
     * {String} 叠置分析操作类型。
     */
    type:"intersection",


    //请求串模板
    //_reqStrTemplate:"{'GetFeature': {'service': 'OverlapService','version': '1.0.0',"+"'Query': [{'typeName':'${dataInputs}'}],"+"'maxFeatures': '','startPosition': '','resultType': ''}}",
	_reqStrTemplate: "{'GetFeature': {'service': 'OverlapService','version': '1.0.0','dataSource':'${sourceInputs}','Query': [{'typeName':'${dataInputs}'}],'maxFeatures': '','startPosition': '','outPutFormat': 'GeoJSON','resultType': ''}}",

    /**
     * Constructor: GeoGlobe.Analysis.SuperposeAnalysis
     * GeoGlobe.Analysis.SuperposeAnalysis类构造函数。
     *
     * Parameters:
     * url - {String} 服务地址
     * options - {Object} 相关属性的设置项，可选
     */
    initialize: function(url,options){
        this.url = url;
        GeoGlobe.Util.extend(this, options);
    },

    //构造查询字串
    _buildReqStr: function(){
        var string = GeoGlobe.String.format(this._reqStrTemplate,{
            type: this.type,
            dataInputs: this.typeName,
            sourceInputs: this.DataSource
        });
        return string;
    },

    /**
     * APIMethod: startAnalysis
     * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
     *
     */
    startAnalysis: function(pageNum){
        //查询前做设置方面检查
        if(this._checkSet()){
            return false;
        }

        //发送分析请求
        var postStr = this._buildReqStr();
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: postStr,
            scope: this,
            success:function(result){
                if("" == result.responseText || null == result.responseText){
                    this.failFn();
                    return;
                }
                this.successFn(result);
            },
            failure:this.failFn

        });
    },
    //检查相关参数设置
    _checkSet: function(){
        if(!this.url){
            return false;
        }
    },

    /**
     * APIMethod: successFn
     * 分析操作成功的回调函数
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>)} 结果要素数组
     */
    successFn:function(features){

    },
    /**
     * APIMethod: failFn
     * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
     * 用户可以使用自定义方法替代。
     */
    failFn:function(){
        alert("服务请求操作失败，请检测服务是否正常运行。");
    },

    CLASS_NAME:"GeoGlobe.Analysis.GetFeature"

});﻿/**
 * Class: GeoGlobe.Analysis.SpatialAnalysis
 * 叠置分析类。
 */
GeoGlobe.Analysis.SpatialAnalysis = GeoGlobe.Class({

    /**
     * APIProperty: url
     * {String} 叠置分析操作所需要的WPS服务地址。
     */
    url: null,

    /**
     * APIProperty: type
     * {String} 叠置分析操作类型。
     */
    type:"intersection",


    //请求串模板
    _requestStrTemplate:
    "{'SpatialAnalysis': {'service': 'OverlapService','version': '1.0.0',"+
    "'origionLayerNames': ['${origionLayerNames}'],'targetLayerNames': ['${targetLayerNames}'],"+
    "'outPutFormat': 'GeoJSON','operator': '${dataInputs}','isSynchronization': 'true','tolerance': '${tolerance}'}}",
    /**
     * Constructor: GeoGlobe.Analysis.SuperposeAnalysis
     * GeoGlobe.Analysis.SuperposeAnalysis类构造函数。
     *
     * Parameters:
     * url - {String} 服务地址
     * options - {Object} 相关属性的设置项，可选
     */
    initialize: function(url,options){
        this.url = url;

        GeoGlobe.Util.extend(this, options);
    },

    //构造查询字串
    _buildRequestStr: function(){
        var string = GeoGlobe.String.format(this._requestStrTemplate,{
            type: this.type,
            dataInputs: this.operator,
            origionLayerNames:this.origionLayerNames,
            targetLayerNames:this.targetLayerNames,
			 tolerance:this.tolerance
        });
        return string;
    },

    /**
     * APIMethod: startAnalysis
     * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
     *
     */
    startAnalysis: function(pageNum){
        //查询前做设置方面检查
        if(this._checkSet()){
            return false;
        }

        //发送分析请求
        var postStr = this._buildRequestStr();
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: postStr,
            scope: this,
            success:function(result){
                if("" == result.responseText || null == result.responseText){
                    this.failFn();
                    return;
                }
                //var features = this._parserResult(result);
                this.successFn(result,pageNum);
            },
            failure:this.failFn

        });
    },

    //检查相关参数设置
    _checkSet: function(){
        if(!this.url){
            return false;
        }
    },

    /**
     * APIMethod: successFn
     * 分析操作成功的回调函数
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>)} 结果要素数组
     */
    successFn:function(features){

    },

    /**
     * APIMethod: failFn
     * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
     * 用户可以使用自定义方法替代。
     */
    failFn:function(){
        alert("叠置分析操作失败，请检测服务是否正常运行。");
    },
    CLASS_NAME:"GeoGlobe.Analysis.SpatialAnalysis"

});
﻿/**
 * Class: GeoGlobe.Analysis.CoreBufferAnalysis
 * 基于内核的缓冲分析类。
 */
GeoGlobe.Analysis.CoreBufferAnalysis = GeoGlobe.Class({

    /**
     * APIProperty: url
     * {String} 缓冲分析操作所需要的WPS服务地址。
     */
    url: null,

    /**
     * APIProperty: type
     * {String} 缓冲分析操作类型。
     */
    type:"intersection",

    //请求串模板
    _requestStrTemplate:
    "{'BufferAnalysis': {'service': 'OverlapService','version': '1.0.0',"+
    "'layerName': '${layerName}','bufferRadius': '${bufferRadius}','bufferStyle':'${bufferStyle}',"+
    "'outPutFormat': 'JSON','bufferType': '${bufferType}','isSynchronization': 'true'}}",
    /**
     * Constructor: GeoGlobe.Analysis.CoreBufferAnalysis
     * GeoGlobe.Analysis.CoreBufferAnalysis类构造函数。
     *
     * Parameters:
     * url - {String} 服务地址
     * options - {Object} 相关属性的设置项，可选
     */
    initialize: function(url,options){
        this.url = url;

        GeoGlobe.Util.extend(this, options);
    },

    //构造查询字串
    _buildRequestStr: function(){
        var string = GeoGlobe.String.format(this._requestStrTemplate,{
            type: this.type,
            layerName:this.layerName,
            bufferRadius:this.bufferRadius,
            bufferStyle:this.bufferStyle,
            bufferType:this.bufferType
        });
        return string;
    },

    /**
     * APIMethod: startCoreBufferAnalysis
     * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
     *
     */
    startAnalysis: function(pageNum){
        //查询前做设置方面检查
        if(this._checkSet()){
            return false;
        }

        //发送分析请求
        var postStr = this._buildRequestStr();
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: postStr,
            scope: this,
            success:function(result){
                if("" == result.responseText || null == result.responseText){
                    this.failFn();
                    return;
                }
                //var features = this._parserResult(result);
                this.successFn(result,pageNum);
            },
            failure:this.failFn

        });
    },

    //检查相关参数设置
    _checkSet: function(){
        if(!this.url){
            return false;
        }
    },

    /**
     * APIMethod: successFn
     * 分析操作成功的回调函数
     *
     * Parameters:
     * features - {Array(<GeoGlobe.Feature>)} 结果要素数组
     */
    successFn:function(features){

    },

    /**
     * APIMethod: failFn
     * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
     * 用户可以使用自定义方法替代。
     */
    failFn:function(){
        alert("缓冲分析操作失败，请检测服务是否正常运行");
    },
    CLASS_NAME:"GeoGlobe.Analysis.CoreBufferAnalysis"

});/**
 * Class: GeoGlobe.Query.Service
 * 服务类。本类是服务类的基类，需要由子类去实现。
 */
GeoGlobe.Query.Service = GeoGlobe.Class4OL({
	
	/**
     * APIProperty: name
     * {String} 服务名称。
     */
	name: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: version
     * {String} 服务版本号。
     */		
	version: null,

	
	/**
     * APIProperty: userid
     * {String} 用户名。
     */			
	userid: "test@liferay.com",
	
	/**
     * Constructor: GeoGlobe.Query.BusQuery
     * GeoGlobe.Query.BusQuery类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},


	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息，由子类实现。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * APIMethod: isExist
     * 检查服务是否存在，由子类实现。
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * APIMethod: failFn
     * 服务操作失败响应回调函数。
     * 
     * operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new GeoGlobe.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "GeoGlobe.Query.Service"
	
});/**
 * Class: GeoGlobe.Query.RouteQuery
 * >说明：本类的findRoute方法以及getRouteInfo方法的成功回调中如果包含exceptionInfo节点，则表示服务查询发生异常。
 * >findRoute方法以及getRouteInfo方法成功回调中返回的异常信息包含两个节点（exceptionInfo节点和exceptionCode节点）。
 * >异常信息的数据结构举例：
 * >{
 * >	exceptionInfo:"终点附近无导航链路",
 * >	exceptionCode:"1002"
 * >} 
 * >其中exceptionInfo表示异常信息的描述;exceptionCode表示异常编码;异常编码取值说明：
 * >1000：服务逻辑或功能异常。
 * >1001：服务未配置路网数据集。（当服务未配置路网数据集并且请求FindRoute与GetRouteInfo接口将返回此异常）。
 * >1002：导航查询的两点之间无通路。（请求FindRoute接口如果无解决方案则返回此异常）。
 * >1003：无匹配的路段信息。（请求GetRouteInfo接口如果无关联请求路段ID的内容则返回此异常）。
 * >1004：请求参数内容不正确。
 * 
 * Inherits from:
 * - <GeoGlobe.Query>
 */
GeoGlobe.Query.RouteQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service, {
	
	/**
	 * Property: _format
	 * 结果解析器。
	 */
	_format: null,
	
	/**
     * Constructor: GeoGlobe.Query.RouteQuery
     * GeoGlobe.Query.Route类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 备用参数，目前暂不使用。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		this._format = new GeoGlobe.Format.RouteQuery();
		GeoGlobe.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn) {
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		GeoGlobe.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息。
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * data - {String} （必选）路网名称。
	 * orig - {String} （必选）起点坐标。   例如："120,30"。
	 * dest -  {String} （必选）终点坐标。
	 * radius — {Number}(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米。
	 * queryType - {Number} (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询。
	 * midpos - {String}(可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * avoidPos - {String}(可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * filterRoute - {Number}(可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0。
	 * resultCount - {Number}(可选) 导航查询返回的最大解决方案数目，参数值必须为正整数，参数默认值为1。
     * 
	 * Example:
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new GeoGlobe.Query.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
			async:false,
            scope: this,
            success: function(result){
				var routes = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routes.exceptionInfo === "string") {
					 successFn(routes);
					 return;
				}
				var routeInfo = new GeoGlobe.Query.RoutesResult(routes);
				//将路线数据转化为GeoJSON类型
				var routeLine = routeInfo.routes;
				var gj = new GeoGlobe.Format.GeoJSON();
				var gjstr = gj.write(routeLine);
				var j = new GeoGlobe.Format.JSON();
				geojsonRoute = j.read(gjstr);
				routeInfo.geojsonRoute = geojsonRoute;
                successFn(routeInfo);
            },
            failure: failFn
        });
	},
	
	/**
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息。
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * data - {String} （必选）路网名称
	 * id - {String} （必选）查询路段的ID名称，可以有0个或多个，多个ID之间以逗号分隔。
	 * 
	 * Example:
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new GeoGlobe.Query.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routeInfo){});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var routeInfo = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routeInfo.exceptionInfo === "string") {
					 successFn(routeInfo);
					 return;
				}
				routeInfo = new GeoGlobe.Query.RouteInfoResult(routeInfo);
            	successFn(routeInfo);
            },
            failure: failFn
        });
	},	

	CLASS_NAME: "GeoGlobe.Query.RouteQuery"
	
});

/**
 * Class: GeoGlobe.Util.Format.RouteQuery
 * 路网导航查询结果解析类，本类供内部调用，用户一般无需使用。
 */
GeoGlobe.Format.RouteQuery = new GeoGlobe.Class4OL(GeoGlobe.Format.XML,{

	/**
	 * Constructor: GeoGlobe.Util.Format.RouteQuery
	 * 构造函数。
	 * 
	 * Parameters:
	 * data - {Object} 服务端生成的原始JSON数据。
	 */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

	/**
	 * APIMethod: read
	 * 读入服务端响应的XML内容并解析为JSON对象返回。
	 * 
	 * Parameters:
	 * data - {String} 服务端响应的XML。
	 * 
     * Returns:
     * {Object | String} JSON对象
     * 说明：当返回结果为字符串时表示查询发生异常。
     */	
    read: function(data) {
        var result = {};
		var routes = [];
		var dataTemp = data;
        if(typeof data == "string") {
			//调用父类的read方法。将xml串转换为dom对象。
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            routes = [];
			//获得根节点名称
			var elName = GeoGlobe.Format.XML.prototype.getChildEl.apply(this, [data]).nodeName;
			//处理异常情况：
			if("ServiceExceptionReport" === elName) {
				//var serviceException = data.getElementsByTagName("ogc:ServiceException")[0];
				var serviceException = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(data, "*", "ServiceException")[0];
				var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [serviceException]);
				var code = serviceException.getAttribute("code");
				return {
					exceptionInfo: text,
					exceptionCode: code
				};
			}
			
			//获取跟节点的子元素
			var nodes = data.getElementsByTagName(elName)[0].childNodes;
			//Todo 如果elName不带前缀的，取整个elName。如果elName带前缀的，则取前缀之后的名称。
			//var nodes = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(data, "*", elName)[0];
			//遍历子节点
            for(var i=0; i<nodes.length; i++){
                var node = nodes[i];
				//获取节点名称
                var nodeName = node.nodeName;
				//判断方法是否存在
                if(this._resultPaser[elName][nodeName]) {
					//使用apply方法改变调用方法的上下文环境
					this._resultPaser[elName][nodeName].apply(this, [node, routes]);
                }
            }
        }
		elName = elName.toLowerCase();
		if("routeinfo" === elName) {
			result["items"] = routes;
		}else {
			result[elName] = routes;
		}
		
        return result;
    },
	
	/**
	 * Property: _resultPaser
	 * 查询结果解析器。
	 */
    _resultPaser: {
		"RouteInfo":{
			"Item": function(node, obj) {
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
	            var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
						this._resultPaser["RouteInfo"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.push(item);
			},
	        "Name": function(node, obj){
				//调用父类的getChildValue方法，并且使用本对象的上下文环境。
				var name = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
	        "Toll": function(node, obj){
				var toll = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.toll = toll;
	        },
			"Level": function(node, obj) {
				var level = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
				obj.level = level;
			},
			"Length": function(node, obj) {
				var length = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Geometry": function(node, obj) {
				//获取gml:LineString节点对象。
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new GeoGlobe.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new GeoGlobe.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Directions": function(node, obj) {
				obj.directions = [];
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
	                    this._resultPaser["RouteInfo"][nodeName](node,obj.directions);
	                }
	            }
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				//获取节点的属性值
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.push(dir);
			}
			//TODO：是否还有可选属性没有加进来，待查
	    },
		"Routes": {
			"Route": function(node, obj) {
				var nodes = node.childNodes;
	            var route = {};
	            for(var i=0; i<nodes.length; i++){
	                var node = nodes[i];
					var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,route]);
	                }
	            }
				obj.push(route);
			},
			"Item": function(node, obj) {
				if(!GeoGlobe.Util.isArray(obj.items)) {
					obj.items = [];
				}
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
				var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.items.push(item);
			},
			"Distance": function(node, obj){
				var distance = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.distance = distance;
			},
			"Name": function(node, obj){
				var name = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
			"Length": function(node, obj) {
				var length = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.direction = dir;
			},
			"Geometry": function(node, obj) {
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new GeoGlobe.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new GeoGlobe.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Duration": function(node, obj) {
				var duration = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.duration = duration;
			},
			"BoundingBox": function(node, obj) {
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,obj]);
	                }
	            }
			},
            "LowerCorner": function(node, obj) {
				var str = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
				var str = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.right = pointList[0];
                obj.top = pointList[1];
                //obj.bounds = new GeoGlobe.Bounds(obj.left, obj.bottom,obj.right, obj.top);
                obj.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(obj.left, obj.bottom),new GeoGlobe.LngLat(obj.right, obj.top));
				//left,bottom,right,top只是临时使用，所以用完后需要清掉。
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
			"Count": function(node, obj) {
				var count = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.count = count;
			}
		}
	}
});/**
 * Class: GeoGlobe.Query.RoutesResult
 * 导航链路信息结果对象。结果对象中包含起点到目的地的所有行走方案。
 */
GeoGlobe.Query.RoutesResult = GeoGlobe.Class4OL({
	
	/**
	 * APIProperty: data
	 * {Object}解析服务返回的XML后，得到的完整JSON对象。
	 */
	data: null,
	
	/**
	 * APIProperty: routes
	 * {Array(GeoGlobe.Query.RouteResult)}  起点到终点的所有行走方案。
	 */
	routes: null,
	
	/**
     * Constructor: GeoGlobe.Query.RoutesResult
     * Geo.Service.GeoRoutesResult类的构造函数。
     *
     * Parameters:
     * data - {Object} JSON对象
     *
     */
	initialize: function(data) {
		this.routes = [];
		var routes = null;
		if(data && data.routes) {
			this.data = data;
			routes = data.routes;
		}
		if(GeoGlobe.Util.isArray(routes)) {
			for(var i = 0, len = routes.length;i < len; i++) {
				var routeObj = new GeoGlobe.Query.RouteResult();
				for(var route in routes[i]) {
					routeObj[route] = routes[i][route];
				}
				this.routes.push(routeObj);
			}
        }
	},

	CLASS_NAME: "GeoGlobe.Query.RoutesResult"
	
});

/**
 * Class: GeoGlobe.Query.RouteResult
 * 起到到终点的一条行走方案。
 */
GeoGlobe.Query.RouteResult = GeoGlobe.Class4OL({
	
	/**
	 * APIProperty: bounds
	 * {GeoGlobe.LngLatBounds}两点间的一条通路的范围
	 */
	bounds: null,
	
	/**
	 * APIProperty: count
	 * {Integer}导航线路包含的路段总数。
	 */
	count: null,
	
	/**
	 * APIProperty: distance
	 * {Number}导航线路总里程，单位为米。
	 */
	distance: null,
	
	/**
	 * APIProperty: duration
	 * {Integer}导航行驶总时间，单位为分钟。
	 *	（导航行驶总时间根据由总里程换算而来，具体换算公式由服务定制）
	 */
	duration: null,
	
	/**
	 * APIProperty: geometry
	 * {Geo.Geometry}线路的几何信息。
	 */
	geometry: null,
	
	/**
	 * APIProperty: items
	 * {Array{object}} 
	 * 	路段元素，可以有零或多个；每个元素包含一个属性id，标识路段的唯一编号；
	 * 	如果路段不在道路上（如起点到某条道路），将不包含路段编号与路段名称。
	 * 
	 * 数组中的对象结构举例:
	 * {
	 * 	id:"33",
	 * 	length: "161",
	 * 	name: "玉兰路",
	 * 	geometry:值为GeoGlobe.Geometry对象,
	 * 	direction: {
	 * 		text:"4",
	 * 		nextID:"8414",
	 * 		nextItem:"佳园路"
	 * 	}
	 * }
	 * 示例中节点说明：
	 * id: 路段id
	 * name:路段名称
	 * length：路段总长，单位为米
	 * geometry:路段行走路线
	 * text:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 * 
	 */
	items: null,
	
	/**
     * Constructor: GeoGlobe.Query.RouteResult
     * GeoGlobe.Query.RouteResult类的构造函数。
     */
	initialize: function() {
		
	},

	CLASS_NAME: "GeoGlobe.Query.RouteResult"
	
});
/**
 * Class: GeoGlobe.Query.RouteInfoResult
 * 路段信息结果类。用于记录路段所在道路的详细信息。
 */
GeoGlobe.Query.RouteInfoResult = GeoGlobe.Class4OL({
	
	/**
	 * APIProperty: data
	 * {Object}解析服务返回的XML后，得到的完整JSON对象。
	 */
	data: null,
	
	/**
	 * APIProperty: items
	 * {Array(GeoGlobe.Query.RouteInfoItem)}
	 * 路段数组。
	 */
	items: null,
	
	/**
     * Constructor: GeoGlobe.Query.RouteInfoResult
     * GeoGlobe.Query.RouteInfoResult类的构造函数。
     *
     * Parameters:
     * data - {Object} JSON对象。
     */
	initialize: function(data) {
		this.items = [];
		if(data && data.items) {
			this.data = data;
			var items = data.items;
		}
		if(GeoGlobe.Util.isArray(items)){
			for(var i = 0, len = items.length;i < len; i++) {
				var routeInfoItem = new GeoGlobe.Query.RouteInfoItem();
				for(var route in items[i]) {
					routeInfoItem[route] = items[i][route];
				}
				this.items.push(routeInfoItem);
			}
        }
	},

	CLASS_NAME: "GeoGlobe.Query.RouteInfoResult"
	
});

/**
 * Class: GeoGlobe.Query.RouteInfoItem
 * 路段对象。从出发点到目的地的路程由一个或多个路段组成。
 */
GeoGlobe.Query.RouteInfoItem = GeoGlobe.Class4OL({
	
	/**
	 * APIProperty: id
	 * {String}路段编号。
	 */
	id:  null,
	
	/**
	 * APIProperty: name
	 * {String}路段名称。
	 */
	name: null,
	
	/**
	 * APIProperty: toll
	 * {Number}路段收费信息，元素值定义：
	 *	0 – 免费路段；
	 *	1 – 部分收费路段；
	 *	2 – 收费路段。
	 *	（路段收费信息匹配路网数据库的特定属性，如果没有该属性则默认值为“0”免费路段）
	 */
	toll: null,
	
	/**
	 * APIProperty: length
	 * {Number}路段行驶的里程，单位为米。
	 */
	length: null,
	
	/**
	 * APIProperty: geometry
	 * {GeoGlobe.Geometry}线路几何信息。
	 */
	geometry: null,
	
	/**
	 * APIProperty: level
	 * {String}道路级别，由路网数据库定义。
	 *	（路段级别一般标识路段的类型；例如路段级别分为1-3级，级别1为普通小路，级别2为城镇公路，级别3为高速公路；如果路网数据库未指定路段级别则默认值为0）
	 */
	level: null,
	
	/**
	 * APIProperty: directions
	 * {Array{Object}} 
	 * 路段朝向。
	 * 
	 * 数组中的对象结构举例:
	 * [
	 * 	{
	 *  	nextID: "4211",
	 *  	nextItem: "红钢二街",
	 *  	direction: 1
	 *  }
	 * ]
	 * 
	 * 示例中节点说明：
	 * direction:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 */
	directions: null,
	
	/**
     * Constructor: GeoGlobe.Query.RouteInfoItem
     * Geo.Service.GeoRouteInfoItem类的构造函数。
     */
	initialize: function() {
		
	},

	CLASS_NAME: "GeoGlobe.Query.RouteInfoItem"
	
});﻿/**
 * Class: GeoGlobe.Query.BusQuery
 * 公交服务类。
 * 
 * Inherits from:
 *  - <Geo.Query>
 */
GeoGlobe.Query.BusQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service,{
	
	/**
	 * APIProperty: networkName
	 * 网络名称。
	 */
	networkName: null,
	
	/**
	 * APIProperty: transferScheme
	 * 换乘方案信息。
	 */
	transferScheme: null,
	
	/**
     * Constructor: GeoGlobe.Query.BusQuery
     * GeoGlobe.Query.BusQuery类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     * 
     * Example:
     * (code)
     *  var url = "http://map.geostar.com.cn:9001/bus_sdk_new/bus";
     *  var busService = new GeoGlobe.Query.BusQuery("公交服务", url);
     * (end)
     */
	initialize: function(name, url,  options){ 
		this.name = name;
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},

	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var params = {
           REQUEST: "GetCapabilities"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + this.url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
	/**
     * APIMethod: isExist
     * 将向服务发送"GetCapabilities"同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};		
		var xhr = GeoGlobe.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},	
	
	/**
     * APIMethod: queryStation
     * 站点查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * stationName - {String} (可选) 站点名称。
     * stationId - {Integer} (可选) 站点ID  必须为正整型。
     * lineId - {Integer} (可选) 线路ID。
     * lineName - {String}  (可选) 线路名称。
     * coordinate - {String} (可选) 站点位置  用逗号分隔XY轴坐标如(X,Y)。
     * bbox - {String} (可选) 矩形范围。
	 *     
     * Example:
     * (code)
     *  //示例1 根据站点名称查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     *  //示例2 根据站点ID查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  //示例3 根据矩形范围查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      bbox : '-1,-1,1,1'
     *  }
     *  (end)
     */	
    queryStation:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStation"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
		
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }
		
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
		
		if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
		
		if(options.coordinate !== null && options.coordinate !== undefined){
        	params.COORDINATE = options.coordinate;
        }   
		
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },

	/**
     * APIMethod: queryLine
     * 线路查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * lineName - {String} (可选) 线路名称。
     * lineId - {Integer} (可选) 线路ID。
     * stationName - {String} (可选) 站点名称。
     * stationId - {Integer} (可选) 站点ID。
     * coordinate - {String} (可选) 站点位置。
     * bbox - {String} (可选) 矩形范围。
     *       
     * Example:
     * (code)
     *  //示例1 根据站点名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     * //示例2 根据站点ID查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     * //示例3 根据路线名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      lineName : '4'
     *  }
     *  (end)
     */	
    queryLine: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLine"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }    
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }    
                
        if(options.coordinate !== null && options.coordinate !== undefined){
            params.COORDINATE = options.coordinate;
        }   
                     
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },
    
	/**
     * APIMethod: queryChange
     * 公交换乘方案查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * startStationId - {Integer} (可选) 起始站点ID。
     * endStationId - {Integer} (可选) 终止站点ID。
     * startCoordinate - {String} (可选) 起始站点坐标。
     * endCoordinate - {String} (可选) 起始站点坐标。
     * maxDepth - {Integer}(可选) 最大边数范围,正整型参数,没有则默认值为5。
     * maxCost - {Float} (可选) 最大权值范围,正双精度符点型参数,没有则默认为100.0。
     * maxSolutions - {Integer} (可选) 最多解决方案数量,正整型参数,没有则默认为5。
     * orderType - {String}(可选) 值为LeastCost时表示较快捷，值为LeastWalk时表示少步行，值为LeastChange时表示少换乘。
     * 
     * Example:
     * (code)
     *  busService.queryChange({
     *      networkName: "BusChangeModule",
     *        startStationId: "238",
     *        endStationId: "25",
	 *		  maxDepth:5,
	 *		  maxCost:100.0,
	 *		  maxSolutions:5,
	 *		  //orderType表示换乘的类型。LeastCost表示较快捷，用户还可以选择LeastWalk或LeastChange，LeastWalk表示少步行，值为LeastChange时表示少换乘
	 *		  orderType:"LeastCost" 
     *  })
     *  (end)
     */	
    queryChange: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryChange"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.startStationId !== null && options.startStationId !== undefined){
            params.STARTSTATIONID = options.startStationId;
        }
        
        if(options.endStationId !== null && options.endStationId !== undefined){
            params.ENDSTATIONID = options.endStationId;
        }
		
		if(options.orderType !== null && options.orderType !== undefined){
            params.ORDERTYPE = options.orderType;
        }
        
        if(options.startCoordinate !== null && options.startCoordinate !== undefined){
            params.STARTCOORDINATE = options.startCoordinate;
        }    
        
        if(options.endCoordinate !== null && options.endCoordinate !== undefined){
            params.ENDCOORDINATE = options.endCoordinate;
        }  
		
		if(options.maxDepth !== null && options.maxDepth !== undefined){
            params.MAXDEPTH = options.maxDepth;
        } 
		
		if(options.maxCost !== null && options.maxCost !== undefined){
            params.MAXCOST = options.maxCost;
        }  
		
		if(options.maxSolutions !== null && options.maxSolutions !== undefined){
            params.MAXSOLUTIONS = options.maxSolutions;
        }  
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		  
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
            	var  featureCollection = [];
				var resXML;//= result.responseXML;
				if (!result.responseXML.documentElement) {
					resXML = format.read(result.responseText);
				}
				else {         
					resXML = result.responseXML;
				}       

				var docElement = resXML.selectNodes("/Features/FeatureCollection");
				
            	var xmlparser = new GeoGlobe.Format.XML();
				
            	for(var i = 0; i < docElement.length; i++) {
					//获取FeatureCollection元素节点的属性
					var featureCollectionElement = docElement[i];
					var attArray = ['cost','price','walkingDistance','transferTimes'];
					var attributionObj = this._getAttibutionOfNode(featureCollectionElement, attArray);
					
					var str = xmlparser.write(docElement[i]);
					var features = this._parserFeatures(str);
					//features或featureCollectionElement相当于一个FeatureCollection
					features.attributes= attributionObj;
					var featureMember = featureCollectionElement.selectNodes("featureMember");
					for(var j = 0; j < featureMember.length; j++) {
						var road = featureMember[j].selectNodes("Road");
						//线路添加是否步行属性：isOnFoot
						features[j]["isOnFoot"] = road[0].getAttribute("isOnFoot");
					}
	            	featureCollection.push(features);
            	}

                successFn(featureCollection);
            },
            failure: failFn
        });

    },
	
	//根据节点得到节点的属性
	_getAttibutionOfNode: function(node, keyArray) {
		//获取FeatureCollection属性信息
		var fcAttibution = {};
		if(node.tagName){
			for(var i = 0; i < keyArray.length; i++) {
				fcAttibution[keyArray[i]] = node.getAttribute(keyArray[i])
			}
	    }
		return fcAttibution;
	},
   
    _getGeometryType: function(geometry){
        var maping = {
            "GeoGlobe.Geometry.Point": "point",
            "GeoGlobe.Geometry.LineString": "line",
            "GeoGlobe.Geometry.Polygon": "polygon"
        };
        return "polygon";
    },
    
    _pagingToString: function(curPage,maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property,type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        return '<geometry>'+
                    '<Polygon>'+
                        '<outerBoundaryIs>'+
                            '<LinearRing>'+
                                '<coordinates decimal="." cs="," ts=" ">20,30 21,41 52,42 53,33 20,30</coordinates>'+
                            '</LinearRing>'+
                        '</outerBoundaryIs>'+
                    '</Polygon>'+
                '</geometry>';
    },
    
    _stringToGeometry: function(string){
        return GeoGlobe.Geometry.Polygon.createRegularPolygon(
            new GeoGlobe.Geometry.Point( Math.random()*360 - 160, 
                                           Math.random()*90 - 70 ),
            Math.round(Math.random()*20),
            Math.round(Math.random()*10)
        );
    },
	
    _parserFeatures: function(resultString){
        var parser = new GeoGlobe.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(resultString);
        return features;
    },
	
	// 把节点名称所在的节点外套上<featureMember></featureMember>
	_parserResponseText: function(resultString, nodeName){
		if(nodeName){
			var re1 = new RegExp("<" + nodeName + ">", ["g"]);
	        var re2 = new RegExp("</" + nodeName + ">", ["g"]);
			
	        resultString = resultString.replace(re1, "<featureMember><" + nodeName + ">");
	        resultString = resultString.replace(re2, "</" + nodeName + "></featureMember>");
		}
		
		resultString = resultString.replace(/<gml:LineString>/g,"<gml:LineString><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:LineString>/g,"</gml:coordinates></gml:LineString>");
		resultString = resultString.replace(/<gml:Point>/g,"<gml:Point><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:Point>/g,"</gml:coordinates></gml:Point>");
		return resultString;
	},
	
	_parserFeaturesNew: function(resultString, featureName){
		var parser = new GeoGlobe.Format.GML();
        parser.gmlns = "*";
		if(featureName){
			parser.featureName = featureName;
		}
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);

	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Format.XML2JSON();
		return parser.read(result);
	},
	
	/**
	 * APIMethod: queryTransferScheme
	 * 根据始终点的空间坐标或一组起始站点ID和一组终止站点的ID，查询公交换乘的文字信息，必要时也查询出第一条方案的几何信息。（公交2.0）
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function}请求成功的回调函数。
	 * failFn - {Function}请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * networkName {String} (必选) 网络模型名称。
	 * transferMode - {Integer} (必选) 换乘模式  ,有三种值：0-较快捷   1-少换乘  2-少步行。
	 * startInput - {String} (必选) 始点信息，可以是坐标信息也可也是ID类型（坐标类型,格式为:x y。分隔符为空格符；ID类型,格式为:id,… ,id。分隔符为逗号）。
	 * endInput - {String} (必选)终点信息支持坐标与ID类型:坐标类型,格式为:x y。分隔符为空格符ID类型,格式为:id,… ,id。分隔符为逗号。
	 * inputMode - {Integer}(可选)始终点输入模式,值为0|1|2: 0-坐标,1-车站外部唯一编号,2-车站内部唯一编号（当前服务没有外部唯一编号）。
	 * ComputeModel	
	 * transferSubset
	 * existGoTime
	 * startTime
	 * specificSubset
	 * maxSearchDistance
	 * computeSort
	 * transferPolicy
	 * resultSort
	 * prioritySubset
	 * existAbsolutePriority
	 * lagSubset
	 * outputPage
	 * pageSize
	 * changeCount
	 */
	queryTransferScheme: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferScheme",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		//四个必选参数
		var required = {
			networkName:true,
            transferMode: true,
            startInput: true,
			endInput: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("缺少必选属性：'" + prop + "'。");
            }
        }
		params.networkName = options.networkName;
		
		//这样判断的原因是为了避免0,1这样的值在进行if判断的时候被当做false把参数给过滤掉；""串不需要被过滤，这个已经向服务组确认
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if(options.transferMode !== null && options.transferMode !== undefined) {
			params.TRANSFERMODE = options.transferMode;
        }
		if(options.startInput !== null && options.startInput !== undefined) {
			params.STARTINPUT = options.startInput;
        }
		if(options.endInput !== null && options.endInput !== undefined) {
			params.ENDINPUT = options.endInput;
        }
		if(options.inputMode !== null && options.inputMode !== undefined) {
			params.INPUTMODEL = options.inputMode;
        }
		if (options.ExistGoTime !== null && options.ExistGoTime !== undefined) {
			params.EXISTGOTIME = options.ExistGoTime;
        }
		if (options.StartTime !== null && options.StartTime !== undefined) {
			params.STARTTIME = options.StartTime;
        }
		if (options.MaxSearchDistance !== null && options.MaxSearchDistance !== undefined) {
			params.MAXSEARCHDISTANCE = options.MaxSearchDistance;
		}
		if (options.PrioritySubset !== null && options.PrioritySubset !== undefined) {
			params.PRIORITYSUBSET = options.PrioritySubset;
        }
		if (options.ExistAbsolutePriority !== null && options.ExistAbsolutePriority !== undefined) {
			params.EXISTABSOLUTEPRIORITY = options.ExistAbsolutePriority;
        }
		if (options.LagSubset !== null && options.LagSubset !== undefined) {
			params.LAGSUBSET = options.LagSubset;
        }
		if (options.OutputPage !== null && options.OutputPage !== undefined) {
			params.OUTPUTPAGE = options.OutputPage;
        }
		if (options.PageSize !== null && options.PageSize !== undefined) {
			params.PAGESIZE = options.PageSize;
        }
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: GeoGlobe.Function.bind(function(result){
				var resXML = result.responseXML;
                var features = {
                    startPoint: [],
                    transferScheme: [],
                    endPoint: []
                };	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				
				var element = resXML.selectNodes("/QueryTransferSchemeResponse");	
				var elementXMLStr = xmlparser.write(element[0]);
				// XML解析成json对象
				var jsonObj = this._parseToJSON(elementXMLStr);
				var startPoint = jsonObj.QueryTransferSchemeResponse.StartPoint;
				if (!GeoGlobe.Util.isArray(startPoint)) {
		            startPoint = [startPoint];
		        }
				var endPoint = jsonObj.QueryTransferSchemeResponse.EndPoint;
				if (!GeoGlobe.Util.isArray(endPoint)) {
		            endPoint = [endPoint];
		        }
				var transferScheme = jsonObj.QueryTransferSchemeResponse.TransferScheme;
				
				// 起点要素
                var startPointGeometry = this._getPointGeometryByGMLPointStr(startPoint[0].Geometry.gml_Point);
            	var startPointFeature = new GeoGlobe.Feature(startPointGeometry);
				// 终点要素
                var endPointGeometry = this._getPointGeometryByGMLPointStr(endPoint[0].Geometry.gml_Point);
            	var endPointFeature = new GeoGlobe.Feature(endPointGeometry);
				// 换乘要素
				var transferSchemeFeatures = this._parserTransferScheme(transferScheme);
				
                features = {
                    startPoint: startPointFeature,
                    transferScheme: transferSchemeFeatures,
                    endPoint: endPointFeature
                };
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	// 解析换乘要素
    _parserTransferScheme: function(transferSchemeObjs){
		if (!GeoGlobe.Util.isArray(transferSchemeObjs)) {
            transferSchemeObjs = [transferSchemeObjs];
        }
        var transferSchemeFeatures = new Array();
        for (var i = 0; i < transferSchemeObjs.length; i++) {
			var transferSchemeObj = transferSchemeObjs[i];
			// 解析片段信息
			var SectionInfo = this._parserSectionInfo(transferSchemeObj.SectionInfo);
			// 解析片段步行
			var SectionRoutingFeatures = this._parserSectionRouting(transferSchemeObj.SectionRouting);
            
			var transferSchemeFeature = {
                Cost: transferSchemeObjs[i].Cost,
                SectionInfo: SectionInfo,
                SectionRouting: SectionRoutingFeatures,
                TotalDistance: transferSchemeObjs[i].TotalDistance,
                TransferCount: transferSchemeObjs[i].TransferCount
            };
            transferSchemeFeatures.push(transferSchemeFeature);
        }
        return transferSchemeFeatures;
    },
	
	// 解析片段信息
    _parserSectionInfo: function(sectionInfoObjs){
		if (!GeoGlobe.Util.isArray(sectionInfoObjs)) {
            sectionInfoObjs = [sectionInfoObjs];
        }
		var sectionInfos = new Array();
		for (var i = 0; i < sectionInfoObjs.length; i++) {
			
			// 上车点要素
			var fromStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation);
			if (sectionInfoObjs[i].FromStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation.PassagewayRouting);
				if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
                fromStationFeature.attributes.PassagewayRouting = fromStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 下车点要素
			var toStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation);
			if (sectionInfoObjs[i].ToStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation.PassagewayRouting);
                if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
				toStationFeature.attributes.PassagewayRouting = toStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 线路要素
			var sectionLine = this._parserSectionLines(sectionInfoObjs[i].SectionLines.SectionLine);
			var sectionRouting = this._parserSectionRouting(sectionInfoObjs[i].SectionRouting);
			
			sectionInfos.push({
				FromStation: fromStationFeature,
				SectionLine: sectionLine,
				ToStation: toStationFeature,
				SectionRouting: sectionRouting
			});
		}
		return sectionInfos;
	},
	
	// 解析片段信息内的片段线路
    _parserSectionLines: function(sectionLineObjs){
        if (!GeoGlobe.Util.isArray(sectionLineObjs)) {
            sectionLineObjs = [sectionLineObjs];
        }
		var sectionLineFeatures = new Array();
		for (var i = 0; i < sectionLineObjs.length; i++) {
            var sectionLineFeature = new GeoGlobe.Feature(null, sectionLineObjs[i]);
			sectionLineFeatures.push(sectionLineFeature);
		}
		return sectionLineFeatures;
	},
	
	// 解析片段步行
    _parserSectionRouting: function(sectionRoutingObjs){
		// TODO
        if (!GeoGlobe.Util.isArray(sectionRoutingObjs)) {
            sectionRoutingObjs = [sectionRoutingObjs];
        }
		var sectionRoutingFeatures = new Array();
		for (var i = 0; i < sectionRoutingObjs.length; i++) {
			sectionRoutingFeatures.push(sectionRoutingObjs[i]);
		}
		return sectionRoutingFeatures;
	},
	
	// -----根据点串得到点对象
	_getPointGeometryByGMLPointStr: function(pointStr) {
		var pointArr = pointStr.split(",");
		var point = new GeoGlobe.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
		return point;
	},
	
	// 解析站点或出入口点的要素
    _getPointFeatureByObj: function(pointInfoObj){
        var pointGeometry = null;
        if (pointInfoObj.Geometry && pointInfoObj.Geometry.gml_Point) {
            pointGeometry = this._getPointGeometryByGMLPointStr(pointInfoObj.Geometry.gml_Point);
        }
        var pointFeature = new GeoGlobe.Feature(pointGeometry, pointInfoObj);
        return pointFeature;
    },
	
	// -----根据id等信息获取geometry串并生成geometry对象
    _getLineGeometryByGMLLineStr: function(geometryStr){
        if (!geometryStr) {
            return null;
        }
        var pointStrArr = geometryStr.split(" ");
        var pointArr = [];
        for (var i = 0, j = pointStrArr.length; i < j; i++) {
            var pointGeometry = this._getPointGeometryByGMLPointStr(pointStrArr[i]);
            pointArr.push(pointGeometry);
        }
        var lineGeometry = new GeoGlobe.Geometry.LineString(pointArr);
        return lineGeometry;
    },
	
	/**
	 * APIMethod: queryTransferGeometry
	 * 根据线路ID或者步行ID来获取相应的线要素（公交2.0。注意：这些线要素不包含属性信息）。
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 
	 * options请求参数属性可为:
	 * networkName - {String} (必选) 网络模型名称。
	 * parameterInfo - {Arrays} 取值格式：[[geometryTypeID,geometryInfoID,FromOrdinal,ToOrdinal]]例如[[0,10,22,24]]。
	 * geometryTypeID - {Integer} (必选) 0-线路内部ID,1-步行路由内部ID。如果这个属性的值为1，那么FromOrdinal和ToOrdinal这两个属性的的值就都为0。
	 * geometryInfoID - {Integer}几何信息 的ID。
	 * FromOrdinal -  {Integer} (必选) 起点序号。
	 * ToOrdinal -  {Integer} (必选) 终点序号。
	 */
	queryTransferGeometry: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferGeometry",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.parameterInfo === null || options.parameterInfo === undefined || options.parameterInfo === ""){
            throw "Error!Not parameterInfo for bus query.";
            return;
        }
		params.networkName = options.networkName;
		params.PARAMETERINFO = "";
        for (var i = 0; i < options.parameterInfo.length; i++) {
            params.PARAMETERINFO += options.parameterInfo[i].toString();
            if (i != options.parameterInfo.length - 1) {
                params.PARAMETERINFO += "_";
            }
        }
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: GeoGlobe.Function.bind(function(result){
				var features = this._parseQueryTransferGeometryResult(result);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析QueryTransferGeometry接口返回结果 -----获取线路要素
	_parseQueryTransferGeometryResult: function(result) {
		resXML = result.responseXML;
		var features = [];
		if(!resXML) {
			return features;
		}
		var xmlparser = new GeoGlobe.Format.XML();
		var geometrysStrTemp = resXML.selectNodes("/QueryTransferGeometryResponse");	
		//没有查询到数据的情况
		if(geometrysStrTemp && geometrysStrTemp.length <= 0) {
			return features;
		}
		var geometrysXMLStr = xmlparser.write(geometrysStrTemp[0]);
		var geometrysXMLObj = this._parseToJSON(geometrysXMLStr);
		var geometrys = geometrysXMLObj.QueryTransferGeometryResponse.SectionGeometry;	
		
		if(geometrys) {
			if(!GeoGlobe.Util.isArray(geometrys)) {
				geometrys = [geometrys];
			}
			//得到一个个站点
			for(var i = 0 ;i < geometrys.length; i++)  {
				//得到几何对象
				var geometryTemp = this._getLineGeometryByGMLLineStr(geometrys[i].Geometry.gml_LineString);
				//得到线要素
                var lineFeature = new GeoGlobe.Feature(geometryTemp, {
                    ID: geometrys[i].ID
                });
				features.push(lineFeature);
			}
		}
		return features;
	},
	
	/**
	 * APIMethod: queryKeyWord
	 * 根据关键字来获取线路信息或者站点信息或者出入口信息。（公交2.0）
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 
	 * options请求参数属性可为:
	 * networkName - {String} (必选) 网络模型名称。
	 * keyWord - {String} (必选)查询关键字。
	 * searchType - {Integer} (可选) 查询类型，默认值为 2，查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊默认值为2。
	 * keyWordType - {Integer} (可选) 查询关键字类型，默认值为 -1，可供选择的值为-1|0|1|2:-1:先查线路，然后查车站，最后查出入口0-查线路，1-查车站，2-查出入口。
	 *     
	 * Returns:
	 * {Array(GeoGlobe.Feature)} 返回的是出入口、站点、线路要素。
	 */
	queryKeyWord: function(options, successFn, failFn) {
		var params = {
			REQUEST: "QueryKeyWord",
			SERVICE: "BUS",
			VERSION: "1.0.0",
			SEARCHTYPE: 2
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.keyWord === null || options.keyWord === undefined || options.keyWord === ""){
            throw "Error!Not keyWord for bus query.";
            return;
        }
		params.NETWORKNAME = options.networkName;
		params.KEYWORD = options.keyWord;
		
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if (options.searchType !== null && options.searchType !== undefined) {
        	params.SEARCHTYPE = options.searchType;
        }
		if (options.keyWordType !== null && options.keyWordType !== undefined) {
        	params.KEYWORDTYPE = options.keyWordType;
        }
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: GeoGlobe.Function.bind(function(result){
				var features = this._parserQueryKeyWordResult(result,options.keyWordType);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析queryKeyWord接口返回结果 -----获取站点或出入口或线路文字描述信息
	_parserQueryKeyWordResult: function(result,keyWordType) {
		var resXML = result.responseXML;
		var features = [];	
		if(!resXML) {
			return features;
		}
		var xmlparser = new GeoGlobe.Format.XML();
		var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
		//没有查询到数据的情况
		if(errorTemp && errorTemp.length > 0) {
			return features;
		}
		var objectsStrTemp = resXML.selectNodes("/QueryKeyWordResponse");	
		var objectsXMLStr = xmlparser.write(objectsStrTemp[0]);
		var objectsXMLObj = this._parseToJSON(objectsXMLStr);
		
		// 0-查线路，1-查车站，2-查出入口
        if (keyWordType === 1) {
            var stations = objectsXMLObj.QueryKeyWordResponse.Stations.Station;
			if (stations && !(GeoGlobe.Util.isArray(stations))) {
				stations = [stations];
			}
            for (var i = 0; i < stations.length; i++) {
                var pointFeature = this._getPointFeatureByObj(stations[i]);
                features.push(pointFeature);
            }
        } else if (keyWordType === 2) {
            var passageways = objectsXMLObj.QueryKeyWordResponse.Passageways.Passageway;
			if (passageways && !(GeoGlobe.Util.isArray(passageways))) {
				passageways = [passageways];
			}
            for (var i = 0; i < passageways.length; i++) {
                var pointFeature = this._getPointFeatureByObj(passageways[i]);
                features.push(pointFeature);
            }
        } else {
            var lines = objectsXMLObj.QueryKeyWordResponse.Lines.Line;
			if (lines && !(GeoGlobe.Util.isArray(lines))) {
				lines = [lines];
			}
            for (var i = 0; i < lines.length; i++) {
                var lineFeature = new GeoGlobe.Feature(null,lines[i]);
                features.push(lineFeature);
            }
        }
		return features;
	},
	
	/**
     * APIMethod: queryStationInfo
     * 站点查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * stationId - {Integer} (必选) 站点ID  必须为正整型。
     *   
     *       
     * Example:
     * (code)
     *  busService.queryStationInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */	
    queryStationInfo:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStationInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.stationId === null || options.stationId === undefined || options.stationId === ""){
            throw "Error!Not stationId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
        
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				resXML = result.responseXML;
				if(!resXML) {
					var features = {
						lines:[],
						passageways:[]
					};
	                successFn(features);
					return;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				
				//根据节点名字，解析成对象
				var lines = this._parserQueryStationInfoNode("Lines", xmlparser, resXML);
				var passageways = this._parserQueryStationInfoNode("Passageways", xmlparser, resXML);
                
				//解析后转feature
				var passagewaysFeature = new Array();
                for (var i = 0; i < passageways.length; i++) {
					var pointFeature = this._getPointFeatureByObj(passageways[i]);
					passagewaysFeature.push(pointFeature);
                }
		
				var features = {
					lines: lines,
					passageways: passagewaysFeature
				};
                successFn(features);
            },
            failure: failFn
        });

    },
	
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryStationInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Lines":
                //解析lines
	            var element = resXML.selectNodes("/QueryStationInfoResponse/StationInfo/Lines");
	            var lines = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
	                lines = jsonObj.Lines.Line;
	                if (!(GeoGlobe.Util.isArray(lines))) {
	                    lines = [lines];
	                }
	            }
	            return lines;
                break;
            case "Passageways":
                //解析Passageways
	            var element = resXML.selectNodes("/QueryStationInfoResponse");
	            var passageways = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
					var passagewaysJson = jsonObj.QueryStationInfoResponse.StationInfo.Passageways;
					if(passagewaysJson){
						passageways = passagewaysJson.Passageway;
		                if (!(GeoGlobe.Util.isArray(passageways))) {
		                    passageways = [passageways];
		                }
					}
	            }
	            return passageways;
                break;
            default:
				return [];
                break;
        }
    },
    
    /**
     * APIMethod: queryLineInfo
     * 线路查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * lineId - {Integer} (必选) 线路ID。
     * STARTNODENUMBER - {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * ENDNODENUMBER - {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * 
     * Example:      
     * (code)
     *  busService.queryLineInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */
    queryLineInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLineInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.lineId === null || options.lineId === undefined || options.lineId === ""){
            throw "Error!Not lineId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.startNodeNumber !== null && options.startNodeNumber !== undefined){
            params.STARTNODENUMBER = options.startNodeNumber;
        }    
                
        if(options.endNodeNumber !== null && options.endNodeNumber !== undefined){
            params.ENDNODENUMBER = options.endNodeNumber;
        }   
                     
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
//				// 传入包含gml的结点名称
//				var resultString = this._parserResponseText(result.responseText, "Line");
//				var features = this._parserFeaturesNew(resultString);
//				
//				// 线路所包含的站点要素
//				var resultStationString = this._parserResponseText(result.responseText, "Station");
//				var stationFeatures = this._parserFeaturesNew(resultStationString);
//                features[0].attributes.Stations = features[0].data.Stations = stationFeatures;
//				
//				successFn(features);
//				return;
				
				var features = [];
				var resXML = null;
				if(result.responseXML) {         
					resXML = result.responseXML;
					var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
					//没有查询到数据的情况
					if(errorTemp && errorTemp.length > 0) {
						successFn(features);
						return;
					}
					var xmlparser = new GeoGlobe.Format.XML();
					//根据节点名字，解析成对象
					var line = this._parserQueryLineInfoNode("Line", xmlparser, resXML);
					//解析后转feature
					var lineFeatures = new Array();
	                for (var i = 0; i < line.length; i++) {
						//线路内站点信息转要素
						var stationFeatures = new Array();
	                    for (var j = 0; j < line[i].VIAStations.Station.length; j++) {
							//得到点要素
	                    	var stationFeature = this._getPointFeatureByObj(line[i].VIAStations.Station[j]);
							stationFeatures.push(stationFeature);
	                    }
						line[i].Stations = stationFeatures;
						//得到线几何对象
						var lineGeometry = this._getLineGeometryByGMLLineStr(line[i].Geometry.gml_LineString);
						//得到线要素
	                    var lineFeature = new GeoGlobe.Feature(lineGeometry, line[i]);
						lineFeatures.push(lineFeature);
	                }
			
					features = lineFeatures;
				}
				successFn(features);
            },
            failure: failFn
        });

    },
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryLineInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Line":
                //解析line
	            var element = resXML.selectNodes("/QueryLineInfoResponse");
				var xmlObj = xmlparser.write(element[0]);
                var jsonObj = this._parseToJSON(xmlObj);
				var l = jsonObj.QueryLineInfoResponse.Line;
				
	            var lines = new Array();
                if (l && !(GeoGlobe.Util.isArray(l))) {
                    lines = [l];
                }else{
					lines = l;
				}
	            return lines;
                break;
            default:
				return [];
                break;
        }
    },
	
	/**
     * APIMethod: queryPassagewayInfo
     * 根据出入口ID获取与此出入口有关的站点信息，包括出入口所对应的车站信息。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * passagewayId - {Integer} (必选) 出入口ID。
     * 
     * Example:      
     * (code)
     *  busService.queryPassagewayInfo({
     *      networkName: "BusChangeModule",
     *      passagewayId : 2
     *  }
     *  (end)
     */
    queryPassagewayInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryPassagewayInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.passagewayId === null || options.passagewayId === undefined || options.passagewayId === ""){
            throw "Error!Not passagewayId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.passagewayId !== null && options.passagewayId !== undefined){
            params.PASSAGEWAYID = options.passagewayId;
        }
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var resXML = result.responseXML;
				var features = [];	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				var responseText = this._parserResponseText(result.responseText);
				features = this._parserFeaturesNew(responseText, "Stations");
				successFn(features);
            }
        });
	},
	
	
	/**
     * method: _queryByName
     * 根据起点终点名称得到对应的坐标信息
     * 根据坐标信息请求_queryTransferScheme查询换乘方案信息
     *
     * Parameters:
     * startName - {String} 起点名称。
     * endName - {String} 终点名称。
     * transferMode - {String} 选择方式
     *
     * Returns:
     * {Object}换乘方案信息
     * 
     * 返回对象属性包含：
     * startPoint 起点要素
     * transferScheme 所有换乘方案信息
     * endPoint 终点要素
     */
    _queryByName: function(startName,endName,transferMode){
    	var that = this;
    	var featuresInfo = null;
    	 //查询起点信息
         that.queryKeyWord({
             networkName: that.networkName,
             keyWord: startName,
             keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
             SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
         }, function(feature){
               if (feature.length == 0) {
				   alert("没有查询到起点");
	               return;
               }
			   var startPoint = feature[0].geometry.x + " " +feature[0].geometry.y;
			   //查询终点信息
			   that.queryKeyWord({
	               networkName: that.networkName,
	               keyWord: endName,
	               keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
	               SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
       		  }, function(feature){
		            if (feature.length == 0) {
						alert("没有查询到终点");
		           		return;
		      		}
		   			var endPoint = feature[0].geometry.x + " " + feature[0].geometry.y;
		   			featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
		    	});
			});
			return featuresInfo;
    },
	
	/**
     * APIMethod: queryBus
     * 根据parameter1、parameter2、transferMode查询公交换乘方案。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得服务的networkName。
     * 根据得到的参数请求_queryTransferScheme方法得到换乘方案信息 
     *
     * Parameters:
     * parameter1 - {<GeoGlobe.LngLat> | String} 起点经纬度或者起点名称。
     * parameter2 - {<GeoGlobe.LngLat> | String} 终点经纬度或者终点名称。
     * transferMode - {String} 选择方式 0-较快捷   1-少换乘  2-少步行
     *
     * Returns:
     * {Object}换乘方案信息
     * {flag:服务正常返回换乘信息为true,否则为false,featuresInfo：换乘方案信息}
     *
     */
    queryBus: function(parameter1, parameter2,transferMode){
    	var that = this;
    	var featuresInfo = null;
    	that.getCapabilities(GeoGlobe.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new GeoGlobe.Format.BusCapabilities();
            var capabilities = format.read(data);
			if(capabilities.capability){
	            var layerName = capabilities.capability.networks[0];
	            that.networkName = layerName;
	            if(typeof(parameter1) == "string" && typeof(parameter2) == "string"){//站点名称查询
	            	featuresInfo = that._queryByName(parameter1,parameter2,transferMode);
	            }else{//坐标查询
	            	var startPoint = parameter1.lng + " " +parameter1.lat;
	            	var endPoint = parameter2.lng + " " + parameter2.lat;
	            	featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
	            }
			}else{
				alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            	"请求地址：" + url + "\n操作类型：GetCapabilities");
			}
        }, this),
		function(){
            alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        var featureData = {
        	flag:featuresInfo ? true : false,
        	featuresInfo:featuresInfo
        }
        return featureData;
    },
    
    
    failFn: function(){
		alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
	},
	
	 /**
	  * Method: _queryTransferScheme
	  * 查询换乘方案信息
	  * 根据startPoint、endPoint、transferMode、networkName查询公交换乘方案。
	  *
      * Parameters:
      * url - {String} 公交服务地址。
      * startPoint - {<GeoGlobe.Geometry.Point>} 起点坐标。
      * endPoint - {<GeoGlobe.Geometry.Point>} 终点坐标。
      * transferMode - {String} 选择方式 0-较快捷   1-少换乘  2-少步行
      *
      * Returns:
      * {Object}换乘方案信息
      * 
      * 返回对象属性包含：
      * startPoint 起点要素
      * transferScheme 所有换乘方案信息
      * endPoint 终点要素
	  *
	  */
	_queryTransferScheme: function(startPoint,endPoint,transferMode){
		var lineFeatures =  null;
        this.queryTransferScheme({
	         networkName: this.networkName,
	         transferMode: transferMode ? transferMode : 0,//0-较快捷   1-少换乘  2-少步行
	         inputMode: 0,//默认为0。0：传坐标。2：传ID。
	         startInput: startPoint,
	         endInput: endPoint
	    }, function(features){
	     	featuresInfo = features;
	    });
	    this.transferScheme = featuresInfo.transferScheme;
	    return featuresInfo;
	},
	
	/**
	 *
	 * APIMethod: queryBusTransferSchemeByIndex
	 * 根据sortIndex查询单条换乘方案几何信息。
	 *
     * Parameters:
     * sortIndex - {String} 换乘方案索引值。
     *
     * Returns:
     * {Object}换乘方案几何信息
     * {lineFeatures:方案线要素 ,stationFeatures:换乘方案的起始点要素}
	 *
	 */
	queryBusTransferSchemeByIndex: function(sortIndex){
		var busSer = null;
		var lineData = null;
		var sortIdx = parseInt(sortIndex);
        var transferScheme = this.transferScheme[sortIdx];
        var sectionInfo = transferScheme.SectionInfo;
        
        //查询参数。
        var parameterInfo = new Array();
        var transferPointFeatures = new Array();
        for (i = 0; i < sectionInfo.length; i++) {
            var type = 0;
            var lineFeature = sectionInfo[i].SectionLine[0];
            var lineId = lineFeature.data.ID;
            var fromOrdinal = lineFeature.data.FromOrdinal;
            var toOrdinal = lineFeature.data.ToOrdinal;
            
            parameterInfo.push([type, lineId, fromOrdinal, toOrdinal]);
            transferPointFeatures.push(sectionInfo[i].FromStation);
            transferPointFeatures.push(sectionInfo[i].ToStation);
        }
        
        this.queryTransferGeometry({
            networkName: this.networkName,
            //单条几何信息的ID的类型(0或者1)，几何信息的ID(line:LID)，起点序号(upStation:NodeNumber)，终点序号(downStation:NodeNumber)；
            parameterInfo: parameterInfo//[[0, 67, 24, 60], [0, 221, 31, 85]]
        }, function(features){
            var lineFeatures = features;
            //将lineFeatures和transferPointFeatures转化为geojson数据类型
            var gjformat = new GeoGlobe.Format.GeoJSON();
			var geojsonRouteStr = gjformat.write(lineFeatures);
			var geojsonStationStr = gjformat.write(transferPointFeatures);
			var jformat = new GeoGlobe.Format.JSON();
			var geojsonRoute = jformat.read(geojsonRouteStr);
			var geojsonStation = jformat.read(geojsonStationStr);
			
            var data = {
            	lineFeatures:lineFeatures,
            	geojsonRoute:geojsonRoute,
            	stationFeatures: transferPointFeatures,
            	geojsonStation:geojsonStation
            }
            lineData = data;
        });
        return lineData;
	},
	
	
	
	CLASS_NAME: "GeoGlobe.Query.BusQuery"
});

//FF,chrome兼容selectNodes,selectSingleNode
(function xmlNodesTool(){
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectNodes = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            //name space resolver defined  
            function nsResolver(prefix){
                var ns = {
                    'csw': 'http://www.opengis.net/cat/csw',
                    'smmd': 'http://data.sbsm.gov.cn/smmd/2007',
                    'wfs': 'http://www.opengis.net/wfs',
                    'gml': 'http://www.opengis.net/gml',
                    'geoglobe': 'http://www.geostar.com.cn/geoglobe'
                };
                return ns[prefix] || null;
            }
            //var oNSResolver = this.createNSResolver(this.documentElement||this.ownerDocument.documentElement)||nsResolver;
            var aItems = this.evaluate(cXPathString, xNode, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var aResult = [];
            for (var i = 0; i < aItems.snapshotLength; i++) {
                aResult[i] = aItems.snapshotItem(i);
            }
            return aResult;
        };
        
        // prototying the Element 
        Element.prototype.selectNodes = function(cXPathString){
            if (this.ownerDocument.selectNodes) {
                return this.ownerDocument.selectNodes(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
        
    }
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectSingleNode = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            var xItems = this.selectNodes(cXPathString, xNode);
            if (xItems.length > 0) {
                return xItems[0];
            }
            else {
                return null;
            }
        };
        
        // prototying the Element 
        Element.prototype.selectSingleNode = function(cXPathString){
            if (this.ownerDocument.selectSingleNode) {
                return this.ownerDocument.selectSingleNode(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
    }
})();/**
 * Class: GeoGlobe.Query.WFSQuery
 * WFS地图要素服务查询类。本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）的查询。
 */
GeoGlobe.Query.WFSQuery = GeoGlobe.Class4OL({
	
    /**
     * APIProperty: url
     * {String} WFS服务地址。
     */
	url: null,
	
	/**
     * APIProperty: version
     * {String} WFS服务版本
     */
	version: "1.0.0",

    /**
     * APIProperty: featureNS
     * {String} 要素命名空间
     */
    featureNS: null,
	
	/**
	 * APIProperty: isReverse
	 * {Boolean} 是否对请求结果中的几何信息进行轴序反转，默认值为false,
	 * 当取值为false时，对请求结果不做反转操作。
	 * 当取值为true时，对请求结果做反转操作。
	 */
	isReverse: false,
	
	/**
	 * APIProperty: featurePrefix
	 * {String} 要素类型前缀，默认值""
	 */
	featurePrefix:"",
	
    /**
     * APIProperty: featureType
     * {String | Array(String)} 要素类型。
     */	
	featureType: "",
	
    /**
     * APIProperty: maxFeatures
     * {Number} 最大结果数。
     */	
	maxFeatures: 10,
	
    /**
     * APIProperty: filter
     * {<GeoGlobe.Filter>} 查询条件。
     */
	filter: null,
    
    /**
     * APIProperty: geometryName
     * {String} 要素中geometry属性的名称，默认为"the_geom"。
     */
    geometryName: "the_geom",


    /**
     * APIProperty: protocol
     * {<GeoGlobe.Protocol>} WFS查询协议对象。
     */	
	protocol: null,

    /**
     * APIProperty: format
     * {<GeoGlobe.Format>} 用于对查询操作返回结果进行解析的格式解析器，默认为GML解析器。
     */
	format: null,
    
    /**
     * APIProperty: format
     * {<GeoGlobe.Format>} 格式解析器构造参数。
     */    
    formatOptions: null,
    
    /**
     * APIProperty: isSeparate
     * {Boolean} 设置是否将查询结果按图层名分类。
     */  
    isSeparate: false,
	
    /**
     * APIProperty: srsName
     * {String} 空间参考名。默认值为"EPSG:4326"。
     */
    srsName: "EPSG:4326",
	
    /**
     * APIProperty: time
     * {String} 可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间。时间格式：2015-5-19 12:12:01
     */
	time: null,
	
    /**
     * APIProperty: userecent
     * {String} 可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
     */
	userecent: true,
	
	/**
	 * APIProperty: sortBy
	 * {Array} 设置WFS查询结果的排序参数，该参数为一个数组对象。
     * > sortBy数组内对象所包含的属性:
     * > property - {String} 查询出的要素的某一属性的名称，根据该属性进行排序。
     * > order - {String} 设置正序("ASC")或倒序("DESC")。
     * 
	 * 说明：
	 * 1.wfsg和wfs服务都支持排序；如果wfsg服务中的Post请求串中没有sort节点，那么该服务就不进行排序了（此时用其他字段排序也不起作用了）。当服务在查询中
	 * 有sort节点的时候， 建议用户选择STANDARDNAME和sort字段之一进行排序。如果使用DoMainName作为查询关键字，也可以使用DoMainName进行作为排序字段。
	 * 
	 * 2.wfsg服务和wfs服务默认是以sort字段进行排序，sort字段的值是数字，如果用户以sort字段进行排序，那么sort字段的值（数字）越大，
	 * 在结果列表中越排在后面，相反，sort字段的值越小，则在结果列表中排在越前面，如果sort字段的值相同，则按照其在数据库中读出来的先后顺序排列，
	 * 如果sort字段没值，则排在结果的最后面。
	 * 
	 * 3.若是以STANDARDNAME作为排序字段，如果STANDARDNAME的值是中文，那么排序就是第一个汉字的拼音的首字母的先后顺序作为排序字段（如北京和安徽，
	 * 北京是b为拼音首字母，安徽是a为拼音首字母，那么就是安徽排在北京的前面），若值的第一个汉字拼音首字母相同，则是以第一个汉字拼音的第二个字
	 * 母的先后顺序排列；如果STANDARDNAME的值是英文，也一样，依次类推。
	 * 
	 * Examples:
	 * (code)
	 *		 wfsQueryObj.sortBy = [{
     *              property: "STANDARDNAME",
     *              order: "DESC"
     *          }]
	 * (end)
	 */
	sortBy: null,

	groupBy: null,
	
	resultType: "Results",
	
	startPosition: null,

	/**
	 * Constructor: GeoGlobe.Query.WFSQuery
	 * GeoGlobe.Query.WFSQuery类构造函数。
	 * 
	 * Parameters:
	 * url - {String} WFS服务地址。
	 * featureType - {String} 要素类型。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,featureType,options){
		this.url = url;
		this.featureType = featureType;
		var xy = null;
		if(options) {
			if(options.isReverse === true) {
				this.isReverse = options.isReverse;
				xy = !options.isReverse;
			}else if(options.isReverse === false) {
				this.isReverse = options.isReverse;
				//xy顺序即是不反转
				xy = !options.isReverse;
			}else {
				//默认不反转
				xy = !this.isReverse;
			}
			if(!options.format) {
				this.format = new GeoGlobe.Format.GML({xy:xy});
			}else if(options.format instanceof GeoGlobe.Format.GML.v2 ||options.format instanceof GeoGlobe.Format.GML.v3) {
				options.format.setFeatureType_(featureType);
			}
		}
		GeoGlobe.Util.extend(this, options);
	},

	/**
	 * APIMethod: query
	 * 开始查询。
	 * 
	 * Parameters:
	 * filter - {GeoGlobe.Filter} 过滤器。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new GeoGlobe.LngLatBounds([-90,-180],[90,180]);
	 * 
	 * successFn - {Function} 请求成功的回调函数。
	 * > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 * > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examplse:
	 * (code)
	 *  	//查询范围
	 *		var queryBBOX = new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 *		 //范围过滤
	 *		 var filter = new GeoGlobe.Filter.Spatial({
	 *           type: GeoGlobe.Filter.Spatial.BBOX,
	 *           property: this.geometryName,            
	 *		    value: queryBBOX
	 *       });
	 *		 wfsQueryObj.query(filter,successFn,failFn);
	 * (end)
	 */
	query: function(filter,successFn,failFn){
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
            formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent,//是否追溯
			srsName: this.srsName
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var features = result.features
            
            //根据要求进行按图层名分捡要素
            if(this.isSeparate){
                features = this._separateFeatures(features);
            }
            //对于容错给予提示的节点
            var trueNames = this._read_trueName(result);
			trueNames ? (features.trueNames = trueNames) : features;
			//querySuccessFn(features);
			
			var gjformat = new GeoGlobe.Format.GeoJSON();
			var gjStr = gjformat.write(features);
			var jformat = new GeoGlobe.Format.JSON();
			var gjObj = jformat.read(gjStr);
			querySuccessFn({
				features: features,
				geojson: gjObj
			});
			
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			filter: queryFilter,
			callback: callback
		});
	},
	
	/**
	 * APIMethod: queryPage
	 * 
	 * Parameters:
	 * filter - {GeoGlobe.Filter} 过滤器。
	 * successFn - {Function} 请求成功的回调函数。
	 *    > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 *    > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * options - {Object} 参数选项。
     * 
	 */
	queryPage: function(filter, successFn, failFn, options){
	    var perPageNumber = (options && options.perPageNumber) || 15,
	        pageNumber = (options && options.pageNumber) || 1;
	    
	    var startPosition = (pageNumber - 1) * perPageNumber + 1;
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
			multi:true,
	        formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
	        maxFeatures: perPageNumber,
	        startPosition: startPosition,
	        featurePrefix:this.featurePrefix,
	        url: this.url,
	        featureNS: this.featureNS,
			version: this.version,
			geometryName : this.geometryName,
	        featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent,//是否追溯
			srsName:this.srsName
	    });
		
	    //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
	    var queryFilter = filter || this.filter;
	    var querySuccessFn = successFn || this.successFn;
	    var queryFailFn = failFn || this.failFn;
	    
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}
	
			var features = result.features
	        
	        //根据要求进行按图层名分捡要素
	        if(this.isSeparate){
	            features = this._separateFeatures(features);
	        }
	        //对于容错给予提示的节点
	        var trueNames = this._read_trueName(result);
			features.trueNames = trueNames;
			//querySuccessFn(features);
			
			var gjformat = new GeoGlobe.Format.GeoJSON();
			var gjStr = gjformat.write(features);
			var jformat = new GeoGlobe.Format.JSON();
			var gjObj = jformat.read(gjStr);
			querySuccessFn({
				features: features,
				geojson: gjObj
			});
			
			
		},this);
		this.response = this.protocol.read({
			sortBy:this.sortBy,
	//		maxFeatures: this.maxFeatures,
			filter: queryFilter,
			callback: callback
		});
	},
	
	/**
	 * APIMethod: queryPage
	 * 查询总数据的总条数。
	 * 
	 * Parameters:
	 * filter - {GeoGlobe.Filter} 过滤器。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * 
	 */
	queryTotalNumber: function(filter,successFn,failFn){

        var hitsParser = new GeoGlobe.Format.WFSHits();

		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: hitsParser,
			propertyNames: this.propertyNames,
            resultType: "hits",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent//是否追溯
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var hitsResult = result.features
            
			querySuccessFn(hitsResult);
			
		},this);

		this.response = this.protocol.read({
			filter: queryFilter,
			callback: callback
		});

	},
    
	//读取容错提示节点
	_read_trueName: function(result) {
		var trueNames = [];
		if(result.priv && result.priv.responseText) {
			if(null == this.format){
				return null;
			}
			var trueNameDocs = this.format.getXMLDoc().getElementsByTagName("trueName");
			if (trueNameDocs == null || trueNameDocs.length == 0) {
                return null;
            }
			for(var i = 0; i < trueNameDocs.length; i++) {
				trueNames.push(trueNameDocs[i].text);
			}
			return trueNames;
		}
		return trueNames;
	},
	
	/**
	 * APIMethod: getBufferRegion
	 * 得到缓冲区域。
	 * 
	 * Parameters:
     * point - {<GeoGlobe.Feature>} 点要素。
     * distance - {Integer} 半径。
     * unit - {String} 缓冲单位。
     * 
	 * Returns:
     * {<GeoGlobe.Geometry.Polygon>} 几何多边形。
	 */
	getBufferRegion: function(point,distance,unit) {
		var lonlat = this._getFeaturesCenter(point);
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		return GeoGlobe.Geometry.Polygon.createRegularPolygon(point.geometry,distance,40,360); 
	},
	
    /**
     * Method: _getFeaturesCenter
     * 获取所有要素范围之合的中心点。
     * 
     * Parameters:
     * features - 要执行缓冲分析的要素。
     * 
     * Returns:
     * {<GeoGlobe.LonLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * Method: _getFeaturesExtent
	 * 获取要素数组范围之合。
	 *
	 * Parameters:
	 * features - 要查看的要素数组
	 * 
	 * Returns:
	 * {<GeoGlobe.LngLatBounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(GeoGlobe.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new GeoGlobe.LngLatBounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	/**
	 * Method: _meterToDegree
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * Parameters:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(GeoGlobe.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: pointQuery
	 * 点查询。
	 * 
	 * Parameters:
	 * point - {<GeoGlobe.Geometry.Point>} 点要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的point参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个点要素为例：new GeoGlobe.Geometry.Point(112,20)。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该点要素应写成new GeoGlobe.Geometry.Point(20,112)
	 * distance - {Number} 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examples:
	 * (code)
	 *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
	 *   //点要素
	 *	 var queryPoint = new GeoGlobe.Geometry.Point(110.40056,39.93202);
	 *   wfsQueryObj.pointQuery(queryPoint,distance,unit,successFn,failFn);
	 * (end)
	 */
    pointQuery: function(point,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new GeoGlobe.Filter.Spatial({
            //type: GeoGlobe.Filter.Spatial.INTERSECTS,
            type: GeoGlobe.Filter.Spatial.DWITHIN, //GeoGlobe.Filter.Spatial.DWITHIN
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: point
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: pathQuery
	 * 线查询。
	 * 
	 * Parameters:
	 * path - {<GeoGlobe.Geometry.LineString>} 线要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的path参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个线要素为例：new GeoGlobe.Geometry.LineString([new GeoGlobe.Geometry.Point(118,20),new GeoGlobe.Geometry.Point(118.8,20.8)])。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该线要素应写成
     * 		new GeoGlobe.Geometry.LineString([new GeoGlobe.Geometry.Point(20,118),new GeoGlobe.Geometry.Point(20.8,118.8)])。
	 * distance - {Number}缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
     *   //线要素
	 *	 var queryPath = new GeoGlobe.Geometry.LineString([
     *         new GeoGlobe.Geometry.Point(110,35),
     *         new GeoGlobe.Geometry.Point(110,36)
     *    ]);
     * 	 wfsQueryObj.pathQuery(queryPath, distance, unit, successFn,failFn);
     * (end)
	 */
    pathQuery: function(path,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new GeoGlobe.Filter.Spatial({
            type:GeoGlobe.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: path
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: polygonQuery
	 * 面查询。
	 * 
	 * Parameters:
	 * polygon - {<GeoGlobe.Geometry.Polygon>} 面要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的polygon参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个面要素为例：
     * 		new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(177.76672363281,37.655639648436),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163)
     *       ])
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该面要素应写成
     * 		new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(37.655639648436,177.76672363281),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619)
     *       ])
	 * 
	 * isContain - {Boolean} 是包含还是相交。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     * 	 var isContain = false;
	 *	 var queryPolygon = new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(77.76672363281,37.655639648436),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163)
     *       ])                
     *   ]);
     * 	 wfsQueryObj.polygonQuery(queryPolygon, isContain, successFn,failFn);
     * (end)
	 */
    polygonQuery: function(polygon,isContain,successFn,failFn){
        var filterType = isContain ? GeoGlobe.Filter.Spatial.CONTAINS : 
                                     GeoGlobe.Filter.Spatial.INTERSECTS;
        var filter = new GeoGlobe.Filter.Spatial({
            type: filterType,
            property: this.geometryName, 
            value: polygon
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: bboxQuery
	 * 范围查询。
	 * 
	 * Parameters:
	 * bbox - {<GeoGlobe.LngLatBounds>} 范围。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new GeoGlobe.LngLatBounds([-90,-180],[90,180]);
	 * 
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examples:
	 * (code)
	 *   //查询范围
		 var queryBBOX = new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 	 wfsQueryObj.bboxQuery(queryBBOX, successFn,failFn);
	 * (end)
	 */
    bboxQuery: function(bbox,successFn,failFn){
        var filter = new GeoGlobe.Filter.Spatial({
            type: GeoGlobe.Filter.Spatial.BBOX,
            property: this.geometryName,            
		    value: bbox
        });
        this.query(filter,successFn,failFn);
    },
    
	/**
	 * APIMethod: attributeQuery
	 * 属性查询。
	 * 
	 * Parameters:
	 * type - {String} 比较类型。
	 * property - {String} 属性名。
	 * value - {Number} or {String} 属性值。
	 * options - {Object} 可选参数。
	 *    lowerBoundary - {Number} or {String} 值小的边界。
	 *    upperBoundary - {Number} or {String} 值大的边界。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     *   var type = GeoGlobe.Filter.Comparison.LIKE;
	 *		var property = "label";
	 *		var value = "*";
	 *		wfsQueryObj.attributeQuery(type,property,value,{
	 *			matchCase : true
	 *	 },successFn,failFn);
     * (end)
	 * 
	 */
    attributeQuery: function(type, property, value, options, successFn,failFn){
        
        var matchCase = options && options.matchCase;
        var lowerBoundary = options ? options.lowerBoundary : null;
        var upperBoundary = options ? options.upperBoundary : null;
        
        var filter = new GeoGlobe.Filter.Comparison({
            type: type,
            property: property,            
		    value: value,
            matchCase: matchCase,
            lowerBoundary: lowerBoundary,
            upperBoundary: upperBoundary
        });
        this.query(filter,successFn,failFn);
    },

	statisticsQuery: function(filter,successFn,failFn){
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
			formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
            resultType: "statistics",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent//是否追溯
        });

        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;

		var callback = GeoGlobe.Function.bind(function(result){
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}
			try{
				/*var object = null;
				var x2j = new GeoGlobe.Util.Format.XML2JSON();			
				var text = result.priv.responseText;
				if (null != text && "" != text && undefined != text) {			
					object = x2j.read(result.priv.responseText);
				} else {
					var xmlParser = new GeoGlobe.Format.XML();
					text = xmlParser.write(result.priv.responseXML);
					object = x2j.read(text);
				}*/
				var doc = result.priv.responseXML;
				var StatisticsResult = this._analysis_StatisticsResult(doc);
			}catch(e) {
				querySuccessFn(result.priv.responseText);
				return;
			}
			querySuccessFn(StatisticsResult);
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			groupBy: this.groupBy,
			filter: queryFilter,
			callback: callback
		});
	},

	/**
	 * Method: _analysis_StatisticsResult
	 * 解析返回的结果
	 * 
	 * Parameters:
	 * 	doc
	 */
	_analysis_StatisticsResult: function(doc) {
		var StatisticsResult = {};
		var featureCollection = doc.documentElement;
		//var results = featureCollection.firstElementChild;
        var results = featureCollection.firstChild;
		var layerArray = results.childNodes;
		if(0 < layerArray.length){
			StatisticsResult.layers = this._analysis_StatisticsResult_results(layerArray);
		}
		return StatisticsResult;
	},

	/**
	 * Method: _analysis_StatisticsResult_results
	 * 统计结果第二级结构
	 * 
	 * Parameters:
	 * 	layerArray
	 */
	_analysis_StatisticsResult_results: function(layerArray) {
		var layers = [];
		for(var i = 0; i < layerArray.length; i++) {
			var layer = {};
			var results = [];
			var resultArray = layerArray[i].childNodes;
			for(var j = 0; j < resultArray.length; j++) {
				var result = {};
				result.layerName = resultArray[j].parentNode.nodeName;
                //根据浏览器类型进入不同的方法
                if(navigator.appName=="Microsoft Internet Explorer"){
                    //IE 浏览器
                    result.result = this._analysis_StatisticsResult_results_result_IE(resultArray[j]);
                }else{
                    //谷歌浏览器
                    result.result = this._analysis_StatisticsResult_results_result_google(resultArray[j]);
                }
				results.push(result);
			}
			layer.results = results;
			layers.push(layer);
		}
		return layers;
	},

	/**
	 * Method: _analysis_GeoCodeResult_results_result
	 * 统计结果第三级结构
	 * IE浏览器
	 * Parameters:
	 * 	result
	 */
	_analysis_StatisticsResult_results_result_IE: function(result) {
		var object = {};
		var i = 0;
		var nodeName = result.childNodes[0].nodeName;
		if("Key" == nodeName) {
			object.Key = result.childNodes[0].text;
			i = 1;
		}
		var names = [];
		var values = [];
		for(; i < result.childNodes.length; i++) {
			var name = {};
			var value = {};
			name.name = result.childNodes[i].getAttribute("name");
			value.Value = result.childNodes[i].text;
			names.push(name);
			values.push(value);
		}
        object.name = names;
		object.values = values;
		return object;
	},

    /**
     * Method: _analysis_GeoCodeResult_results_result
     * 统计结果第三级结构
     * 谷歌浏览器
     * Parameters:
     * 	result
     */
    _analysis_StatisticsResult_results_result_google: function(result) {
        var object = {};
        var i = 0;
        var nodeName = result.childNodes[0].nodeName;
        if("Key" == nodeName) {
            object.Key = result.childNodes[0].innerHTML;
            i = 1;
        }
        var names = [];
        var values = [];
        for(; i < result.childNodes.length; i++) {
            var name = {};
            var value = {};
            name.name = result.childNodes[i].getAttribute("name");
            value.Value = result.childNodes[i].innerHTML;
            names.push(name);
            values.push(value);
        }
        object.name = names;
        object.values = values;
        return object;
    },

    /**
     * APIProperty: successFn
     * 查询成功后的回调函数，用户可以自定义此方法。
	 *
	 * Parameters:
	 * features - {Array(<GeoGlobe.Feature>)} 结果要素数组。
     */
	successFn: function(features){
        
    },

    /**
     * APIMethod: failFn
     * WFS查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
     */    
    failFn: function(){
    	alert("对不起,查询失败,请查询服务是否正常。");
    },
    
    //私有,按图层类型分离要素
    _separateFeatures: function(features){
        var result = {};
        for(var i=0; i<features.length; i++){
            var f = features[i];
            var featureType;
            
            //如果是经GML2解析器则判断gml属性中的featureType，如果是GML3则判断type
            if (f.gml) {
                featureType = f.gml.featureType;
            }
            else {
                featureType = f.type;
            }
            
            if(!result[featureType]){
                result[featureType] = [];
            }
            result[featureType].push(f);
        }
        return result;
    },
	
    /**
     * APIProperty: setTime
     * 设置时间。时间格式：2015-5-19 12:12:01
	 *
	 * Parameters:
	 * time - {String} 结果要素数组。
     */
	setTime: function(time){
		this.time = time;
	},
	
    /**
     * APIProperty: setUserecent
     * 设置是否追溯。
	 *
	 * Parameters:
	 * userecent - {Boolean} 结果要素数组。
     */
	setUserecent: function(userecent){
		this.userecent = userecent;
	},
    	
	CLASS_NAME: "GeoGlobe.Query.WFSQuery"
});

GeoGlobe.Query.WFSQuery.reverseGeometryXY = function(geometry) {
	
	var geometryTypes = {
        "GeoGlobe.Geometry.Point": "Point",
        "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
        "GeoGlobe.Geometry.LineString": "LineString",
        "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
        "GeoGlobe.Geometry.Polygon": "Polygon",
        "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
        "GeoGlobe.Geometry.Collection": "GeometryCollection"
    };
	var types = {
		"Point": function(geometry,types) {
			var pointx = geometry.x;
			var pointy = geometry.y;
			var point = geometry.clone(geometry);
			point.x = pointy;
			point.y = pointx;
			return point;
		},
		"LineString": function(geometry,types) {
			var lineString = geometry.clone(geometry);
			for(var i = 0; i < lineString.components.length; i++) {
				var point = types["Point"](lineString.components[i]);
				lineString.components[i] = point;
			}
			return lineString;
		},
		"Polygon": function(geometry,types) {
			var polygon = geometry.clone(geometry);
			for(var i = 0; i < polygon.components.length; i++) {
				for(var j = 0; j <polygon.components[i].components.length - 1; j++) {
					var point = types["Point"](polygon.components[i].components[j]);
					polygon.components[i].components[j] = point;
				}
			}
			return polygon;
		}
	}
	var ageometry = types[geometryTypes[geometry.CLASS_NAME]](geometry,types);
	return ageometry;
};

GeoGlobe.Format.WFSHits = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {

    wfsns: "http://www.opengis.net/wfs",
    
    featureCollection: "FeatureCollection",
    
    read: function(data){
        if (typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var featureCollectionNodes = data.documentElement;
        var numberOfFeatures = parseInt(featureCollectionNodes.getAttribute("numberOfFeatures"));
        return {
            numberOfFeatures: numberOfFeatures
        }
    }
	
});/**
 * Class: GeoGlobe.Query.GeoCodingQuery
 * 地址匹配查询类。默认版本是1.0.0。
 *
 * 例子:
 * (code)
 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
 *			version:"1.1.0"
 *		});
 * (end)
 */
GeoGlobe.Query.GeoCodingQuery = function(url, options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Query.GeoCodingQuery.DEFAULTS
    );
    var cls = GeoGlobe.Query.GeoCodingQuery["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "不支持的地址匹配服务版本: " + options.version;
    }
    return new cls(url, options);
};

GeoGlobe.Query.GeoCodingQuery.DEFAULTS = {
    "version": "1.0.0"
};/**
 * Class4OL: GeoGlobe.Query.GeoCodingQuery.v1
 * 地址匹配服务查询接口的抽象类,抽象类不能实例化。
 */
GeoGlobe.Query.GeoCodingQuery.v1 = GeoGlobe.Class4OL({
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version:"1.0.0",
	
	/**
     * APIProperty: url
     * {String}服务地址。
     */
	url: null,
	
	/**
     * Constructor: GeoGlobe.Query.GeoCodingQuery.v1
     * GeoGlobe.Query.GeoCodingQuery.v1类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
		this.url = url;
        GeoGlobe.Util.extend(this,options);
		this.format = new GeoGlobe.Format.JSON();
	},
	
	/**
	 * Method: getCommonParams
	 * 获取公共的参数
	 * 
	 * Parameters:
	 * 	options
	 */
	getCommonParams: function(options) {
		var params = {
			request: "GetCategory",
			service:"GeoCoding",
			version:this.version,
			output:"json"
		};
        GeoGlobe.Util.extend(params,options);
		return params;
	},
	
	/**
	 * APIMethod: getCategoryByName
	 * 根据类别名称查询类别及子类别。
	 * 
	 * Parameters:
	 * name - {String} 类别名称。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getCategoryByName:function(name,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof name === "string" && name.length !== 0) {
			params.categoryName = name;
		}
		var failFn = failFn || this.failFn;
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},

	/**
	 * APIMethod: getCategoryByCode
	 * 根据类别编码查询类别及子类别。
	 * 
	 * Parameters:
	 * code - {Number}类别编码。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * Example:
	 * (code)
	 *      //根据范围和地址进行查询：
	 * 		var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.getCategoryByCode(1012001008000000,
	 * 		function(GeoCoding){},function(){});
	 * (end)
	 */
	getCategoryByCode: function(code,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof code === "number") {
			params.categoryCode = code;
		}
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: getAllCategory
	 * 查询所有类别信息。
	 * 
	 * Parameters:
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getAllCategory: function(successFn,failFn) {
		var params = this.getCommonParams();
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * Method: _requestCategory
	 * 执行get请求操作
	 * 
	 * Parameters:
	 * 	params
	 *  successFn
	 *  failFn
	 */
	_requestCategory:function(params,successFn,failFn) {
		var failFn = failFn || this.failFn;
        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var category = this.format.read(result.responseText);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(category);
		},failFn);
	},
	
	/**
	 * Method: _analysis_GeoCodeResult
	 * 解析返回的结果，getCoder接口查询结果第一级结构
	 * 
	 * Parameters:
	 * 	json
	 */
	_analysis_GeoCodeResult: function(json) {
		var queryResult = {
			status:json.status
		};
		switch(json.status) {
			case "OK":
				var results = json.results;
				if(results) {
					queryResult.results = this._analysis_GeoCodeResult_results(results);
				}
			break;
			case "INVALID_REQUEST":
				
			break;
			case "NO_RESULTS":
				
			break;
			case "UNKNOWN_ERROR":
				
			break;
			default:
				queryResult = {
					requestKeyWord:json.requestKeyWord,
					count:json.count,
					statisticsLevel:json.statisticsLevel,
					statisticsLevelName:json.statisticsLevelName
				};

				if(json && json.count > 0){
					var results = json.results;
					if(results) {
						queryResult.results = this._analysis_GeoCodeResult_statistics(results);
					}
				}
			break;
		}
		return queryResult;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results
	 * getCoder接口查询结果第二级结构
	 * 
	 * Parameters:
	 * 	results
	 */
	_analysis_GeoCodeResult_results: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(GeoGlobe.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				result.requestKeyWord = results[i].requestKeyWord;
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}
				//匹配结果总数
				result.count = results[i].count;
				if(results[i].result) {
					result.result = this._analysis_GeoCodeResult_results_result(results[i].result);
				}
				aresults.push(result);
			}
			return aresults;
		}
	},

	/**
	 * Method: _analysis_GeoCodeResult_statistics
	 * getCoder接口按行政区划统计结果值第二级结构
	 * 
	 * Parameters:
	 * 	results
	 */
	_analysis_GeoCodeResult_statistics: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(GeoGlobe.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}

				if(results[i]) {
					result.name = results[i].name;
					result.value = results[i].value;
					result.remark = results[i].remark;
				}
				aresults.push(result);
			}
			return aresults;
		}
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results_result
	 * getCoder接口查询结果第三级结构
	 * 
	 * Parameters:
	 * 	result
	 */
	_analysis_GeoCodeResult_results_result: function(result) {
		var addresss = [];
		for(var i = 0,j = result.length; i < j;i++) {
			var address = {};
            var street_path = {};
			//匹配结果的类型
			address.resultType = result[i].resultType;
			//匹配地址是否为精确地址
			address.precise = result[i].precise;
			//该条匹配结果是否为摘要信息
			address.isBrief = result[i].isBrief;
			//匹配结果与请求关键字的匹配度，值域为1到100，值越大匹配度就越高
			address.score = result[i].score;
            if(result[i].addressComponent.street){
                street_path = result[i].addressComponent.street;
            }
			if(address.isBrief == false) {
				address.addressComponent = this._analysis_GeoCodeResult_results_result_address(result[i].addressComponent,address.resultType);
			}
			address.poiArray = this._analysispoiArray(result[i].poiArray);
			if(result[i].location) {
				address.location = result[i].location;
			}
			//TODO:referenceAddressArray
			if(address.precise == 0) {
				address.referenceAddressArray = result[i].referenceAddressArray;
			}
            if(street_path){
                address.street_path = street_path;
            }
			addresss.push(address);
		}
		return addresss;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results_result_address
	 * getCoder接口查询结果第四级结构，当前匹配结果的地址详细信息
	 * 
	 * Parameters:
	 * 	addressComponent
	 *	resultType
	 */
	_analysis_GeoCodeResult_results_result_address:function(addressComponent,resultType) {
		var addressC = {
			country: addressComponent.country
		};
		//行政区划的第二级-省、直辖市、自治区
		if(addressComponent.province) {
			addressC.province = addressComponent.province;
		}
		//行政区划第三级-市
		if(addressComponent.city) {
			addressC.city = addressComponent.city;
		}
		//行政区划第四级-区或县
		if(addressComponent.district) {
			addressC.district = addressComponent.district;
		}
		//行政区划第五级-乡镇
		if(addressComponent.town) {
			addressC.town = addressComponent.town;
		}
		if(addressComponent.street) {
			addressC.street = {
				name:addressComponent.street.name
			};
			
			if(resultType === "street") {
				//需要增加对线的json串的解析
				if(addressComponent.street.geometry) {
					//var sgeometry = addressComponent.street.geometry;
					var sgeometry = this.format.read(addressComponent.street.geometry);
					var streetGeometry = null;
					if(sgeometry["paths"]) {
						//这个需要做测试，这里的几何信息一般来说是线，不过也有可能不是线
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["rings"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["x"] && sgeometry["y"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}
				}
			}
		}
		if(addressComponent.streetNumber) {
			addressC.streetNumber = addressComponent.streetNumber;
		}
		if(addressComponent.buildingNumber) {
			addressC.buildingNumber = addressComponent.buildingNumber;
		}
		if(resultType === "adminArea") {
			//当前匹配最小级行政区划的空间信息,本属性需要被转换成Geo.Geometry类型
			if(addressComponent.geometry) {
				//var geometry = addressComponent.geometry;
				var geometry = this.format.read(addressComponent.geometry);
				var areaGeometry = null;
				//如果它是面，我们解析它
				if(geometry["rings"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(geometry["paths"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(typeof geometry["x"] === "number" && typeof geometry["y"] === "number") {
					addressC.geometry = this._getGeometry(geometry);
				}
			}
			//当前匹配最小级行政区划下属的其它行政区划名称，多个以逗号隔开
			if(addressComponent.subordinate) {
				addressC.subordinate = addressComponent.subordinate;
			}
			//行政区的邮政编码
			if(addressComponent.zipCode) {
				addressC.zipCode = addressComponent.zipCode;
			}
			//电话长途区划
			if(addressComponent.callingCode) {
				addressC.callingCode = addressComponent.callingCode;
			}
		}
		return addressC;
	},
	
	/**
	 * Method: _analysispoiArray
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	poiArray
	 */
	_analysispoiArray: function(poiArray) {
		var pointFeatures = [];
		for(var i = 0,j = poiArray.length; i < j;i++) {
			var point = {};
			for(var pro in poiArray[i]) {
				point[pro] = poiArray[i][pro];
			}
			if("" != point.geometry && undefined != point.geometry){
				var geometry = this.format.read(point.geometry);
				point.geometry = this._getGeometry(geometry);
			}
			pointFeatures.push(point);
		}
		return pointFeatures;
	},
	
	/**
	 * Method: _analysisLocation
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	location
	 */
	_analysisLocation:function(location) {
		
	},
	
	/**
	 * Method: _getGeometry
	 * 得到GeoGlobe几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new GeoGlobe.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new GeoGlobe.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//需要增加多点类型
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: _geometryType
	 * 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new GeoGlobe.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new GeoGlobe.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new GeoGlobe.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new GeoGlobe.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new GeoGlobe.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new GeoGlobe.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new GeoGlobe.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(error) {
		if(typeof error == "string") {
			alert(error);
		}
		alert("对不起，查询请求失败！请检查地址匹配服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},

	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1"
});/**
 * Class: GeoGlobe.Query.GeoCodingQuery.v1_0_0
 * 地址匹配服务查询接口1.0.0版本，本类可以实现如下功能：
 * 
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 *	Inherits from:
 *  	- <GeoGlobe.Query.GeoCodingQuery.v1>
 */
GeoGlobe.Query.GeoCodingQuery.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
	
	/**
     * Constructor: GeoGlobe.Query.GeoCodingQuery.v1_0_0
     * GeoGlobe.Query.GeoCodingQuery.v1_0_0类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {String || Array(String)} (必选) 查询的地址名称集合。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<GeoGlobe.LngLatBounds> | <GeoGlobe.Geometry.Polygon>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * fuzzyMatch - {Boolean} (可选) 是否模糊匹配，true表示精确匹配，false表示模糊匹配。默认值为false。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) ： 从第几条开始查询，缺省值是1。
	 * 无customWeight参数 ，1.0.0版本当前只按匹配度排序。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(typeof options.address === "string") {
			params.address = options.address;
		}else if(GeoGlobe.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.address = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if(options.extent instanceof mapboxgl.LngLatBounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof GeoGlobe.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}else{
            params.bbox = options.extent;
        }
		if(typeof options.fuzzyMatch === "boolean") {
			params.fuzzyMatch = options.fuzzyMatch;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}

        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				//var GeoCodingResult = this._analysis_GeoCodeResult(json);
                if(params.resultType == "result"){
                    var GeoCodingResult = this._parseQueryResultToFeature(json);
                }else{
                    var GeoCodingResult = this._analysis_GeoCodeResult(json);
                }
                //var res = this._parseQueryResultToFeature_v_0(GeoCodingResult);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},

	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlat - {GeoGlobe.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(options.lonlat) {
			params.latlng = options.lonlat.lat+","+options.lonlat.lng;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				//var GeoCodingResult = this._analysis_GeoCodeResult(json);
                if(params.resultType == "result"){
                    var GeoCodingResult = this._parseQueryResultToFeature(json);
                }else{
                    var GeoCodingResult = this._analysis_GeoCodeResult(json);
                }
                //var res = this._parseQueryResultToFeature_v_0(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult,json);
		},this.failFn);
	},
	/**
	 * APIMethod: getLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<GeoGlobe.LngLatBounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {GeoGlobe.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * APIMethod: getLocationsByPage
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Featur } – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<GeoGlobe.LngLatBounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {GeoGlobe.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature } – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {GeoGlobe.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddressesByPage
	 * 根据位置查找匹配的地址信息-分页查询。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {GeoGlobe.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * Method: _parseQueryResultToFeature
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象
	 * 
	 * Parameters:
	 * params {Object} 键值对
	 *
	 * Returns:
	 * {Object} 包含状态和feature数组的对象
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(GeoGlobe.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
									attribute.category = result[j].poiArray[k].category;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
                                    attribute.streetgeometry = result[j].addressComponent.street.geometry;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new GeoGlobe.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new GeoGlobe.Feature(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}
        var gjformat = new GeoGlobe.Format.GeoJSON();
        var geojsonStr = gjformat.write(features);
        var jsonformat = new GeoGlobe.Format.JSON;
        var geojsonFeature = jsonformat.read(geojsonStr);
		return {
			status: queryResult.status,
			features: features,
            geojsonFeatures:geojsonFeature
		};
	},
	
	/**
     * Method: _getAddress
     * 拼装详细地址。
     *
     * Parameters: 
	 * addressComponent - {Object} 地址对象。
     * name - {String} 名称。
     *
     * Returns:
     * {String} 详细地址。
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_0_0"
});/**
 * Class: GeoGlobe.Query.GeoCodingQuery.v1_1_0
 * 地址匹配服务查询接口1.1.0版本，本类可以实现如下功能：
 * 
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123 和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 4.可以根据多个地址信息查询到地理坐标信息。
 * > 5.可以根据多个地理坐标值获取地址信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 *	Inherits from:
 *  	- <GeoGlobe.Query.GeoCodingQuery.v1>
 */
GeoGlobe.Query.GeoCodingQuery.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
	
	/**
	 * APIProperty: method
	 * 数据请求方式，默认值是"get"。
	 */
	method: "get",
	
	/**
     * Constructor: GeoGlobe.Query.GeoCodingQuery.v1_1_0
     * GeoGlobe.Query.GeoCodingQuery.v1_1_0类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
        GeoGlobe.Util.extend(this,options);
		this.filterFormat = new GeoGlobe.Format.Filter();
        GeoGlobe.Query.GeoCodingQuery.v1.prototype.initialize.apply(this, arguments);
	},
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<GeoGlobe.Bounds> | <GeoGlobe.Geometry.Polygon>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：(1)hits：返回匹配结果的总数；(2)result：返回匹配结果；(3)statistics：统计结果值。缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {GeoGlobe.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * statisticsLevel - {Integer} (可选) 统计级别。可供选择的值：1(省级)；2(市(县)级)；3(区级)。默认值为2。
	 * customWeight - {Boolean} (可选) 是否启动自定义权重排序，缺省为true。如设置为false，则按匹配度排序。
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = false;
		if(typeof options.address === "string") {
			params.keyword = options.address;
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if((options.address == undefined || options.address == null) && 
				(options.categoryCode == undefined || options.categoryCode == null)) {
			throw "address是必选参数！";
		}
		if(options.extent instanceof mapboxgl.LngLatBounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof GeoGlobe.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}else{
            params.bbox = options.extent;
        }
		if(options.filter instanceof GeoGlobe.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = GeoGlobe.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.semanticAnalysis  === "boolean") {
			params.semanticAnalysis = options.semanticAnalysis;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		
	},
	
	/**
	 * Method: _getCodingRequest
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	successFn {Function} 成功回调
	 * 	failFn {Function} 失败回调
	 */
	_getCodingRequest: function(params,successFn,failFn) {
		if(this.method == "get") {
			GeoGlobe.loadURL(this.url,params,this,function(result) {
				try{
					var json = this.format.read(result.responseText);
                    //_parseQueryResultToFeature
                    if(params.resultType == "result"){
                        var GeoCodingResult = this._parseQueryResultToFeature(json);
                    }else{
                        var GeoCodingResult = this._analysis_GeoCodeResult(json);
                    }

				}catch(e) {
					successFn(result.responseText);
					return;
				}
				successFn(GeoCodingResult);
			},this.failFn);
		}else {
			var paramsStr = GeoGlobe.Util.getParameterString(params);
            GeoGlobe.Request.POST({
	            url: this.url,
	            data: paramsStr,
	            success: function(result) {
					try{
						var json = this.format.read(result.responseText);
						var GeoCodingResult = this._analysis_GeoCodeResult(json);
					}catch(e) {
						successFn(result.responseText);
						return;
					}
					successFn(GeoCodingResult);
				},
	            failure: this.failFn,
	            scope: this
	        });
		}
	},
	
	/**
	 * Method: _setGeoCoderCommonProperty
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	options
	 */
	_setGeoCoderCommonProperty: function(params,options) {
		if(typeof options.sortFields  === "string") {
			params.sortFields = options.sortFields;
		}
		if(typeof options.scoreFilter  === "string") {
			params.scoreFilter = options.scoreFilter;
		}
	},
	
	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {<GeoGlobe.LonLat>} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * 
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = true;
		if(options.lonlat) {
			params.keyword = options.lonlat.lat+","+options.lonlat.lng;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: batchAddressesToLocations
	 * 根据一到多个地址查询坐标位置信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {Array(String)} (必选) 查询的地址名称集合。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * filter - {<GeoGlobe.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchAddressesToLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	batchAddressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = false;
		if(GeoGlobe.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.keywords = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		if(options.filter instanceof GeoGlobe.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = GeoGlobe.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
         GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
	 * APIMethod: batchLocationToAddresses
	 * 根据多个坐标位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlats - {Array(<GeoGlobe.LonLat>)} (必选) 坐标位置数组。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchLocationToAddresses({
	 *			lonlats:[new GeoGlobe.LonLat(123.43888042, 41.759929371),new GeoGlobe.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *
	 *		},function() {});
	 * (end)
	 */
	batchLocationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = true;
		if(options.lonlats instanceof GeoGlobe.LonLat) {
			options.lonlats = [options.lonlats];
		//	params.keywords = options.lonlat.lat+","+options.lonlat.lng;
		}else  if(!GeoGlobe.Util.isArray(options.lonlats)) {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(GeoGlobe.Util.isArray(options.lonlats)) {
			var lonlatsStr = "";
			for(var i = 0; i < options.lonlats.length;i++) {
				lonlatsStr += options.lonlats[i].lat+","+options.lonlats[i].lng+";";
			}
			lonlatsStr = lonlatsStr.substr(0, lonlatsStr.length - 1);
			params.keywords = lonlatsStr;
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
         GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
     * Method: _getAddress
     * 拼装详细地址。
     *
     * Parameters: 
	 * addressComponent - {Object} 地址对象。
     * name - {String} 名称。
     *
     * Returns:
     * {String} 详细地址。
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	
	/**
	 * APIMethod: getLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<GeoGlobe.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {<GeoGlobe.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * APIMethod: getLocationsByPage
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<GeoGlobe.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {<GeoGlobe.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddresses
	 * 根据位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {<GeoGlobe.LonLat>} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddressesByPage
	 * 根据位置查找匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {<GeoGlobe.LonLat>} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * APIMethod: batchGetAddresses
	 * 根据多个坐标位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlats - {Array(<GeoGlobe.LonLat>)} (必选) 坐标位置数组。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetAddresses({
	 *			lonlats:[new GeoGlobe.LonLat(123.43888042, 41.759929371),new GeoGlobe.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetAddresses: function(options, successFn, failFn){
		this.batchLocationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * APIMethod: batchGetLocations
	 * 根据一到多个地址查询坐标位置信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {Array(String)} (必选) 查询的地址名称集合。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * filter - {<GeoGlobe.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetLocations: function(options, successFn, failFn){
		this.batchAddressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * Method: _parseQueryResultToFeature
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象。
	 * 
	 * Parameters:
	 * params {Object} 键值对
	 *
	 * Returns:
	 * {Object} 包含状态和feature数组的对象
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(GeoGlobe.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
									attribute.category = result[j].poiArray[k].category;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
                                    attribute.streetgeometry = result[j].addressComponent.street.geometry;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new GeoGlobe.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new GeoGlobe.Feature(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}

        var gjformat = new GeoGlobe.Format.GeoJSON();
        var geojsonStr = gjformat.write(features);
        var jsonformat = new GeoGlobe.Format.JSON;
        var geojsonFeature = jsonformat.read(geojsonStr);
		return {
			status: queryResult.status,
			features: features,
            geojsonFeatures:geojsonFeature
		};
	},
	
	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_1_0"
});/**
 * Class: GeoGlobe.HeatMap
 * 热图控件类，为二维地图提供热图功能。
 *
 * Inherits from:
 *  - <GeoGlobe.HeatMap>
 */
GeoGlobe.HeatMap = GeoGlobe.Class4OL({

    /**
     * Property: map
     * {String} 添加的地图容器。
     */
    map: null,
	
	/**
     * Property: size
     * {Number} 热力点的缓冲范围。
     */
	size: 25,


	/**
     * Property: intensity
     * {Number} 添加的热力的强度， 0-1。
     */
	intensity: 0.5,

    /**
     * Constructor: GeoGlobe.HeatMap
     * GeoGlobe.HeatMap构造函数。
     *
     * Parameters:
     * map - {Object} HeatMap相关选项设置。
	 * data -{object} HeatMap数据（可选）
     */
    initialize: function(map, data){
        this.heatmap = new mapboxgl.heatmap(map);
        var heatMap = this.heatmap;
        this.map = map;
        var map = this.map;
		if(data){
			this.datas = data;
			this.setData(data);
		}else{
			 this.datas = [];
		}
     	this._updataLayer = GeoGlobe.Function.bind(this.updateLayer, this);
        map.on('zoom', this._updataLayer);
        map.on('move', this._updataLayer);
    },

    /**
     * Method: addPoint
     * 添加热图点
     *
     * options:
     * lnglat - {number} 地图的坐标点
     * size - {number} 热力点的缓冲范围.
     * intensity - {0-1} 添加的热力的强度
     */
    addPoint:function(lnglat,size,intensity){
        var poi = this.map.project([lnglat[0],lnglat[1]]);
        this.heatmap.heatmap.addPoint(poi.x, poi.y, size, intensity);
    },

    /**
     * Method: update
     * 绘制数据点
     *
     */
    update:function(){
        this.heatmap.heatmap.update();
    },

    /**
     * Method: updateLayer
     * 更新热图数据
     *
     */
    updateLayer: function(){
        this.setData(this.datas);
    },

    /**
     * APIMethod: setData
     * 设置热图数据
     *
     */
    setData: function (data){
        this.clear();
        this.datas = data;
        if(this.datas){
            for(var i =0;i<this.datas.length;i++){
                this.addPoint(this.datas[i], this.size, this.intensity);
            }
        }
    },

    /**
     * Method: display
     * 显示热图
     *
     */
    display:function(){
        return this.heatmap.heatmap.display();
    },

    /**
     * Method: multiply
     * 增加热图的数值
     *
     * options:
     * value - {number} 热图的增加值.
     */
    multiply:function(value){
        this.heatmap.heatmap.multiply(value);
    },

    /**
     * Method: clamp
     * 图各个值之间锁定的值
     *
     * options:
     * clamp1 - {number} 最小值.
     * clamp2 - {number} 最大值.
     */
    clamp:function(clamp1,clamp2){
        this.heatmap.heatmap.clamp(clamp1,clamp1);
    },

    /**
     * Method: blur
     * 热图模糊程度
     *
     */
    blur:function(){
        this.heatmap.heatmap.blur();
    },

    /**
     * APIMethod: clear
     * 清除
     *
     */
    clear:function(){
        this.heatmap.heatmap.clear();
		this.datas = [];
    },

    /**
     * APIMethod: remove
     * 移除并销毁。
     *
     */
    remove: function(){
        this.clear();
		map.off('zoom', this._updataLayer);
        map.off('move', this._updataLayer);
		
		this.heatmap.heatmap_canvas.parentNode.removeChild(this.heatmap.heatmap_canvas);
		//this.heatmap.heatmap_canvas.remove();
		this.heatmap.heatmap_canvas = null;
		this.heatmap = null;
		this.map = null;
    },
	
	

    CLASS_NAME: "GeoGlobe.HeatMap"
});﻿/**
 * Class: GeoGlobe.LayerGroup
 * 基础图层组类，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层 将做为地图中的底图置于所有图层的最下方。
 *
 * Inherits from:
 *  - <GeoGlobe.LayerGroup>
 */
GeoGlobe.LayerGroup = GeoGlobe.Class4OL({

    /**
     * Property: map
     * {GeoGlobe.map} 地图容器。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.LayerGroup
     * GeoGlobe.Control构造函数。
     *
     * Parameters:
     * options - {Object} LayerGroup相关选项设置。
     */
    initialize: function(options){
    },


    /**
     * Method: addGroup
     * 在地图上添加一个图层组。
     *
     * Parameters:
     * map - {GeoGlobe.Map} 地图对象。
     * id - {string} id The id of the new group
     * layers -{Array<Object>} layers The Mapbox style spec layers of the new group
     * beforeId -string} [beforeId] The layer id or group id after which the group
     *     will be inserted. If ommitted the group is added to the bottom of the
     *     style.
     */
    addGroup:function(map, id, layers, beforeId){
        mapboxgl.LayerGroup.addGroup(map, id, layers, beforeId);
    },

    /**
     * Method: addLayerToGroup
     * 在图层组上添加单个图层.
     *
     * Parameters:
     * map - {Map} map
     * groupId - {string} groupId The id of group
     * layer - {Object} layer The Mapbox style spec layer
     * beforeId {string} [beforeId] An existing layer id after which the new layer
     *     will be inserted. If ommitted the layer is added to the bottom of
     *     the group.
     */
    addLayerToGroup: function(map, groupId, layer, beforeId) {
        mapboxgl.LayerGroup.addLayerToGroup(map, groupId, layer, beforeId);
    },

    /**
     * Method: removeGroup
     * 移除图层组中单个图层.
     *
     * Parameters:
     * map {Map} map
     * ids {string} The  layer's id of the group to be removed.
     * groupId - {string} groupId The id of group
     */
    removeLayerFromGroup: function(map, id,groupId) {
        var layers = map.getStyle().layers;
        for (var i = 0; i < layers.length; i++) {
            if (layers[i].metadata && layers[i].metadata.group === groupId) {
                if(layers[i].id == id ){
                map.removeLayer(layers[i].id);
               
		}
            }
        }
    },

    /**
     * Method: removeGroup
     * 移除全部图层组.
     *
     * Parameters:
     * map {Map} map
     * id {string} id The id of the group to be removed.
     */
   removeGroup: function(map, id) {
        mapboxgl.LayerGroup.removeGroup(map, id);
    },
    /**
     * Method: moveGroup
     * 移动整个图层组.
     *
     * Parameters:
     * map {Map} map
     * id {string} id The id of the group to be removed.
     * groupId - {string} groupId The id of group
     */
   moveGroup: function(map, id, beforeId) {
        mapboxgl.LayerGroup.moveGroup(map, id, beforeId);
    },

    /**
     * Method: getGroupFirstLayerId
     * 获取图层组里第一个图层id.
     *
     * Parameters:
     * map {Map} map
     * id {string} id The id of the group.
     * returns {string}
     */
    getGroupFirstLayerId: function(map, id) {
        return mapboxgl.LayerGroup.getGroupFirstLayerId(map, id);
    },

    /**
     * Method: getGroupLastLayerId
     * 获取图层组里最后一个图层id.
     *
     * Parameters:
     * map {Map} map
     * id {string} id The id of the group.
     * returns {string}
     */
    getGroupLastLayerId: function(map, id) {
        return mapboxgl.LayerGroup.getGroupLastLayerId(map, id);
    },
    CLASS_NAME: "GeoGlobe.LayerGroup"
});

/**
 * Class: GeoGlobe.Service
 * 服务类。本类是服务类的基类，需要由子类去实现。
 */
GeoGlobe.Service = GeoGlobe.Class({
	
	/**
     * APIProperty: name
     * {String} 服务名称。
     */
	name: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: version
     * {String} 服务版本号。
     */		
	version: null,

	
	/**
     * APIProperty: userid
     * {String} 用户名。
     */			
	userid: "test@liferay.com",
	
	/**
     * Constructor: GeoGlobe.Service.Bus
     * GeoGlobe.Service.Bus类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
        GeoGlobe.Util.extend(this, options);
	},


	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息，由子类实现。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * APIMethod: isExist
     * 检查服务是否存在，由子类实现。
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * APIMethod: failFn
     * 服务操作失败响应回调函数。
     * 
     * operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new GeoGlobe.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "GeoGlobe.Service"
	
});/**
 * Class: GeoGlobe.Service.WFST
 * OGC-WFST服务类。Web要素服务-T（Web Feature Service-Transaction简称WFST）遵循OGC的WFS1.0.0规范，
 * 本服务提供对要素的增加、修改、删除等事务操作。
 *
 * Inherits from:
 * - <GeoGlobe.Service>
 */
GeoGlobe.Service.WFST = GeoGlobe.Class4OL(GeoGlobe.Service, {
	
    /**
     * APIProperty: xy
     * {Boolean} 值为true时，为(x,y)顺序。值为false时，为(y,x)顺序。
     */ 
    xy: true,

    /**
     * Constructor: GeoGlobe.Service.WFST
     * GeoGlobe.Service.WFST类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: describeFeatureType
     * 获取要素类型描述操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例：
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */
    describeFeatureType: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "DescribeFeatureType"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: getFeature
     * 获取要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	TypeName - {String} 必选 类型名称。
     * 	version - {String} 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  MaxFeatures - {Integer} 可选 查询的返回的结果总数。
     *  filter - {GeoGlobe.Filter} 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */
    getFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "GetFeature"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: lockFeature
     * 锁定要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	typeName - {String} 必选 指定操作的图层类型名称。
     * 	version - {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  expiry - {Number} 可选 锁定的分钟数，如果没有则默认为1分钟。
     *  lockAction - {String} 可选 指定如何获得锁，如果没有则默认为"ALL"。
     *  filter - {GeoGlobe.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    lockFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "LockFeature",
            expiry: 1,
            lockAction: "ALL"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
		//解析filter对象，转换为XML字符串。
		var filterXMLString = this._parserFilterToString(params.filter);
        
        var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<LockFeature version="${version}" service="${service}" lockAction="${lockAction}" expiry="${expiry}" ' +
	        'xmlns:wfs=" http://www.opengis.net/wfs" ' +
	        'xmlns:gml=" http://www.opengis.net/gml" ' +
	        'xmlns:myns=" http://www.someserver.com/myns" ' +
	        'xmlns:ogc=" http://www.opengis.net/ogc" ' +
	        'xmlns:xsi=" http://www.w3.org/2001/XMLSchema-instance" ' +
	        'xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">' +
	        '<Lock typeName="${typeName}">' +
		        '${filterXMLString}' +
	        '</Lock>' +
        '</LockFeature>';
        
        var requestString = GeoGlobe.String.format(requestStringTemplate, {
            version: params.version,
            service: params.service,
            lockAction: params.lockAction,
            expiry: params.expiry,
            typeName: params.typeName,
            filterXMLString: filterXMLString
        });
        
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
        
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
        //        GeoGlobe.loadURL(url, params, this, function(result){
        //            successFn(result);
        //        }, failFn);
    },
    
    /**
     * APIMethod: transaction
     * 要素的事务操作，可以对服务中的要素内容进行增加、删除和修改操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	version {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * 	releaseAction {String} 可选 指定如何释放锁，提供有"ALL"和"SOME"两种方式，默认值是"ALL"。
     *             在做更新或删除要素的时候，releaseAction="ALL"或"SOME"决定LockId对应的所有要素是否全部释放。
     *             如果是"ALL",表示LockId对应的所有要素全部解锁释放。
     *             如果是"SOME",表示LockId只对正在操作的要素解锁释放，其他要素还是保持锁定状态。
     *  lockId {String} 可选 锁定编号。
     * inserts - {Object} 添加要素的请求参数。
     *  features {Array(<GeoGlobe.Feature>)} 必选 一系列要素的集合。
     *  typeName {String} 必选 指定操作的图层类型名称。
     * updates - {Object} 修改要素的请求参数。
     *  features {Array(<GeoGlobe.Feature>)} 必选 一系列要素的集合。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {GeoGlobe.Filter} 可选 操作要素的条件过滤器。
     * deletes - {Object} 删除要素的请求参数。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {GeoGlobe.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    transaction: function(params, inserts, updates, deletes, successFn, failFn){
		var url = this.url;
		//默认参数
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "Transaction",
            releaseAction: "ALL"
        };
		//合并默认参数，获得实际请求参数
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
		
		//定义post请求模板
		var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<wfs:Transaction releaseAction="${releaseAction}" handle="Transaction 01" version="${version}" service="${service}" '+
		'xmlns="http://www.someserver.com/myns" ' +
		'xmlns:gml="http://www.opengis.net/gml" ' +
		'xmlns:ogc="http://www.opengis.net/ogc" ' +
		'xmlns:wfs="http://www.opengis.net/wfs" ' +
		'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
	        '${lockIdString}' +
	        '${transactionString}' +
        '</wfs:Transaction>';
		
		//lockId的请求标签
        var lockId = params.lockId;
		var lockIdString = "";
		if(lockId){
			lockIdString += '<LockId>' + lockId + '</LockId>';
		}
		
		var transactionString = "";
		//添加
        if (inserts) {
            transactionString += this._getInsertString(inserts);
        }
		//修改
		if(updates){
			transactionString += this._getUpdateString(updates);
		}
		//删除
		if(deletes){
			transactionString += this._getDeleteString(deletes);
		}
		//根据模板，获得post请求串
        var requestString = GeoGlobe.String.format(requestStringTemplate, {
            releaseAction: params.releaseAction,
            version: params.version,
            service: params.service,
            lockIdString: lockIdString,
            transactionString: transactionString
        });
		
		//请求失败的回调函数
		if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
		
		//发送post请求
		var xhr = new GeoGlobe.Request.POST({
            url: url,
            data: requestString,
            scope: this,
            success: successFn,
//          success: function(result){
//				if(typeof successFn == "function"){
//	            	successFn(this._parseTransactionResult(result));
//	            }
//			},
            failure: failFn
        });
	},
	
	/**
     * APIMethod: parseTransactionResult
     * 解析服务返回的要素事务操作的响应结果。 
     * 
     * Parameters:
     * result - {object} 服务返回的要素事务操作的响应结果。
     *
     * Returns:
     * {object} 返回要素事务操作的JSON返回结果。
	 */
    parseTransactionResult: function(result){
	    var format = new GeoGlobe.Format.XML2JSON();
	    var obj = format.read(result.responseText);
	    var res = new Array();
	    var wfs_Status = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_TransactionResult.wfs_Status);
	    var wfs_InsertResults = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_InsertResults);
	    //不存在则返回空数组。
	    if(!wfs_Status){
	    	return res;
	    }
	    for (var i = 0; i < wfs_Status.length; i++) {
	        if (wfs_Status[i].wfs_SUCCESS !== undefined) {
	            res.push({
	                status: "SUCCESS",
	                fid: (wfs_InsertResults && wfs_InsertResults[i]) ? wfs_InsertResults[i].ogc_FeatureId.fid : null
	            });
	        }
	        else {
	            res.push({
	                status: "FAILED",
	                fid: null
	            });
	        }
	    }
	    return res;
	},
	
	/**
     * Method: _objToArray
     * 对象转数组。 
     * 
     * Parameters:
     * obj - {object} 对象。
     *
     * Returns:
     * {Array} 返回数组。
	 */
    _objToArray: function(obj){
		if (obj && !(obj instanceof Array)) {
	        obj = [obj];
	    }
	    return obj;
	},
	
	/**
     * Method: _getInsertString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * insert - {object} 添加要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
    _getInsertString: function(inserts){
		var features = inserts.features;
		var typeName = inserts.typeName;
		var insertStr = "";
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            insertStr += '<wfs:Insert handle="Insert ' + i + '">' +
			this._getInsertFeatureString(feature, typeName) +
			'</wfs:Insert>';
        };
		return insertStr;
	},
	
	/**
     * Method: _getInsertFeatureString
     * 获取保存要素所需的外部属性串。 
     * 
     * Parameters:
     * feature - {<GeoGlobe.Feature>} 要素。
     * typeName - {String} 指定操作的图层类型名称。
     *
     * Returns:
     * {String} 返回保存要素所需的外部属性串。
	 */
    _getInsertFeatureString: function(feature, typeName){
        var str = "";
        
        var featureTemplate = '<${typeName}>${content}</${typeName}>';
        var geoTemplate = "<GEOMETRY>${geometry}</GEOMETRY>";
        
        var attrTemplate = "<${tag}><![CDATA[${value}]]></${tag}>"
        
        for (var item in feature.attributes) {
            if (item == "OID") {
                continue;
            }
            str += GeoGlobe.String.format(attrTemplate, {
                value: (feature.attributes[item] ? feature.attributes[item] : ""),
                tag: item
            });
        }
        str += GeoGlobe.String.format(geoTemplate, {
            geometry: this._getGeometryStringByFeature(feature)
        });
        
        str = GeoGlobe.String.format(featureTemplate, {
            typeName: typeName,
            content: str
        });
        return str;
    },
	
	/**
     * Method: _getUpdateString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * updates - {object} 修改要素的参数对象。
     *
     * Returns:
     * {String} 返回XML字符串。
	 */
	 /*
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var feature = updates.feature;
        
        //要素的要修改的属性和值的XML字符串
        var propertyString = this._getUpdatePropertyString(feature);
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        var updateStr = '<wfs:Update typeName="' + typeName + '" handle="Update 1">' +
	        propertyString +
	        filterXMLString +
        '</wfs:Update>';
        
        return updateStr;
    },
    */
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var features = updates.features;
        var updateStr = '';
        for (var i = 0; i < features.length; i++) {
        	if(features[i].geometry){
		        //要素的要修改的属性和值的XML字符串
		        var propertyString = this._getUpdatePropertyString(features[i]);
		        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [typeName + "." + features[i].attributes.OID]});
		        //解析filter对象，转换为XML字符串。
		        var filterXMLString = this._parserFilterToString(filterTmp);
		        updateStr += '<wfs:Update typeName="' + typeName + '" handle="Update ' + i + '">' +
			        propertyString +
			        filterXMLString +
		        '</wfs:Update>';
        	}
        }
        return updateStr;
        /*
        for (var i = 0; i < filter.fids.length; i++) {
	        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete ' + i + '">';
	        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [filter.fids[i]]});
	        //解析filter对象，转换为XML字符串。
	        deleteStr += this._parserFilterToString(filterTmp);
	        deleteStr += '</wfs:Delete>';
        };
        */
    },
	
	/**
     * Method: _getUpdatePropertyString
     * 获取修改的要素属性的XML字符串。 
     * 
     * Parameters:
     * feature - {<GeoGlobe.Feature>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素属性的XML字符串。
	 */
    _getUpdatePropertyString: function(feature){
        var str = "";
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
            str += '<wfs:Property>' +
	            '<wfs:Name><![CDATA[' +
	            item +
	            ']]></wfs:Name>' +
	            '<wfs:Value><![CDATA[' +
	            (feature.data[item] ? feature.data[item] : "") +
	            ']]></wfs:Value>' +
            '</wfs:Property>';
        }
        str += '<wfs:Property>' +
	        '<wfs:Name>Geometry</wfs:Name>' +
	        '<wfs:Value>' +
	        this._getGeometryStringByFeature(feature) +
	        '</wfs:Value>' +
        '</wfs:Property>';
        return str;
    },
	
	/**
     * Method: _getGeometryStringByFeature
     * 获取修改的要素geometry的XML字符串。 
     * 
     * Parameters:
     * feature - {<GeoGlobe.Feature>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素geometry的XML字符串。
	 */
	_getGeometryStringByFeature: function(feature){
		var gmlFormat = new GeoGlobe.Format.GML({xy: this.xy});
        gmlFormat.buildCoordinatesNode = GeoGlobe.Function.bind(function(geometry){
			var coordinatesNode = this.createElementNS(this.gmlns, "gml:coordinates");
            coordinatesNode.setAttribute("decimal", ".");
            coordinatesNode.setAttribute("cs", ",");
            coordinatesNode.setAttribute("ts", " ");
            
            var parts = [];
            
            if (geometry instanceof GeoGlobe.LngLatBounds) {
                if (this.xy) {
                    parts.push(geometry.left + "," + geometry.bottom);
                    parts.push(geometry.right + "," + geometry.top);
                }
                else {
                    parts.push(geometry.bottom + "," + geometry.left);
                    parts.push(geometry.top + "," + geometry.right);
                }
            }
            else {
                var points = (geometry.components) ? geometry.components : [geometry];
                for (var i = 0; i < points.length; i++) {
                    if (this.xy) {
                        parts.push(points[i].x + "," + points[i].y);
                    }
                    else {
                        parts.push(points[i].y + "," + points[i].x);
                    }
                }
            }
            
            var txtNode = this.createTextNode(parts.join(" "));
            coordinatesNode.appendChild(txtNode);
            
            return coordinatesNode;
			
        }, gmlFormat);
        
		//DOMElement. A GML polygon node.
		var gmlDOMElement = gmlFormat.buildGeometryNode(feature.geometry);
		//gmlDOMElement.setAttribute("srsName", "urn:ogc:def:crs:EPSG:6.9:4326");
		var xmlParser = new GeoGlobe.Format.XML();
		var geometrtXmlStr = xmlParser.write(gmlDOMElement);
		return geometrtXmlStr;
    },
	
	/**
     * Method: _getDeleteString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * deletes - {object} 删除要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
	 /*
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        
        var deleteStr = "";
        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete 1">';
        deleteStr += filterXMLString;
        deleteStr += '</wfs:Delete>';
        return deleteStr;
    },
    */
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        var deleteStr = "";
		for (var i = 0; i < filter.fids.length; i++) {
	        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete ' + i + '">';
	        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [filter.fids[i]]});
	        //解析filter对象，转换为XML字符串。
	        deleteStr += this._parserFilterToString(filterTmp);
	        deleteStr += '</wfs:Delete>';
        };
        return deleteStr;
    },
	
	/**
     * Method: _parserFilterToString
     * 解析filter对象，转换为XML字符串。
     * 
     * Parameters:
     *  filter - {<GeoGlobe.Filter>} 可选 操作要素的条件过滤器。
     *
     * Returns:
     * {String} 过滤器字符串。
	 */
    _parserFilterToString: function(filter){
		//解析filter对象，转换为XML字符串。
		var filterXMLString = "";
        if (filter) {
            var filterFormatter = new GeoGlobe.Format.Filter.v1();
            var result = filterFormatter.write(filter);//{DOMElement} An ogc:Filter element.
			var xmlParser = new GeoGlobe.Format.XML();
			filterXMLString = xmlParser.write(result);
			return filterXMLString;
        }
		return filterXMLString;
	},
	
    CLASS_NAME: "GeoGlobe.Service.WFST"
});
﻿/**
 * Class: GeoGlobe.Service.CTS
 * CTS坐标转换服务。
 * 坐标转换服务是GeoGlobe Server的应用服务之一。
 * 主要用于坐标投影转换、坐标仿射变换
 *
 * Inherits from:
 * - <GeoGlobe.Service>
 */
GeoGlobe.Service.CTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * Constructor: GeoGlobe.Service.CTS
     * GeoGlobe.Service.CTS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息的XML。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CTS"
            //VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CTS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     * APIMethod: TransCoords
     * 坐标投影转换,并返回变换的结果。
     *
     * Parameters:
     * params - {Object} 请求参数
     * FORMAT -{string} 输出方式(XML或JSON)，默认为XML
     * FROMEPSG -{string} 原始EPSG号
     * TOEPSG -{string} 目标EPSG号
     * COORDINATE -{string} 需转换的坐标串，中间以逗号隔开
     * DIM -{string} 二维(2)，缺省值为2
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     */
    TransCoords: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "CTS",
            //VERSION: "1.0.0",
            REQUEST: "TransCoords"
        };

        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);

        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            if(params.FORMAT == "xml"){
                var json = {};
                var xml = result.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                var obj = this.xmltoJson(xml);
                json.attributes = obj.CTS_TransResult["cts:Coordinate"].attributes.dim;
                var coords = obj.CTS_TransResult["cts:Coordinate"].text;
                var arr = coords.split(",");
                var intcoord = [];
                for(var i = 0; i< arr.length;i++){
                    intcoord.push(arr[i]);
                }
                json.coordvalue = intcoord;
            }else if(params.FORMAT == "json"){
                var json = {};
                var obj = result.responseText;
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                json.attributes = geojson.CTS_TransResult.dim;
                json.coordvalue = geojson.CTS_TransResult.Coordinate;
            }
            successFn(json);
        }, failFn);
    },
    xmltoJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmltoJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmltoJson(item));
                }
            }
        }
        return obj;
    },
    /**
     * APIMethod: AffineTransform
     * 坐标仿射变换。
     *
     * Parameters:
     * params - {Object} 请求参数。
     * FORMAT -{string} 输出方式(XML或JSON)，默认为XML
     * COORDINATE -{string} 需转换的坐标串，中间以逗号隔开
     * DIM -{string} 二维(2)，缺省值为2
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     */
    AffineTransform: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "CTS",
            //VERSION: "1.0.0",
            REQUEST: "AffineTransform"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);

        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            if(params.FORMAT == "xml"){
                var json = {};
                var xml = result.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                var obj = this.xmltoJson(xml);
                json.attributes = obj.CTS_AffineTransResult["cts:Coordinate"].attributes.dim;
                var coords = obj.CTS_AffineTransResult["cts:Coordinate"].text;
                var arr = coords.split(",");
                var intcoord = [];
                for(var i = 0; i< arr.length;i++){
                    intcoord.push(arr[i]);
                }
                json.coordvalue = intcoord;
            }else if(params.FORMAT == "json"){
                var json = {};
                var obj = result.responseText;
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                json.attributes = geojson.CTS_AffineTransResult.dim;
                json.coordvalue = geojson.CTS_AffineTransResult.Coordinate;
            }
            successFn(json);
        }, failFn);
    },

    CLASS_NAME: "GeoGlobe.Service.CTS"
});
﻿/**
 * Class: GeoGlobe.Service.VTS
 * VTS服务类。矢量瓦片服务,主要用于支持MapBox的protobuffer格式的矢量瓦片数据，并兼容OGC的WMTS服务
 * 本服务提供获取矢量瓦片的样式、和数据。
 *
 * Inherits from:
 * - <GeoGlobe.Service>
 */
GeoGlobe.Service.VTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * Constructor: GeoGlobe.Service.VTS
     * GeoGlobe.Service.WFST类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var info =[];
            var capabilities;
            var layers =[];
            json = json.Capabilities;
            if(json.Contents.Layer.length){
                for(var i =0; i <json.Contents.Layer.length;i++){
                    layers.push(json.Contents.Layer[i]);
                }
            }else{
                layers.push(json.Contents.Layer);
            }
            for(var s =0 ; s < layers.length; s++){
                capabilities = {};
                capabilities.version = json.attributes.version;
                capabilities.format = layers[s].Format[4].text;
                capabilities.LayerIdentifier = layers[s].Identifier.text;
                capabilities.StyleIdentifier =  layers[s].Style.Identifier.text;
                capabilities.MatrixSet = layers[s].TileMatrixSetLink[0].TileMatrixSet.text;
                if(layers[s].BoundingBox){
                    capabilities.Bounding = layers[s].BoundingBox;
                }
                var Scales = "";
                var lvlHtml ="";
                for(var m = 0; m < json.Contents.TileMatrixSet.length; m++){
                    if(json.Contents.TileMatrixSet[m].Identifier.text == capabilities.MatrixSet){
                        var Matrix = json.Contents.TileMatrixSet[m];
                    }
                }
                capabilities.mapCRS = Matrix.SupportedCRS.text;
                var matrixs = Matrix.TileMatrix;
                //capabilities.initZoom = matrixs.Identifier.text;
                if(matrixs.length > 0) {
                    for(var i=0, len=matrixs.length; i<len; i++) {
                        if(i == len){
                            break;
                        }
                        lvlHtml += (matrixs[i].Identifier.text +",");
                        Scales += (matrixs[i].ScaleDenominator.text + ",");
                    }
                    capabilities.zoomLevel =  lvlHtml.substr(0,lvlHtml.length - 1);
                    capabilities.Scales =  Scales.substr(0,Scales.length - 1);
                    capabilities.zoomOffset = matrixs[0].Identifier.text;
                    capabilities.initZoom = matrixs[0].Identifier.text;
                }
                info[s] = capabilities;
            }
            successFn(info,json);
        }, failFn);
    },

    xmlToJson:function(xml){
    // Create the return object
    var obj = {};
    if (xml.nodeType == 1) { // element
        // do attributes
        if (xml.attributes.length > 0) {
            obj["attributes"] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
                var attribute = xml.attributes.item(j);
                obj["attributes"][attribute.nodeName] = attribute.nodeValue;
            }
        }
    } else if (xml.nodeType == 3) { // text
        obj = xml.nodeValue;
    }
    // do children
    if (xml.hasChildNodes()) {
        for(var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);
            var nodeName = item.nodeName.replace('ows:','');
            nodeName = nodeName.replace('#','');
            if (typeof(obj[nodeName]) == "undefined") {
                obj[nodeName] = this.xmlToJson(item);
            } else {
                if (typeof(obj[nodeName].push) == "undefined") {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }
                obj[nodeName].push(this.xmlToJson(item));
            }
        }
    }
    return obj;
},

    GetTile:function(options, successFn, failFn){
        var params = {
            REQUEST: "GetTile",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.tileMatrixSet) {
            params.TILEMATRIXSET = options.tileMatrixSet;
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.TILEMATRIX ) {
            params.TILEMATRIX = options.TILEMATRIX;
        }
        if(options.TILEROW ) {
            params.TILEROW = options.TILEROW;
        }
        if( options.TILECOL) {
            params.TILECOL = options.TILECOL;
        }
        var config = {};
        config.url = this.url;
        config.param = params;
        //GeoGlobe.Request.issue(config);
        var url = this.urlAppend(config.url,
            this.getParameterString(config.param || {}));
        return url;
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Function: urlAppend
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *
     * Parameters:
     * url - {String} The url to append to
     * paramStr - {String} The param string to append
     *
     * Returns:
     * {String} The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    /**
     * APIMethod: GetStyleName
     * 获取基于MapboxGL样式名称。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    GetStyleName: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
                var obj = result.responseText;
				if(!obj){
	        		failFn();
	        		return false;
	        	}
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                var styleName =[];
                if(geojson.style){
                    for(var n =0;n <geojson.style.length;n++){
                        styleName.push(geojson.style[n].styleName);
                    }
                }else if(geojson.styleName){
                    for(var s = 0; s < geojson.styleName.length;s++){
                        styleName.push(geojson.styleName[s]);
                    }
                }

                //var style = geojson.style[0];
                successFn(styleName);
            },
            failure: failFn
        });
    },

    /**
     * APIMethod: GetStyle
     * 获取基于MapboxGL样式数据（用json描述）。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    GetStyle: function(styleName,successFn, failFn){
        var url = this.url;
        if(styleName =="" || styleName == undefined){
            alert("请查看样式名称是否存在");
            return ;
        }
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0",
            STYLENAME:styleName
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        GeoGlobe.Request.GET({
        	url: url, 
	       	params: params,
	       	scope: this,
	       	async: this.async,
        	success: function(result){
	        	var obj = result.responseText;
				if(!obj){
					failFn();
					return false;
				}
	            var jformat = new GeoGlobe.Format.JSON();
                var style = jformat.read(obj);
                //var style = geojson.style[0];
                successFn(style);
        	}, 
      		failure: failFn
        });
    },

    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    CLASS_NAME: "GeoGlobe.Service.VTS"
});﻿/**
 * Class: GeoGlobe.Service.WMS
 * OGC-WMS服务类。
 *
 * Inherits from:
 * - <GeoGlobe.Service>
 */
GeoGlobe.Service.WMS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * Constructor: GeoGlobe.Service.WMS
     * GeoGlobe.Service.WMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url,  options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var capabilities ={};
            var jsonOnj = json.WMT_MS_Capabilities;
            var Layer = jsonOnj.Capability.Layer.Layer;
            var request_service =jsonOnj.Capability.Request;
            var layers;
            if(Layer.length){
                layers = Layer[0];
            }else{
                layers = Layer;
            }
            capabilities.version = jsonOnj.attributes.version;
            capabilities.format = request_service.GetMap.Format[1].text;
            capabilities.layer = layers.Title.text;
            capabilities.bbox = layers.BoundingBox.attributes.SRS;
            capabilities.maxExtent = jsonOnj.Capability.Layer.LatLonBoundingBox.attributes;
            successFn(capabilities,json);
        },failFn);
    },

    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    xmlToJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmlToJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmlToJson(item));
                }
            }
        }
        return obj;
    },
    /**
     * APIMethod: getMap
     * 获取地图内容操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMS标准。
     * 	version - {String} 版本，默认值是1.1.1。
     *  layers - {String} 图层名称。
     *  styles - {String}  样式，默认是空串。
     *  srs -  - {String} 默认值是"EPSG:4326"。
     *  width - {Integer} 必选 宽。
     *  height - {Integer} 必选 长。
     *  format - {String} 默认值是"image/jpeg"。
     *  bbox  - {String} 必选 范围。
     * Returns:
     * {String} 地图内容图片地址。
     *
     * 示例:
     * (code)
     * var url = wmsService.getMap({
     *     layers: "basic",
     *     bbox: "-180,-90,180,270",
     *     width: 256,
     *     height: 256
     * });
     * (end)
     */
    getMap: function(options){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WMS",
            request: "GetMap",
            TRANSPARENT: true
        };
        var params = {};
        if( options.layers ) {
            params.LAYERS = options.layers;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.bbox) {
            params.BBOX = '{bbox-epsg-3857}';
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.SRS ) {
            params.SRS = options.SRS;
        }
		if (options.styles) {
            params.STYLES = options.styles;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
       // var paramsString = GeoGlobe.Util.getParameterString(params);
       //var wms_url = GeoGlobe.Util.urlAppend(url, paramsString);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Function: urlAppend
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *
     * Parameters:
     * url - {String} The url to append to
     * paramStr - {String} The param string to append
     *
     * Returns:
     * {String} The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    CLASS_NAME: "GeoGlobe.Service.WMS"
});﻿/**
 * Class: GeoGlobe.Service.WMTS
 * OGC-WMTS服务类。
 *
 * Inherits from:
 * - <GeoGlobe.Service>
 */
GeoGlobe.Service.WMTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * Constructor: GeoGlobe.Service.WMTS
     * GeoGlobe.Service.WMTS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url,  options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMTS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var jsonOnj = json.Capabilities;
            var capabilities = {};
            var layers = jsonOnj.Contents.Layer;
            if(layers.length){
                layers = layers[0];
            }else{
                layers = layers;
            }
            
            capabilities.version = jsonOnj.attributes.version;
            var contents = jsonOnj.Contents;
            capabilities.layer = layers.Title.text;
            capabilities.LayerIdentifier = layers.Identifier.text;
            capabilities.StyleIdentifier =  layers.Style.Identifier.text;
            capabilities.MatrixSet = layers.TileMatrixSetLink[0].TileMatrixSet.text;
            capabilities.Format = layers.Format[1].text;
            capabilities.Bounding = layers.BoundingBox;
            var Scales = "";
            var matrixs = contents.TileMatrixSet[0].TileMatrix;
            if(matrixs.length > 0) {
//							for(var i = 0; i < matrixs.length; i++) {
                for(var i=0, len=matrixs.length; i<len; i++) {
                    if(i == len){
                        break;
                    }
                    Scales += (matrixs[i].ScaleDenominator.text + ",");
                }
            }
            capabilities.Scales =  Scales.substr(0,Scales.length - 1);
            capabilities.zoomOffset = matrixs[0].Identifier.text;
            successFn(capabilities,json);

        },failFn);
    },
    xmlToJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmlToJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmlToJson(item));
                }
            }
        }
        return obj;
    },
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMTS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     * APIMethod: getTile
     * 获取瓦片内容操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
     * service - {String} 默认值是"WMTS"。
     * version - {String} 默认值是"1.0.0"。
     * layer - {String} 必选 图层标示。
     * style - {String} 必选 图层样式标示。
     * format - {String} 默认值是"image/png"。
     * TileMatrixSet - {String} 必选 矩阵集。
     * TileMatrix - {String} 必选 矩阵。
     * TileRow - {Integer} 必选 瓦片行号。
     * TileCol - {Integer} 必选 瓦片列号。
     *
     * Returns:
     * {String} 瓦片内容图片地址。
     *
     * 示例：
     * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
     * (end)
     */
    getTile:function(options){
        var DEFAULT_PARAMS = {
            service: "WMTS",
            request: "GetTile"
        };
        var params = {};
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.tileMatrixSet) {
            params.TILEMATRIXSET = options.tileMatrixSet;
        }
        if( options.TILEMATRIX ) {
            params.TILEMATRIX = options.TILEMATRIX;
        }
        if(options.TILEROW ) {
            params.TILEROW = options.TILEROW;
        }
        if( options.TILECOL) {
            params.TILECOL = options.TILECOL;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.style ) {
            params.STYLE = options.style;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Function: urlAppend
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *
     * Parameters:
     * url - {String} The url to append to
     * paramStr - {String} The param string to append
     *
     * Returns:
     * {String} The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    /**
     * APIMethod: getCapabilitiesForRest
     * WMTS-RESTful的获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilitiesForRest: function(successFn, failFn){
        var version = "1.0.0";
        var docName = "WMTSCapabilities.xml";
        var path = version + "/" + docName;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
        url = url + path;

        if (!failFn) {
            failFn = function(){
                this.failFn("GetCapabilities");
            };
        }

        GeoGlobe.loadURL(url, null, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * APIMethod: getTileForRest
     * WMTS-RESTful的获取瓦片内容操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
     *
     * Returns:
     * {String} 瓦片内容图片地址。
     * 	layer - {String} 必选 图层标示。
     * 	style - {String} 必选 图层样式标示。
     * 	format - {String} 必选 瓦片图片格式。默认值是"image/png"。
     * 	TileMatrixSet - {String} 必选 矩阵集。
     * 	TileMatrix - {String} 必选 矩阵。
     * 	TileRow - {Integer} 必选 瓦片行号。
     * 	TileCol - {Integer} 必选 瓦片列号。
     *
     * 示例：
     * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
     * (end)
     */
    getTileForRest: function(params){
        var layer = params.layer;
        var style = params.style;
        var tileMatrixSet = params.tileMatrixSet;
        var tileMatrix = params.tileMatrix;
        var tileRow = params.tileRow;
        var tileCol = params.tileCol;

        var formatSuffix = null;
        var format = params.format ? params.format : "image/png";
        var formatSuffixMap = {
            "image/png": "png",
            "image/png8": "png",
            "image/png24": "png",
            "image/png32": "png",
            "png": "png",
            "image/jpeg": "jpg",
            "image/jpg": "jpg",
            "jpeg": "jpg",
            "jpg": "jpg"
        };
        if (!formatSuffix) {
            formatSuffix = formatSuffixMap[format] || format.split("/").pop();
        }

        var path = layer + "/" + style + "/" + tileMatrixSet +
            "/" + tileMatrix + "/" + tileRow + "/" + tileCol + "." + formatSuffix;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
        url = url + path;
        return url;
    },

    CLASS_NAME: "GeoGlobe.Service.WMTS"
});/**
 * Class: GeoGlobe.Service.DTJ
 * 地统计分析类。
 */
GeoGlobe.Service.DTJ = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * Constructor: GeoGlobe.Service.DTJ
     * GeoGlobe.Service.DTJ类构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     */
    initialize: function(name,url,options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            successFn(json);

        },failFn);
    },

    getMap:function(options, successFn, failFn){
        var DEFAULT_PARAMS = {
            request: "GetMap",
            service:"WMS",
            version:"1.1.1"
        };
        var params = {};
        if( options.layers ) {
            params.LAYERS = options.layers;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.bbox) {
            params.BBOX = '{bbox-epsg-3857}';
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.interval ) {
            params.INTERVAL = options.interval;
        }
        if(options.GRADSIZE ) {
            params.GRADSIZE = options.GRADSIZE;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.intervalcolor) {
            params.INTERVALCOLOR = options.intervalcolor;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLATIONMETHOD = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },

    getStatisticInfo: function(options, successFn, failFn) {
        var DEFAULT_PARAMS = {
            request: "GetStatisticalValue",
            service:"WMS",
            version:"1.1.1"
        };
        var params = {};
        if( options.layers ) {
            params.LAYERNAME = options.layers;
        }
        if( options.lnglat ) {
            params.X = options.lnglat.lng;
            params.Y = options.lnglat.lat;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.INTERPOLATIONMETHOD) {
            params.INTERPOLATIONMETHOD = options.INTERPOLATIONMETHOD;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLAION = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        //var feature = this.getStatisticValue(url);
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            if(json.FeatureCollection.featureMember) {
                var jsonMemebr = json.FeatureCollection.featureMember;
                successFn(jsonMemebr);
            }

        },failFn);
    },

    /**
     * Method: getCommonParams
     * 获取公共的参数
     *
     * Parameters:
     * 	options
     */
    getParams: function(options) {
        var params = {
            request: "GetMap",
            service:"WMS",
            version:"1.1.1"
        };
        GeoGlobe.Util.extend(params,options);
        return params;
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Function: urlAppend
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *
     * Parameters:
     * url - {String} The url to append to
     * paramStr - {String} The param string to append
     *
     * Returns:
     * {String} The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },
    xmlToJson: function(xml) {
    // Create the return object
    var obj = {};
    if (xml.nodeType == 1) { // element
        // do attributes
        if (xml.attributes.length > 0) {
            obj["attributes"] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
                var attribute = xml.attributes.item(j);
                obj["attributes"][attribute.nodeName] = attribute.nodeValue;
            }
        }
    } else if (xml.nodeType == 3) { // text
        obj = xml.nodeValue;
    }
    // do children
    if (xml.hasChildNodes()) {
        for(var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);
            var nodeName = item.nodeName.replace('ows:','');
            nodeName = nodeName.replace('#','');
            if (typeof(obj[nodeName]) == "undefined") {
                obj[nodeName] = this.xmlToJson(item);
            } else {
                if (typeof(obj[nodeName].push) == "undefined") {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }
                obj[nodeName].push(this.xmlToJson(item));
            }
        }
    }
    return obj;
},

    CLASS_NAME:"GeoGlobe.Service.DTJ"

});

/**
 * Class: GeoGlobe.Service.Fonts
 * OGC-Fonts服务类。
 * 字体服务的getcapabilities
 */

GeoGlobe.Service.Fonts = GeoGlobe.Class4OL(GeoGlobe.Service, {
    /**
     * Constructor: GeoGlobe.Service.Fonts
     *  GeoGlobe.Service.Fonts类的构造函数。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },
    /**
     *  获取服务信息
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "FLS",
            VERSION: "1.0"
        };
        //创建失败回调函数
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            var obj = result.responseText;
            var jformat = new GeoGlobe.Format.JSON();
            var geojson;
            geojson = (obj) ? jformat.read(obj): {};
            successFn(geojson);
        }, failFn);
        //GeoGlobe.loadURL(url, params, this, function(result){
        //    var doc = result.responseXML;
        //    GeoGlobe.Function.bind(this.xmlToJson, this);
        //    var json = this.xmlToJson(doc);
        //    var info =[];
        //    var capabilities;
        //    json = json.Capabilities;
        //    capabilities = {};
        //    capabilities.version = json.font.version;
        //
        //    info[s] = capabilities;
        //    successFn(info,json);
        //}, failFn);
    },

    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "FLS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    GetFont: function(successFn, failFn) {
        var url = this.url;
        var params = {
            REQUEST: "GetFont",
            SERVICE: "FLS",
            VERSION: "1.0"
        };
        if (!failFn) {
            failFn = function () {
                this.failFn(params.REQUEST);
            };
        }
    },
        getParameterString : function(params) {
            var paramsArray = [];
            for (var key in params) {
                var value = params[key];
                if ((value != null) && (typeof value != 'function')) {
                    var encodedValue;
                    if (typeof value == 'object' && value.constructor == Array) {
                        /* value is an array; encode items and separate with "," */
                        var encodedItemArray = [];
                        var item;
                        for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                            item = value[itemIndex];
                            encodedItemArray.push(encodeURIComponent(
                                    (item === null || item === undefined) ? "" : item)
                            );
                        }
                        encodedValue = encodedItemArray.join(",");
                    }
                    else {
                        /* value is a string; simply encode */
                        encodedValue = value;
                    }
                    paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
                }
            }

            return paramsArray.join("&");
        },

        /**
         * Function: urlAppend
         * Appends a parameter string to a url. This function includes the logic for
         * using the appropriate character (none, & or ?) to append to the url before
         * appending the param string.
         *
         * Parameters:
         * url - {String} The url to append to
         * paramStr - {String} The param string to append
         *
         * Returns:
         * {String} The new url
         */
        urlAppend: function(url, paramStr) {
            var newUrl = url;
            if(paramStr) {
                var parts = (url + " ").split(/[?&]/);
                newUrl += (parts.pop() === " " ?
                    paramStr :
                    parts.length ? "&" + paramStr : "?" + paramStr);
            }
            return newUrl;
        },
        CLASS_NAME: "GeoGlobe.Service.Fonts"
    });/**
 * Class: GeoGlobe.Statistic
 * 地统计分析类。
 */
GeoGlobe.Statistic = GeoGlobe.Class({

    /**
     * APIProperty: url
     * {String} 叠置分析操作所需要的WPS服务地址。
     */
    url: null,

    /**
     * APIProperty: type
     * {String} 叠置分析操作类型。
     */
    type:"intersection",


    /**
     * Constructor: GeoGlobe.Statistic
     * GeoGlobe.Statistic类构造函数。
     *
     * Parameters:
     * url - {String} 服务地址
     * options - {Object} 相关属性的设置项，可选
     */
    initialize: function(url,options){
        this.url = url;
        GeoGlobe.Util.extend(this, options);
    },
    paramUrl:function(options, successFn, failFn){
        var params = this.getParams({
            request: "GetMap"
        });
        if( options.layers ) {
            params.LAYERS = options.layers;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.bbox) {
            params.BBOX = '{bbox-epsg-3857}';
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.interval ) {
            params.INTERVAL = options.interval;
        }
        if(options.GRADSIZE ) {
            params.GRADSIZE = options.GRADSIZE;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.intervalcolor) {
            params.INTERVALCOLOR = options.intervalcolor;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLATIONMETHOD = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        var config = {};
        config.url = this.url;
        config.param = params;
        //GeoGlobe.Request.issue(config);
        var url = this.urlAppend(config.url,
           this.getParameterString(config.param || {}));
        return url;
    },

    getStatisticInfo: function(options, successFn, failFn) {
        var params = this.getParams({
            request: "GetStatisticalValue"
        });
        if( options.layers ) {
            params.LAYERNAME = options.layers;
        }
        if( options.lnglat ) {
            params.X = options.lnglat.lng;
            params.Y = options.lnglat.lat;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.INTERPOLATIONMETHOD) {
            params.INTERPOLATIONMETHOD = options.INTERPOLATIONMETHOD;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLAION = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        var config = {};
        config.url = this.url;
        config.param = params;
        //GeoGlobe.Request.issue(config);
        var url = this.urlAppend(config.url,
            this.getParameterString(config.param || {}));
        var feature = this.getStatisticValue(url);
       return feature;
    },

    /**
     * Method: getCommonParams
     * 获取公共的参数
     *
     * Parameters:
     * 	options
     */
    getParams: function(options) {
        var params = {
            request: "GetMap",
            service:"WMS",
            version:"1.1.1"
        };
        GeoGlobe.Util.extend(params,options);
        return params;
    },

   getParameterString : function(params) {
    var paramsArray = [];
    for (var key in params) {
        var value = params[key];
        if ((value != null) && (typeof value != 'function')) {
            var encodedValue;
            if (typeof value == 'object' && value.constructor == Array) {
                /* value is an array; encode items and separate with "," */
                var encodedItemArray = [];
                var item;
                for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                    item = value[itemIndex];
                    encodedItemArray.push(encodeURIComponent(
                            (item === null || item === undefined) ? "" : item)
                    );
                }
                encodedValue = encodedItemArray.join(",");
            }
            else {
                /* value is a string; simply encode */
                encodedValue = value;
            }
            paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
        }
    }

    return paramsArray.join("&");
},

/**
 * Function: urlAppend
 * Appends a parameter string to a url. This function includes the logic for
 * using the appropriate character (none, & or ?) to append to the url before
 * appending the param string.
 *
 * Parameters:
 * url - {String} The url to append to
 * paramStr - {String} The param string to append
 *
 * Returns:
 * {String} The new url
 */
urlAppend: function(url, paramStr) {
    var newUrl = url;
    if(paramStr) {
        var parts = (url + " ").split(/[?&]/);
        newUrl += (parts.pop() === " " ?
            paramStr :
            parts.length ? "&" + paramStr : "?" + paramStr);
    }
    return newUrl;
},
    getStatisticValue: function(url ){
        var wmsUrl = url;
        var newTUrl = Cfg.proxyHostUrl+wmsUrl;
        //获取服务请求值
        Cfg.url = url;
        var request = sendAjaxRequest(newTUrl,dataChange);
        var doc = request.responseXML;
        var json = xmlToJson(doc);
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc){
            alert("服务不可用!");
            return;
        }
        if(json.FeatureCollection.featureMember){
            var jsonMemebr = json.FeatureCollection.featureMember;
            return jsonMemebr;
        }else{
            alert("服务不可用!");
        }

    },

    CLASS_NAME:"GeoGlobe.Statistic"

});

/**
 * Class: GeoGlobe.ElementContainer
 * gl地图的前置容器。
 */
GeoGlobe.ElementContainer = GeoGlobe.Class4OL({

	id: null,
	
    /**
     * Property: map
     * {String} gl地图对象。
     */
    map: null,

    /**
     * Constructor: GeoGlobe.ElementContainer
     * GeoGlobe.ElementContainer构造函数。
     *
     * Parameters:
     * options - {Object} 参数对象
     */
    initialize: function(options){
		this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
		GeoGlobe.Util.extend(this, options);
    },
	
    /**
     * Method: addTo
     * 与地图对象关联
     * 
     * Parameters:
     * map - {Object} map对象
     */
    addTo: function (map){
		this.map = map;
        var mapContainer = map.getCanvasContainer();
		if(!map.eleContainer){
			//创建eleContainer
			var eleContainer = GeoGlobe.DOM.create("div", "geoglobe-element-container", mapContainer);
			eleContainer.style.width = map.getCanvas().style.width;
			eleContainer.style.height = map.getCanvas().style.height;
			eleContainer.style.position = "absolute";
			map.eleContainer = eleContainer;
		}
		
		//创建container
		this.container = GeoGlobe.DOM.create("div", null, map.eleContainer);
		this.container.style.width = map.getCanvas().style.width;
		this.container.style.height = map.getCanvas().style.height;
		this.container.style.position = "absolute";
		
		map.isIntScrollZoom = true;//缩放级别是否为整数处理模式
		this._resize = GeoGlobe.Function.bind(this._resize, this);
		map.on('resize', this._resize);
    },
	
	/**
     * Method: _resize
     * map大小改变时
     */
	_resize: function(){
		var map = this.map;
		map.eleContainer.style.width = map.getCanvas().style.width;
		map.eleContainer.style.height = map.getCanvas().style.height;
		this.container.style.width = map.getCanvas().style.width;
		this.container.style.height = map.getCanvas().style.height;
	},
	
    /**
     * APIMethod: getElMap
     * 获取elmap。
     */
	getElMap: function(){
		return this.elmap;
	},
	
    /**
     * APIMethod: remove
     * 移除并销毁。
     *
     */
    remove: function(){
		var map = this.map;
		map.off('resize', this._resize);
    },
	
    CLASS_NAME: "GeoGlobe.ElementContainer"
});/**
 * Class: GeoGlobe.MaptalksEle
 * gl地图的前置maptalks容器。
 */
GeoGlobe.MaptalksEle = GeoGlobe.Class4OL(GeoGlobe.ElementContainer, {

    /**
     * Property: map
     * {String} gl地图对象。
     */
    map: null,
	
    /**
     * Property: container
     * {Object} maptalks map的容器。
     */
    container: null,
	
    /**
     * Property: elmap
     * {Object} maptalks map对象。
     */
    elmap: null,
	
    /**
     * APIProperty: elmapOptions
     * {Object} maptalks map的构造选项。
     */
	elmapOptions: null,

    /**
     * Constructor: GeoGlobe.MaptalksEle
     * GeoGlobe.MaptalksEle构造函数。
     *
     * Parameters:
     * options - {Object} 参数对象
     */
    initialize: function(options){
        GeoGlobe.ElementContainer.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: addTo
     * 与gl地图对象关联
     * 
     * Parameters:
     * map - {Object} gl地图对象
     */
    addTo: function (map){
		GeoGlobe.ElementContainer.prototype.addTo.apply(this, arguments);
		
		this.container.id = this.id;
		this.container.className = "geoglobe-maptalks-container";
		
		if (window.maptalks && window.maptalks.Map) {
			GeoGlobe.MaptalksEle.overrideMapTalksFunc();
			var center = this.map.getCenter();
			//maptalks map的构造选项
			var _opt = GeoGlobe.Util.extend({
				zoom: this.map.getZoom() + 1,
				//spatialReference:{
		        //  projection:'EPSG:3857'
		        //},
	        	center: [center.lng, center.lat]
			}, this.elmapOptions);
			this.elmap = new maptalks.Map(this.container.id, _opt);
			this._bindEvent();
		}else{
			console.log("使用前置maptalks容器，需引入maptalks地图库。");
		}
    },
	
    /**
     * Method: _bindEvent
     * 绑定事件
     */
	_bindEvent: function(){
		var map = this.map;
		//移动开始时，缩放开始时，旋转开始时。
		this._movestart = GeoGlobe.Function.bind(function(e){//movestart 在zoomstart之前触发
			if(this._zooming){
				this._zooming = false;//缩放途中，突然拖动地图，会打断缩放操作且会触发movestart，所以要重置this._zooming为false。
				this._iszoomend = true;
			}
		}, this);
		//移动中
		this._move = GeoGlobe.Function.bind(function(e){
			if(this._zooming == true || this._rotating == true){
				return;
			}
			this.elmap._moving = true;
			this.syncElmapCenter();
			return;
		}, this);
		//移动结束后，缩放结束后，旋转结束后。
		this._moveend = GeoGlobe.Function.bind(function(e){
			this.elmap._moving = false;
			this.elmap._dragRotating = false;
			this._zooming = false;
			this._rotating = false;
			var zoom = this.map.getZoom();
			if(Math.ceil(zoom) !== zoom){//如果不是整数，则恢复整数级别
				this.map.setZoom(Math.ceil(zoom));
			}
			if(this._iszoomend){//1.如果一个缩放操作结束，则执行。2.如果在一个缩放操作在过程中move，move结束后也执行。
				this._iszoomend = false;
				var zoom = this.map.getZoom() + 1;
				var _pos = e.target.scrollZoom._pos ? e.target.scrollZoom._pos : e.point;
				//44版本
				if(!_pos){
					_pos = e.target.scrollZoom._aroundPoint;
				}
				//44版本 end
				var origin = new maptalks.Point(_pos.x, _pos.y);
				this.elmap._zoomTo(zoom, origin);
				this.elmap._zooming = false;
				this.elmap._getRenderer().onZoomEnd();
				this.elmap._fireEvent('zoomend', { 'from': this.elmap._startZoomVal, 'to': zoom });
				this.syncElmapCenter();
				return;
			};
			var center = this.map.getCenter();
			this.elmap.setCenter([center.lng, center.lat]);
		}, this);
		
		//旋转开始
		this._rotatestart = GeoGlobe.Function.bind(function(e){
			this._rotating = true;
			this.elmap._dragRotating = true;
		}, this);
		//旋转中
		this._rotate = GeoGlobe.Function.bind(function(e){
			this.syncElmapRotate();
		}, this);
		
		//缩放开始
		this._zoomstart = GeoGlobe.Function.bind(function(e){
			//e.target.dragPan.disable();
			//e.target.scrollZoom.disable();
			this._zooming = true;
			this.elmap._moving = false;//因为movestart 在zoomstart之前触发，所以elmap._moving复原为false
			var zoom = this.map.getZoom() + 1;
			//屏幕缩放参考点
			var _pos = e.target.scrollZoom._pos ? e.target.scrollZoom._pos : e.point;
			//44版本
			if(!_pos){
				_pos = GeoGlobe.DOM.mousePos(e.target.scrollZoom._el, e.originalEvent);
			}
			//44版本 end
			var origin = new maptalks.Point(_pos.x, _pos.y);
			this.origin_lnglat = this.map.unproject(_pos);
			this.elmap.onZoomStart(zoom, origin);//此方法内会设置this.elmap._zooming = true;
		}, this);
		//缩放中
		this._zoom = GeoGlobe.Function.bind(function(e){//move 在zoom之前触发
			var center = this.map.getCenter();
			var zoom = this.map.getZoom() + 1;
			if (this.elmap._zoomLevel !== zoom) {
				var _pos = e.target.scrollZoom._pos ? e.target.scrollZoom._pos : e.point;
				//44版本
				if(!_pos){
					_pos = e.target.scrollZoom._aroundPoint;
					_pos = _pos ? _pos : GeoGlobe.DOM.mousePos(e.target.scrollZoom._el, e.originalEvent);
				}
				//44版本 end
				//屏幕缩放参考点
				var _pos2 = this.map.project(this.origin_lnglat);
				if(_pos.x !== Math.round(_pos2.x) || _pos.y !== Math.round(_pos2.y)){
					//_pos = _pos2;
					this.elmap._zooming = false;//处理
				}
				var origin = new maptalks.Point(_pos.x, _pos.y);
				this.elmap.onZooming(zoom, origin);
	        }
			var elmapCenter = this.elmap.getCenter();
			if(center.lng - elmapCenter.x > 2 || center.lng - elmapCenter.x < -2){
				this.syncElmapCenter();
			}
		}, this);
		//缩放结束时
		this._zoomend = GeoGlobe.Function.bind(function(e){//zoomend 在moveend之前触发
			this._zooming = false;
			this._iszoomend = true;
			//e.target.dragPan.enable();
			//e.target.scrollZoom.enable();
		}, this);
		
		map.on('movestart', this._movestart);
		map.on('move', this._move);
		map.on('moveend', this._moveend);
		map.on('rotatestart', this._rotatestart);
		map.on('rotate', this._rotate);
		map.on('zoomstart', this._zoomstart);
		map.on('zoom', this._zoom);
		map.on('zoomend', this._zoomend);
	},
	
	/**
     * Method: _resize
     * map大小改变时
     */
	_resize: function(){
		GeoGlobe.ElementContainer.prototype._resize.apply(this, arguments);
		this.elmap.checkSize();
	},
	
    /**
     * Method: syncElmapCenter
     * 同步elmap的中心点。
     */
	syncElmapCenter: function(){
		var center = this.map.getCenter();
		center = [center.lng, center.lat];
        if (!center) {
            return false;
        }
        center = new maptalks.Coordinate(center);
        var projection = this.elmap.getProjection();
        var _pcenter = projection.project(center);
        this.elmap._setPrjCenter(_pcenter);
	},
	
    /**
     * Method: syncElmapRotate
     * 同步elmap的bearing和pitch。
     */
	syncElmapRotate: function(){
		var map = this.map;
		if(this.elmap){
			//var center = map.getCenter();
	        var bearing = map.getBearing();
	        var pitch = map.getPitch();
			
			var cameraOptions = {
				//'center' : [center.lng, center.lat],
	            'bearing' : map.getBearing(),
	            'pitch' : map.getPitch()
	        };
			this.elmap.setView(cameraOptions);
		}
	},
	
	 /**
     * Method: _syncElmap
     * 同步elmap的view。
     */
	_syncElmap: function(){
		var map = this.map;
		if(this.elmap){
			var center = map.getCenter();
	        var zoom = map.getZoom();
	        var bearing = map.getBearing();
	        var pitch = map.getPitch();
			
			var cameraOptions = {
	            'center' : [center.lng, center.lat],
	            'zoom'   : map.getZoom() + 1,
	            'bearing' : map.getBearing(),
	            'pitch' : map.getPitch()
	        };
			this.elmap.setView(cameraOptions);
		}
	},

    /**
     * APIMethod: remove
     * 移除并销毁。
     */
    remove: function(){
		GeoGlobe.ElementContainer.prototype.remove.apply(this, arguments);
		
		var map = this.map;
		map.off('movestart', this._movestart);
		map.off('move', this._move);
		map.off('moveend', this._moveend);
		map.off('rotatestart', this._rotatestart);
		map.off('rotate', this._rotate);
		map.off('zoomstart', this._zoomstart);
		map.off('zoom', this._zoom);
		map.off('zoomend', this._zoomend);
		
		this.container.parentNode.removeChild(this.container);
		this.container = null;
		this.elmap.remove();
		this.elmap = null;
		this.map = null;
    },
	
    CLASS_NAME: "GeoGlobe.MaptalksEle"
});

GeoGlobe.MaptalksEle.overrideMapTalksFunc = function() {
	if(window.maptalks && window.maptalks.Map){
		maptalks.Map.prototype.addHandler = function(name, handlerClass) {
			//这几个handler不添加
			if(name === "draggable" || name === "touchZoom" || name === "boxZoom" || name === "doubleClickZoom" || name === "scrollWheelZoom"){
				return this;
			}
		    if (!handlerClass) {
		        return this;
		    }
		    if (!this._handlers) {
		        this._handlers = [];
		    }
		    //handler已经存在
		    if (this[name]) {
		        this[name].enable();
		        return this;
		    }
		
		    var handler = this[name] = new handlerClass(this);
		
		    this._handlers.push(handler);
		
		    if (this.options[name]) {
		        handler.enable();
		    }
		    return this;
		}
	}
}
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @requires View2D/BaseTypes/BaseTypes.js
 * @requires View2D/tool/Console.js
 */

/**
 * Namespace: GeoGlobe.Lang
 * Internationalization namespace.  Contains dictionaries in various languages
 *     and methods to set and get the current language.
 */
GeoGlobe.Lang = {
    
    /** 
     * Property: code
     * {String}  Current language code to use in GeoGlobe.  Use the
     *     <setCode> method to set this value and the <getCode> method to
     *     retrieve it.
     */
    code: null,

    /** 
     * APIProperty: defaultCode
     * {String} Default language to use when a specific language can't be
     *     found.  Default is "zh-CN".
     */
    defaultCode: "zh-CN",//en
        
    /**
     * APIFunction: getCode
     * Get the current language code.
     *
     * Returns:
     * {String} The current language code.
     */
    getCode: function() {
        if(!GeoGlobe.Lang.code) {
            GeoGlobe.Lang.setCode();
        }
        return GeoGlobe.Lang.code;
    },
    
    /**
     * APIFunction: setCode
     * Set the language code for string translation.  This code is used by
     *     the <GeoGlobe.Lang.translate> method.
     *
     * Parameters:
     * code - {String} These codes follow the IETF recommendations at
     *     http://www.ietf.org/rfc/rfc3066.txt.  If no value is set, the
     *     browser's language setting will be tested.  If no <GeoGlobe.Lang>
     *     dictionary exists for the code, the <GeoGlobe.String.defaultLang>
     *     will be used.
     */
    setCode: function(code) {
        var lang;
        if(!code) {
            code = (GeoGlobe.BROWSER_NAME == "msie") ?
                navigator.userLanguage : navigator.language;
        }
        var parts = code.split('-');
        parts[0] = parts[0].toLowerCase();
        if(typeof GeoGlobe.Lang[parts[0]] == "object") {
            lang = parts[0];
        }

        // check for regional extensions
        if(parts[1]) {
            var testLang = parts[0] + '-' + parts[1].toUpperCase();
            if(typeof GeoGlobe.Lang[testLang] == "object") {
                lang = testLang;
            }
        }
        if(!lang) {
            GeoGlobe.Console.warn(
                'Failed to find GeoGlobe.Lang.' + parts.join("-") +
                ' dictionary, falling back to default language'
            );
            lang = GeoGlobe.Lang.defaultCode;
        }
        
        GeoGlobe.Lang.code = lang;
    },

    /**
     * APIMethod: translate
     * Looks up a key from a dictionary based on the current language string.
     *     The value of <getCode> will be used to determine the appropriate
     *     dictionary.  Dictionaries are stored in <GeoGlobe.Lang>.
     *
     * Parameters:
     * key - {String} The key for an i18n string value in the dictionary.
     * context - {Object} Optional context to be used with
     *     <GeoGlobe.String.format>.
     * 
     * Returns:
     * {String} A internationalized string.
     */
    translate: function(key, context) {
        var dictionary = GeoGlobe.Lang[GeoGlobe.Lang.getCode()];
        var message = dictionary && dictionary[key];
        if(!message) {
            // Message not found, fall back to message key
            message = key;
        }
        if(context) {
            message = GeoGlobe.String.format(message, context);
        }
        return message;
    }
    
};


/**
 * APIMethod: GeoGlobe.i18n
 * Alias for <GeoGlobe.Lang.translate>.  Looks up a key from a dictionary
 *     based on the current language string. The value of
 *     <GeoGlobe.Lang.getCode> will be used to determine the appropriate
 *     dictionary.  Dictionaries are stored in <GeoGlobe.Lang>.
 *
 * Parameters:
 * key - {String} The key for an i18n string value in the dictionary.
 * context - {Object} Optional context to be used with
 *     <GeoGlobe.String.format>.
 * 
 * Returns:
 * {String} A internationalized string.
 */
GeoGlobe.i18n = GeoGlobe.Lang.translate;
/**
 * @requires View2D/tool/Lang.js
 */

/**
 * Namespace: GeoGlobe.Lang["en"]
 * Dictionary for English.  Keys for entries are used in calls to
 *     <GeoGlobe.Lang.translate>.  Entry bodies are normal strings or
 *     strings formatted for use with <GeoGlobe.String.format> calls.
 */
GeoGlobe.Lang.en = {

    'unhandledRequest': "Unhandled request return ${statusText}",

    'end': ''
    
};
/**
 * @requires View2D/tool/Lang.js
 */

/**
 * Namespace: GeoGlobe.Lang["zh-CN"]
 * Dictionary for Simplified Chinese.  Keys for entries are used in calls to
 *     <GeoGlobe.Lang.translate>.  Entry bodies are normal strings or
 *     strings formatted for use with <GeoGlobe.String.format> calls.
 */
GeoGlobe.Lang["zh-CN"] = {

    'unhandledRequest': "未处理的请求，返回值为 ${statusText}",

    'end': ''
};
